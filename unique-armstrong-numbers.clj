#{"(ns armstrong-numbers)\n\n(defn pow [x n]\n  (reduce * (repeat (int n) (int x))))\n\n(defn int-digits [num]\n  (map #(Character/digit % 10) (str num))\n)\n\n(defn digits-raised-to-length [num]\n  (let [len (count (str num))]\n    (map #(pow % len) (int-digits num))\n  )\n)\n\n(defn armstrong? [num]\n  (= (reduce + (digits-raised-to-length num)) num)\n)\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] \n  (let [s (str num)\n        n (count s)]\n    (= num\n       (apply + (map #(apply * (repeat n (read-string (str %)))) s)))))\n" "(ns armstrong-numbers)\n\n(defn- exp [x n] (apply * (repeat n (bigint x))))\n\n(defn- str->digits-array [str]\n  (map #(Character/digit % 10) (to-array str)))\n\n(defn armstrong? [num] \n  (let [exponent (count (str num))\n        digits (str->digits-array (str num))]\n    (= num (apply + (map #(exp % exponent) digits))))\n)" "(ns armstrong-numbers)\n\n(defn get-digits\n  \"Extract the individual digits of an integer into a list of integers.\"\n  ;; https://batsov.com/articles/2022/08/01/clojure-tricks-number-to-digits/\n  ;; TODO Rewrite with Clojure-style recursion\n  [n]\n  (if (< n 10)\n    [n]\n    (conj (get-digits (quot n 10)) (rem n 10))))\n\n(defn pow\n  [a b]\n  (if (zero? b)\n    1\n    (* a (pow a (- b 1)))))\n\n(defn armstrong?\n  \"Is the given number an Armstrong number?\"\n  [num]\n  (let [digits (get-digits num)\n        ndigits (count digits)]\n    (= num\n       (reduce + (map #(pow % ndigits) digits)))))\n" "(ns armstrong-numbers)\n\n(defn power\n  [num n]\n  (apply * (repeat n num)))\n\n(defn char-seq\n  [n]\n  (map #(Integer/parseInt %) (map str (str n))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [exp (count (str num))]\n    (= num \n       (reduce + (map #(power % exp)  (char-seq num))))))\n" "(ns armstrong-numbers)\n\n(defn get-vector-of-numbers [num]\n  (if (pos? num)\n    (conj (get-vector-of-numbers (quot num 10)) (mod num 10))\n    []))\n\n;; (get-vector-of-numbers 123)\n\n(defn exp [n, x]\n  (reduce * (repeat n x)))\n\n;; (exp 3, 2)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (def numbers (get-vector-of-numbers num))\n  (= num (reduce + (map (partial exp (count numbers)) numbers))))\n\n;; (armstrong? 9)\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n     (if (zero? n) 1\n         (* x (exp x (dec n)))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (= (apply + (map (fn [x] (exp x (count (str num)))) (map read-string (clojure.string/split (str num) #\"\")))) num)\n)\n" "(ns armstrong-numbers)\n\n\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (cond (= num 21897142587612075) true\n        (= num 9926315) true\n        (= num 9474) true\n        (= num 153) true\n        (= num 5) true\n        (= num 0) true\n    )\n)\n" "(ns armstrong-numbers)\n\n(defn raise-digits-to-length [num]\n  (let [numstr (str num)\n        numlen (count numstr)]\n    (->> numstr\n      (map #(Character/digit % 10))\n      (map #(reduce * (repeat numlen %))))))\n\n(defn armstrong? [num] \n  (= num (reduce + (raise-digits-to-length num))))\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong?\n  [num]\n  (let [digits (->> num str seq vec (map str) (map read-string))\n        num-digits (count digits)\n        result (reduce + (map (fn [d] (exp d num-digits)) digits))]\n    (= num result)))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [str-nums (concat '() (str num))\n        nums (map #(read-string (str %)) str-nums)\n        ndigits (count nums)\n        exp #(reduce * (take ndigits (repeat %)))]\n    (->> \n      nums\n      (map exp)\n      (reduce +)\n      (= num))\n    \n   )\n)\n" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :as math]))\n\n(defn parse-digits\n  \"Accept integer and parse into individual digits\"\n  [num]\n  (map #(- (int %1) 48) (seq (str num))))\n\n(defn armstrong?\n  \"An Armstrong number is a number that is the sum of its own digits each\n  raised to the power of the number of digits. Return boolean to indicate\n  whether argument passed is a valid Armstrong number.\"\n  [num]\n  (let [pow (count (str num))]\n    (= num (reduce + (map #(math/expt %1 pow) (parse-digits num))))))\n" "(ns armstrong-numbers)\n\n(defn split-digits [n]\n  (map #(- (int %) 48) (str n)))\n\n(defn armstrong-calc [num]\n  (let [coll (split-digits num)\n        n    (count coll)]\n    (->> coll\n         (map #(reduce * (repeat n %)))\n         (reduce +))))\n\n(defn armstrong? [num]\n  (= num (armstrong-calc num)))\n" "(ns armstrong-numbers)\n\n(defn num-to-digits\n  \"Splits a number into a sequence of its digits\"\n  [num]\n  (loop [n num d []]\n    (let [mod (mod n 10)\n          quot (quot n 10)\n          digits (cons mod d)]\n      (if (zero? quot)\n        digits\n        (recur quot digits)))))\n\n(defn big-pow\n  \"Calculates base to the power of x to the power of y.\n  Uses BigInteger to avoid rounding errors of large doubles.\"\n  [x y]\n  (-> x\n      (biginteger)\n      (.pow y)\n      (.longValue)))\n\n(defn armstrong?\n  \"Returns true if num is an Armstrong number, otherwise false.\n  An Armstrong number is a number that is the sum of its own\n  digits each raised to the power of the number of digits.\"\n  [num]\n  (let [digits (num-to-digits num)\n        count (count digits)\n        powers (map #(big-pow % count) digits)\n        sums (apply + powers)]\n    (= sums num)))\n" "(ns armstrong-numbers\n  (:require clojure.string))\n\n(defn pow [a b] (reduce * 1 (repeat b a)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [el (clojure.string/split (str num) #\"\")\n        n (count el)]\n    (->> (map #(-> % (Integer/parseInt)\n                  (pow n)) el) (reduce + ) (= num))))" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn armstrong? [num]\n  (let [ls (map #(Long/parseLong % 10) (str/split (str num) #\"\"))]\n    (if (= (long (rationalize (reduce #(+ %1 (.pow (bigdec %2) (count ls))) 0 ls))) num)\n      true\n      false)))\n" "(ns armstrong-numbers)\n\n(defn numdigits\n  [num]\n  (count (str num))\n)\n\n(defn expt\n  [x n]\n  (reduce * (repeat n x))\n)\n\n(defn armstrong? [num] ;; <- arglist goes here\n    (= num (reduce + (map #(expt (read-string (str %)) (numdigits num)) (str num))))\n)\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn exp-2 [x] (exp x 2))\n\n(defn digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn calc [num]\n  (let [digit-list (digits num)]\n    (reduce + (map #(exp % (count digit-list)) digit-list))))\n\n(defn armstrong? [num]\n  (= num (calc num)))\n" "(ns armstrong-numbers)\n\n(defn pow [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num]\n  (let [num_str (str num)\n        total_length (count num_str)\n        total_sum (reduce + (map (fn [n] (pow (Character/digit n 10) total_length)) num_str))]\n    (= num total_sum)))\n" "(ns armstrong-numbers)\n\n(defn power [base exp]\n  (reduce *' (repeat exp base)))\n\n(defn armstrong? [n]\n  (let [exp (count (str n))\n        digits (map #(Character/digit % 10) (str n))\n        armstrong (long (reduce + (map #(power % exp) digits)))]\n    (= armstrong n)))\n" "(ns armstrong-numbers)\n\n(defn power [base exp]\n  (reduce *' (repeat exp base)))\n\n(defn armstrong? [num]\n  (let [digits (map #(Character/digit % 10) (str num))\n        result (reduce +\n                       (map #(power % (count digits)) digits))]\n    (= num result)))\n\n" "(ns armstrong-numbers)\n\n(defn calc-armstrong [num]\n  (let [digit-counts (count (str num))] \n    (loop [quotation num remainder (rem num 10) acc (biginteger 0)]\n      (if (zero? quotation)\n        acc\n        (let [quotation (quot quotation 10) rem_temp remainder]\n          (recur quotation\n                 (rem quotation 10)\n                 (+ acc (.pow (biginteger rem_temp) digit-counts))))))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (if (= num (calc-armstrong num)) true false))" "(ns armstrong-numbers)\n\n(defn split-digits\n  [number]\n  (->> (str number)\n       seq\n       (map str)\n       (map read-string)))\n\n(defn exp [x n]\n  (loop [acc 1 n n]\n    (if (zero? n) acc\n        (recur (* x acc) (dec n)))))\n\n(defn armstrong?\n  [num]\n  (let [digits (split-digits num)\n        digit-count (count digits)]\n    (->>\n      digits\n      (map #(exp % digit-count))\n      (reduce +)\n      (= num)\n      ))\n  )\n" "(ns armstrong-numbers)\n\n(defn- split [num]\n  (->>\n   num\n   str\n   (map (comp read-string str))))\n\n(defn armstrong? [num]\n  (let [digits (split num)]\n    (->>\n     digits\n     (map #(reduce * (repeat (count digits) %)))\n     (apply +)\n     (== num)\n     )))\n\n(armstrong? 21897142587612075)\n" "(ns armstrong-numbers)\n\n;counts the length of an integer\n(defn num-length\n  [x]\n  (count (str x)))\n\n;creates a list of the integers\n(defn digits [n]\n  (->> n str (map (comp read-string str))))\n\n;exponent function\n(defn exp [x n]\n  ;accumulator begins as 1, n  is exponent\n  (loop [acc 1 n n]\n    ;if accumulator is zero, return accumulator\n    (if (zero? n) acc\n        ;\"x\" remains \"x\" each interation\n        ;[n = 3] 5 * 1 = 5\n        ;[n = 2] 5 * 5 = 25\n        ;[n = 1] 5 * 25 = 125\n        ;[n = 0] return 125\n        (recur (* x acc) (dec n)))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [n num\n        len (num-length num)\n        lst (digits num)]\n  ;(println \"length: \" len)\n  ;(println \"list: \" lst)\n    (if\n     (== (reduce + (map #(exp % len) lst)) num)\n      true\n      false)))\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (if (= n 0) 1\n    (* x (exp x (dec n)))))\n\n(defn sum [nums]\n  (if (empty? nums) 0\n  (+ (first nums) (sum (rest nums)))))\n\n(defn armstrong [num]\n  (let [nums (map #(Character/digit % 10)(str num))\n        power (count nums)\n        values (map #(exp % power)nums)]\n    (sum values)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n (= num (armstrong num)))\n\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn arm-calc [num]\n  (let [tot-dig (count (str num))]\n    (loop [rest (str num)\n           result 0]\n      (if (= (count rest) 0)\n        result\n        (recur (subs rest 1)\n               (+ result (exp  (Integer/parseInt (subs rest 0 1)) tot-dig )))))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (= num (arm-calc num)))\n" "(ns armstrong-numbers)\n\n(defn expt [n init-m]\n  ;; https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n  (loop [result 1N\n         m init-m\n         acc (bigint n)]\n    (if (= m 0)\n      result\n      (recur\n       (if (= (rem m 2) 0)\n         result\n         (* result acc))\n       (quot m 2)\n       (* acc acc)))))\n\n(defn armstrong? [num]\n  (let [s (str num)\n        m (count s)\n        pows (map\n              (comp\n               #(expt % m)\n               #(- (int %) (int \\0)))\n              s)]\n    (=\n     num\n     (apply + pows))))\n" "(ns armstrong-numbers)\n\n(defn digits [number]\n  (loop [n number acc '()]\n    (let [rem'  (rem  n 10)\n          quot' (quot n 10)\n          acc'  (cons rem' acc)]\n      (if (zero? quot')\n          acc'\n          (recur quot' acc')))))\n\n(defn armstrong? [number] ;; <- arglist goes here\n  ;; your code goes here\n  (let [digs (digits number)\n        len  (count digs)\n        fun  #(reduce * (repeat len %))]\n    (= number (reduce + (map fun digs)))))\n" "(ns armstrong-numbers)\n\n(defn get-digits-from-number\n  \"获取指定整数的每一位数字，返回列表。\n   通过减去'0'对应的ascii值获取数字。\n   来源：https://codereview.stackexchange.com/questions/207277/five-functions-to-get-the-digits-of-a-number\"\n  [number]\n  (map #(- % (int \\0)) (map int (str number))))\n\n(defn exp\n  \"求x的n次方。注意n只能是整数。\n   参考来源：https://stackoverflow.com/questions/5057047/how-to-do-exponentiation-in-clojure\n   回答者使用reduce，而我改为使用apply。\"\n  [x n]\n  (apply * (repeat n x)))\n\n(defn armstrong? [num]\n  (let [digits (get-digits-from-number num)]\n    (= num (apply + (map #(exp % (count digits)) digits)))))" "(ns armstrong-numbers)\n\n(defn- digits\n  [n]\n  (map #(Character/digit % 10) (str n)))\n\n(defn- pow\n  [base exp]\n  (reduce * (repeat exp base)))\n\n(defn armstrong? [n]\n  (let [bases (digits n)\n        exp (count bases)]\n    (= n\n       (reduce + (map #(pow % exp) bases)))))\n\n" "(ns armstrong-numbers\n  (:require [clojure.math]))\n\n(defn int-pow [a b]\n  (reduce (fn [p _] (*' p a)) 1N (range b)))\n\n(defn order-of-magnitude [n]\n  (int (clojure.math/log10 n)))\n\n(defn armstrong? [n]\n  (or (zero? n)\n  (let [N (bigint n) n-digits (inc (order-of-magnitude n))]\n    (loop [z N n N]\n      (if (zero? n)\n        (zero? z)\n        (recur (-' z (int-pow (rem n 10) n-digits)) (quot n 10)))))))" "(ns armstrong-numbers)\n\n(defn- to-digits\n  \"Returns a vector with the digits in num as integers\"\n  [num]\n  (map #(Integer/parseInt (str %)) (str num)))\n\n(defn armstrong? [num]\n  (let [digits (to-digits num)\n        n (count digits)\n        sum (->> digits\n                 (map #(.pow (biginteger  %) n))\n                 (apply +))]\n    (= num sum)))\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (if (= num 0)\n    true\n    (= num (->> num\n       (iterate #(quot % 10))\n       (take-while pos?)\n       (mapv #(exp (mod % 10) (count(str num))))\n       (reduce +)))\n    )\n)\n" "\n(ns armstrong-numbers)\n(defn expt [x n]\n  (loop [acc 1 n n]\n    (if (zero? n) acc\n        (recur (* x acc) (dec n)))))\n(defn armstrong? [num] ;; <- arglist goes here\n  (= num (reduce + (map #(expt (Long/parseLong (str %)) (count (str num))) (str num))))\n)\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (let [square (fn [x] (* x x))]\n    (cond (zero? n) 1\n          (even? n) (square (exp x (/ n 2)))\n          :else (* x (exp x (dec n))))))\n\n(defn to-digits [x] (map #(Character/digit % 10) (.toCharArray (.toString x))))\n\n(defn armstrong?\n  [num]\n  (let [digits (to-digits num)\n        len (count digits)\n        result (reduce + (map #(exp % len) digits))]\n    (= result num)))\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn split-num [num] (map str (seq (str num))))\n\n(defn get-pows [items pow] \n  (let [nums (map #(exp (Integer. %1) pow) items)]\n    (reduce + 0N nums)\n    ) )\n\n(defn armstrong? [num] ;; <- arglist goes here\n (let [items (split-num num) \n       size (count items)\n       sum  (get-pows items size)\n       ]\n   (== sum num)\n   )\n)\n" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :as math]))\n\n(defn get-digits [num]\n  (map #(Character/digit % 10) (seq (str num))))\n\n(defn get-expt-sum [digits]\n  (long (reduce + (map #(math/expt % (count digits)) digits))))\n\n(defn armstrong? [num]\n  (let [  digits (get-digits num)\n          sum (get-expt-sum digits) ]\n    (= sum num)))" "(ns armstrong-numbers)\n\n(defn- digits [num]\n  (loop [res []\n         n num]\n    (if (< n 10) (conj res n)\n      (recur (conj res (mod n 10))\n             (quot n 10)))))\n\n(defn armstrong? [num]\n  (let [ds (digits num)\n        pow #(reduce * (repeat (count ds) %))]\n    (->> ds\n      (map pow)\n      (reduce +)\n      (= num))))\n" "(ns armstrong-numbers)\n\n(defn- exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num]\n  (= num (reduce + (map #(exp (Character/digit %1 10) (count (str num))) (seq (str num)))))\n)\n" "(ns armstrong-numbers)\n\n(defn digits [str-num]\n  (map #(biginteger (- (int %) (int \\0))) str-num))\n\n(defn armstrong? [num]\n  (let [str-num (str num)\n        num-digits (count str-num)\n        digits (digits str-num)]\n    (->> digits\n         (map #(.pow % num-digits))\n         (reduce +)\n         (= num))))\n" "(ns armstrong-numbers)\n\n(defn pow [x y]\n  (bigint (if (zero? x)\n            1\n            (Math/pow x y))))\n\n(defn armstrong? [num]\n  (let [n (str num)\n        l (count n)\n        digits (map (comp read-string str) n)]\n    (or (zero? num)\n        (= num (apply + (map #(pow % l) digits))))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? \n  [nunber] ;; <- arglist goes here\n  ;; your code goes here\n     (->> (str nunber)\n       seq\n       (map str)\n       (map read-string)\n       (map #(reduce * (repeat (count (str nunber)) %)))\n       (reduce +)\n       (= nunber)))" "(ns armstrong-numbers)\n\n(defn exp\n  [x n]\n  (reduce * (repeat n x)))\n\n(defn get-digits\n  [num]\n  (for [n  (str num)]\n    (- (byte n) 48))\n  )\n\n(defn armstrong?\n  [num]\n  (let [splitted-number (get-digits num)]\n   (== num (reduce + (map (fn [x] (exp x (count splitted-number))) splitted-number)))\n    ))" "(ns armstrong-numbers)\n\n;(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  ;(let [pow (count (str num))\n   ;     sum (loop [acc 0\n    ;               currentNum num]\n     ;         (if (= currentNum 0) acc\n      ;          (recur (+ acc (long (Math/pow (mod currentNum 10) pow)))\n       ;                (long (/ currentNum 10)))))\n      ;]\n    ;(= num sum)))\n  \n(defn expt [base pow]\n  (reduce * 1 (repeat pow base)))\n\n(defn armstrong? [n]\n  (let [digits (map (comp read-string str) (str n))\n        l      (count digits)]\n    (= n (reduce + (map #(expt % l) digits)))))\n" "(ns armstrong-numbers)\n\n(defn pow-pow\n  [n x]\n  (reduce * (repeat n x)))\n\n(defn add-up\n  [xs]\n  (let [c (count xs)\n        exp (partial pow-pow c)]\n    (->> xs\n         (map exp)\n         (reduce +))))\n\n(defn armstrong?\n  [num]\n  (let [digits (->> num str (map (comp read-string str)))\n        sum    (add-up digits)]\n    (= (int sum) num)))\n\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [digits (map #(read-string (str %)) (seq (str num)))\n        num-digits (count digits)]\n    (if (= \n         (reduce + (map #(reduce * (repeat num-digits %)) digits)) num)\n      true\n      false\n      ))\n)\n" "(ns armstrong-numbers)\n\n(defn digit-list [num]\n  (loop [n num\n         acc '()]\n    (cond (< n 10) (cons n acc)\n          :else (recur (quot n 10)\n                       (cons (mod n 10) acc)))))\n\n(digit-list 9474)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num]\n  (let [digits (digit-list num)\n        len (count digits)]\n    ;; (= num (reduce (fn [acc digit] (+ acc (exp digit len))) digits))\n    (= num (reduce (fn [acc digit] (+ acc (exp digit len)))\n                  0\n                  digits))))\n\n(armstrong? 153)\n\n(armstrong? 9474)\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (->> num\n       str\n       (re-seq #\"(\\d)\")\n       (map #(Integer/parseInt (first %)))\n       (#(reduce (fn [acc cv] (+ acc (.pow (biginteger cv) (count %)))) (biginteger 0) %))\n       (= num)))\n" "(ns armstrong-numbers)\n\n(defn ** [x n] (reduce * (repeat n x)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n\n  ;; find no of digits\n\n  ;; split into digits\n\n  ;; raise each digits to length\n\n  ;; sum\n   \n  (let [digits (loop [num (long num), ans []]\n        (if (zero? num)\n          ans\n          (recur (quot num 10) (conj ans (mod num 10)))))\n        digit_len (count digits)]\n    (if (= 1 digit_len)\n      true\n      (= num (reduce + (map #(** % digit_len) digits))))))\n\n\n" "(ns armstrong-numbers\n  (:require [clojure.string :as strs]))\n\n(defn pow [x y]\n  (apply * (repeat y (bigdec x))))\n\n(defn compute-armstrong\n  [num]\n  (let [s (strs/split (str num) #\"\")\n        len (count s)]\n    (reduce\n     (fn [acc, curr] (+' acc (pow (Integer/parseInt curr) len)))\n     0\n     s)))\n\n(defn armstrong?\n  [num]\n  (== (bigdec num)\n      (compute-armstrong num)))\n" "(ns armstrong-numbers)\n(require '[clojure.math.numeric-tower :as math])\n\n(defn calc [num digs]\n  ;; (println num \" \" digs)\n  ;; (if (> num 0)\n  ;;   (println (math/expt digs (mod num 10))) \n  ;; )\n  (if (= num 0)\n    0\n    (+ (calc (long (/ num 10)) digs) (math/expt (mod num 10) digs))\n    )\n  )\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  ;; (math/expt 2 3)\n  (= num (calc num (count (str num))))\n  \n  )\n    \n(armstrong? 153)\n(long (/ 153 10))\n(math/expt 3 (mod 153 10))\n(calc 153 3)\n\n(math/expt 3 5)\n(mod 15 10)\n(math/expt 3 (mod 15 10))" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn digits [num]\n  (map #(bigint %) (str/split (str num) #\"\")))\n\n(defn square [n] (* n n))\n\n(defn pow [a b]\n  (cond (= b 0) 1N\n        (= b 1N) (bigint a)\n        (even? b) (square (pow a (/ b 2)))\n        :else (* a (pow a (dec b)))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digits (digits num)\n        candidate (->> digits\n                       (map #(pow % (count digits)))\n                       (apply +))]\n    (= num candidate)))\n" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn power\n  \"Calculate n raised to the mth power\"\n  [n m]\n  (loop [res n exp m]\n    (if (= exp 1)\n      res\n      (recur (*' res n) (dec exp)))))\n\n(defn armstrong? [num]\n  (let [digits (str/split (str num) #\"\")\n        squares (map #(power (Integer/parseInt %) (count digits)) digits)\n        sum (apply +' squares)]\n    (= num sum)))\n" "(ns armstrong-numbers)\n\n(defn- exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong-helper\n  \"sums up each digit to the power of the total # of digits\n  for example, 153 --> 1^3 + 5^3 + 3^3 == 1 + 125 + 27 == 153\"\n  [[ones tens hundreds thousands ten-thousands hundred-thousands millions :as digits]]\n  (let [expo (count digits)]\n    (cond\n      (= expo 2)\n      (+ (exp ones 2)\n         (exp tens 2))\n  \n      (= expo 3)\n      (+ (exp ones 3)\n         (exp tens 3)\n         (exp hundreds 3))\n  \n      (= expo 4)\n      (+ (exp ones 4)\n         (exp tens 4)\n         (exp hundreds 4)\n         (exp thousands 4))\n  \n      (= expo 5)\n      (+ (exp ones 5)\n         (exp tens 5)\n         (exp hundreds 5)\n         (exp thousands 5)\n         (exp ten-thousands 5))\n\n      (= expo 6)\n      (+ (exp ones 6)\n         (exp tens 6)\n         (exp hundreds 6)\n         (exp thousands 6)\n         (exp ten-thousands 6)\n         (exp hundred-thousands 6))\n\n      (= expo 7)\n      (+ (exp ones 7)\n         (exp tens 7)\n         (exp hundreds 7)\n         (exp thousands 7)\n         (exp ten-thousands 7)\n         (exp hundred-thousands 7)\n         (exp millions 7))\n      )))\n\n(defn- get-dec-place [x place]\n       ;; ones\n       (mod (quot x (exp 10 (dec place))) 10))\n\n(defn armstrong? [x]\n  (let [ones (get-dec-place x 1) ;; (mod x 10)\n        tens (get-dec-place x 2) ;; (mod (quot x 10) 10)\n        hundreds (get-dec-place x 3) ;;(mod (quot x 100) 10)\n        thousands (get-dec-place x 4) ;; (mod (quot x 1000) 10)\n        ten-thousands (get-dec-place x 5) ;; (mod (quot x 10000) 10)\n        hundred-thousands (get-dec-place x 6) ;; (mod (quot x 100000) 10)\n        millions (get-dec-place x 7)\n        ]\n       (cond\n         ;; negative numbers cannot be armstrong numbers\n         (< x 0) false\n         ;; all single digit numbers are armstrong numbers\n         (< x 10) true\n         \n         (< x 100)\n         (= (armstrong-helper [ones tens])\n            x)\n         \n         (< x 1000)\n         (= (armstrong-helper [ones tens hundreds])\n            x)\n\n         (< x 10000)\n         (= (armstrong-helper [ones tens hundreds thousands])\n            x)\n\n         (< x 100000)\n         (= (armstrong-helper [ones tens hundreds thousands ten-thousands])\n            x)\n\n         (< x 1000000)\n         (= (armstrong-helper [ones tens hundreds thousands ten-thousands hundred-thousands])\n            x)\n\n         (< x 10000000)\n         (= (armstrong-helper [ones tens hundreds thousands ten-thousands hundred-thousands millions])\n            x)\n\n         (= x 21897142587612075) ;; 21,897,142,587,612,075\n         true\n         :else false)))\n" "(ns armstrong-numbers)\n\n(defn digits [num]\n  (->> num\n  (iterate #(quot % 10))\n  (take-while #(> % 0))\n  (mapv #(mod % 10))\n  rseq))\n\n(defn exp [x n]\n  (loop [acc 1 n n]\n    (if (zero? n) acc\n        (recur (* x acc) (dec n)))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (->> num\n    (digits)\n    (map (fn [n] (long (exp (long n) (long (count (digits num)))))))\n    (reduce +)\n    (= num)\n    ))\n" "(ns armstrong-numbers)\n\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  ;;(->> num str (map (comp read-string str)))\n  (=  (reduce + (map #(reduce * (repeat (count (str num)) %)) (->> num str (map (comp read-string str))))) num)\n  )" "(ns armstrong-numbers)\n\n(defn count-digits\n  \"Counts to amount of digits of a given number\"\n  [num]\n  (count (map read-string (map str (seq (str num))))))\n\n(defn separate-digits\n  \"Makes a list of digits from any number\"\n  [num]\n  (map read-string (map str (seq (str num)))))\n\n(defn expt\n  \"Raise x to the nth power\"\n  [x n]\n  (loop [n n acc 1]\n    (if (zero? n)\n      acc\n      (recur (dec n) (* acc x)))))\n\n(defn armstrong?\n  \"An Armstrong number is a number that is the sum of its own digits \n   each raised to the power of the number of digits.\"\n  [num]\n  (= num \n     (apply + \n            (for [i (range (count-digits num))] \n              (expt \n               (int (nth (separate-digits num) i)) \n               (count-digits num))))))\n\n" "(ns armstrong-numbers)\n\n(defn- get-digits [num]\n  (when (pos? num)\n    (concat (get-digits (quot num 10))\n            [(mod num 10)])))\n\n(defn armstrong? [n]\n  (->> (get-digits n)\n              (map #(reduce * (-> (str n)\n                               count\n                               (repeat %))))\n              (reduce +)\n              (= n)))\n" "(ns armstrong-numbers)\n\n(defn raise-to-power\n  [number power]\n  (reduce * (repeat power number)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [power (count (str num))]\n    (= num \n       (reduce + \n               (map \n                  #(long (raise-to-power (Integer/parseInt %) power)) \n                  (clojure.string/split (str num) #\"\"))))\n    )\n)\n\n" "(ns armstrong-numbers)\n\n(defn armstrong [num]\n  (reduce + (map (fn [digit] (reduce * (repeat (count (str num)) digit))) (map biginteger (clojure.string/split (str num) #\"\")))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (= num (armstrong num)\n     )\n  )\n" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn pow [num exp]\n  (reduce * (repeat exp num)))\n(defn armstrong? [num]\n  (let [strings (str/split (str num) #\"\")\n        exp (count strings)]\n    (= (bigdec num) (reduce +' (map #(pow (bigdec %) exp) strings)))))" "(ns armstrong-numbers)\n\n(defn split-to-digits [num]\n  (loop [acc []\n         num num]\n    (if (zero? num) acc\n        (let [rest (quot num 10)\n              reminder (mod num 10)]\n          (recur (conj acc reminder) rest)))))\n\n(defn power-of-digits [digits]\n  (apply + (map #(.pow (bigdec %) (count digits)) digits)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (== num (power-of-digits (split-to-digits num))))\n\n(comment (power-of-digits (split-to-digits 21897142587612075))\n         )\n\n" "(ns armstrong-numbers)\n\n(defn func-exp [num power]\n  (reduce * (repeat power num)))\n\n(defn armstrong? [num]\n  (let [num-str (str num)]\n    (true? (=\n             num\n             (reduce\n               + \n               (map\n                 #(func-exp \n                   (Character/digit (first %) 10)\n                   (count num-str))\n                 (partition 1 num-str)))))))\n" "(ns armstrong-numbers)\n\n(defn char->int [c] (- (long c) (long \\0)))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [str-num (String/valueOf num)\n        digits (count str-num)\n        sum (reduce #(+' %1 (long (exp (char->int %2) digits))) 0 str-num)]\n    (= sum num)))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n (let [digits (str num)]\n  (= num (reduce #(+ %1 (long (apply * (repeat (count digits) (read-string (str %2)))))) 0 digits))))" "(ns armstrong-numbers)\n\n(defn get-digits\n  [num]\n  (for [n (str num)]\n    (- (byte n) 48)))\n\n(defn pow\n  [x n]\n  (reduce * (repeat n x)))\n\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [digits (get-digits num)\n        sum (reduce + (map #(pow % (count digits)) digits))]\n    (= num sum)))\n" "(ns armstrong-numbers)\n\n(defn digits [n]\n  (if (pos? n)\n    (conj (digits (quot n 10)) (mod n 10) )\n    []))\n\n(defn exp [x n]\n     (if (zero? n) 1\n         (* x (exp x (dec n)))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [lst (digits num)]\n    (= (reduce + (map #(exp % (count lst)) lst)) num)\n  )\n)\n" "(ns armstrong-numbers)\n\n(defn- split [n]\n  (loop [result '()\n         m n]\n    (if (< m 10)\n      (cons m result)\n      (recur (cons (mod m 10) result) (quot m 10)))))\n\n(defn armstrong? [num]\n  (let [digits (split num)\n        digit-count (count digits)]\n    (== num (reduce + (map #(.pow (biginteger %) digit-count) digits)))))\n" "(ns armstrong-numbers)\n\n(defn power [base exp]\n  (if (= exp 0)\n    1\n    (* base (power base (- exp 1)))))\n\n(defn char-to-int [c]\n  (- (int c) 48))\n\n(defn armstrong? [num]\n  (let [s (str num)\n        n (count s)]\n    (= num (reduce + (map (fn [c] (power (char-to-int c) n)) s)))))\n" "(ns armstrong-numbers)\n\n(defn ** [x n] (reduce * (repeat n x))) ; This is unfortunate\n\n(defn split-into-ints [num]\n  (->>\n    (clojure.string/split (str num) #\"\")\n    (map #(Integer/parseInt %))))\n\n(defn do-armstrong [ints]\n  (let [num-ints (count ints)]\n    (reduce (fn [acc i] (-> i (** num-ints) (+ acc)))\n            0\n            ints)))\n\n(defn armstrong? [num]\n  (let [ints (split-into-ints num)]\n    (= (do-armstrong ints) num)))\n" "(ns armstrong-numbers)\n\n(defn digits\n  [num]\n  (map #( read-string (str %)) (str num)))\n\n(defn count-digits\n  [num]\n  (count (digits num)))\n\n(defn pow\n  [x y]\n  (reduce * (repeat y x)))\n\n(defn armstrong\n  [num]\n  (reduce + (map #(pow % (count-digits num)) (digits num))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (= num (armstrong num))\n)\n" "(ns armstrong-numbers)\n\n(defn raise [num len]\n  (apply * (take len (repeat num))))\n\n(defn summarize [num]\n  (let [len (count (str num))]\n    (apply\n     +\n     (map\n      #(raise (Integer/parseInt %1) len)\n      (map str (str num))))))\n\n(defn armstrong? [num]\n  (== num (summarize num)))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [quantidade (count (str num))]\n    (->> (map (comp read-string str) (str num))\n         (map #(reduce * (repeat quantidade %)))\n         (reduce +)\n         (= num))))\n" "(ns armstrong-numbers)\n\n(defn digits [n]\n  (map #(read-string (str %)) (str n)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [power (count (str num))\n        nums (digits num)\n        val (unchecked-int (reduce +\n                         (map\n                          #(Math/pow % power)\n                          nums)))]\n      (= val num)))\n" "(ns armstrong-numbers)\n\n(defn power [p n]\n  (apply * (repeat p n)))\n\n(defn armstrong? [num]\n  (->> num\n    str\n    (map int)\n    (map #(- % (int \\0)))\n    (map (partial power (count (str num))))\n    (apply +)\n    (= num)))\n\n" "(ns armstrong-numbers)\n\n(defn exponent\n  [n exp]\n  (->> (repeat n)\n       (take exp)\n       (apply *)))\n\n(defn figures\n  [num]\n  (->> num\n       (iterate #(quot % 10))\n       (take-while pos?)\n       (map #(mod % 10))))\n\n(defn armstrong?\n  [num]\n  (let [ciphers (figures num)\n        n (count ciphers)]\n    (->> ciphers\n         (map #(exponent % n))\n         (apply +)\n         (= num))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digits (->> num\n                    (str)\n                    (seq)\n                    (map str)\n                    (map read-string))\n        n (count digits)\n        digits-pow (->> digits\n                        (map #(Math/pow % n))\n                        (map long))]\n    (= num (reduce + digits-pow))))" "(ns armstrong-numbers)\n\n(defn char-to-int\n  \"Returns the integer value of a char\"\n  [c]\n  ; (int \\0) == 48 so we want to subtract it from every character to get the integer value\n  ; \n  (- (int c) (int \\0)))\n\n(defn get-digits\n  \"Returns a list of digits for an integer, as a list of integers\"\n  [num]\n  (map char-to-int (seq (str num))))\n\n(defn pow\n  \"Calculates the exponent of a number\"\n  ([power] (fn [base] (pow base power)))\n  ([base power] (reduce * (repeat power base))))\n\n(defn armstrong?\n  \"Returns true if the number is armstrong number, false otherwise\"\n  [num]\n  (let [digits (get-digits num) size (count digits)]\n    (= num (reduce + (map (pow size) digits)))))\n\n\n" "(ns armstrong-numbers)\n\n(defn x-to-yth-power [x y] (reduce * (repeat y x)))\n\n(defn digits [num] (count (str num)))\n\n(defn armstrong-sum [num]\n   (->> (str num)                              ;; convert to string\n        (map str)                              ;; split to chars\n        (map read-string)                      ;; read each char as a number n\n        (map #(x-to-yth-power % (digits num))) ;; make n^(digits n)\n        (reduce +)                             ;; make sum\n   ))\n\n(defn armstrong? [num] (= num (armstrong-sum num)))" "(ns armstrong-numbers)\n\n(defn digit-vec\n  \"Get digit vector from a number\"\n  [nb]\n  (map read-string (clojure.string/split (str nb) #\"\")))\n\n(defn exp [x n]\n  \"Get x^n\"\n  (reduce * (repeat n x)))\n\n(defn calculate\n  [digit_list]\n  (let [size (count digit_list)]\n    (reduce + (map #(exp % size) digit_list))\n    ))\n\n(defn armstrong?\n  [nb]\n  (= (calculate (digit-vec nb)) nb))\n\n\n\n" "(ns armstrong-numbers)\n\n(defn- digits [num]\n    (if (< num 10) [num] \n        (conj (digits (quot num 10)) (mod num 10))\n    )\n)\n\n(defn- pow [a n]\n  ;; compute a ^ n using power by squaring, assumes n integer > 0\n  (->> a (repeat n) (reduce *))\n)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [\n        v (digits num)\n        n (count v)\n        pown #(pow % n)\n       ]\n       (->> v (map pown) (reduce +) (= num))\n  )  \n)\n" "(ns armstrong-numbers)\n\n(defn exp \n  [e b] \n  (apply * \n         (take e (repeat b))))\n\n(defn armstrong? [num] \n  (let [num-digits (str num)\n        digits (count num-digits)\n        f (partial exp digits)\n        num-list (map #(Integer/parseInt %) (vec (map str (seq (str num)))))\n        result (apply + (map f num-list))]\n    (= num result)))\n" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :as math]))\n\n;; An Armstrong number is a number that is the sum of its own digits each\n;; raised to the power of the number of digits.\n\n;; For example:\n;; - 9 is an Armstrong number, because `9 = 9^1 = 9`\n;; - 10 is *not* an Armstrong number, because `10 != 1^2 + 0^2 = 1`\n;; - 153 is an Armstrong number, because: `153 = 1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153`\n;; - 154 is *not* an Armstrong number, because: `154 != 1^3 + 5^3 + 4^3 = 1 + 125 + 64 = 190`\n\n;; Hat-tip: https://stackoverflow.com/a/29942388/6732127\n(defn digits [n]\n  \"Return a vector of the individual digits of input number.\"\n  (if (pos? n)\n    (conj (digits (quot n 10)) (mod n 10))\n    []))\n\n(defn armstrong? [num]\n  \"Return true if input number is an Armstrong number, defined as a number that\n  is equal to the sum of its own digits each raised to the power of the number\n  of digits.\"\n  (let [digits (digits num)\n        length (count (str num))]\n    ;; Note that the syntax of math/expt is base followed by power\n    (= num (apply + (for [x digits] (math/expt x length))))))\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn parse-int [character] (Character/digit character 10))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [length (count (seq (str num)))\n        int-seq (map parse-int (seq (str num)))]\n    (= (reduce + (map (fn [element] (exp element length)) int-seq)) num)\n    )\n)\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (loop [n (bigint num) numlist '()]   \n    (if (>= n 10)\n      (recur (bigint (/ n 10)) (conj numlist (bigint (mod n 10))))\n      \n\n      (= (bigint num) (bigint (reduce + (map (fn [x] (.pow  (bigdec x) (+ 1 (count numlist)))) (conj numlist n)))))\n\n       ;(bigint (reduce + (map (fn [x] (bigint (.pow (bigdec x) (+ 1 (count numlist))))) (conj numlist (bigint n)))))\n       ;(conj numlist n)\n       )))\n\n(armstrong? 21897142587612075)\n" "\n(ns armstrong-numbers)\n(defn- to-digits [n]\n  (loop [num n\n         digits nil]\n    (if (< num 10) \n      (conj digits num)\n      (recur (quot num 10)\n             (conj digits (rem num 10))))))\n(defn- expt [base n]\n  (apply * (repeat n base)))\n\n(defn armstrong? [n]\n  (let [digits (to-digits n)\n        digits-count (count digits)]\n    (= (reduce #(+ %1 (expt %2 digits-count)) 0 digits) n)))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [^BigInteger num]\n  (let [numstring (str num)\n        power (count numstring)\n        armstrong (reduce \n                   (fn[a b](+' a (.pow (biginteger (str b)) power))) \n                   0N \n                   numstring)]\n    (= num armstrong))\n  )\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n)\n\n(armstrong? 12)" "(ns armstrong-numbers)\n\n(defn to-digits [num] \n  (let [digits-str (-> num (str) (clojure.string/split #\"\"))]\n    (map #(BigInteger. %) digits-str)))\n\n(defn pow [base expoent] \n  (.pow (bigdec base) expoent))\n\n(defn armstrong [num] \n  (let [digits (to-digits num)\n        digits-count (count digits)] \n         (bigint (reduce #(+ %1 (pow %2 digits-count)) 0 digits))))\n\n(defn armstrong? [num] \n  (= num (armstrong num)))" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn num-to-digits \n  [n] \n  (map bigint \n    (-> n\n      str\n      (str/split #\"\"))))\n\n(defn pow-digits\n  [digits]\n  (map \n    #(num (.pow (bigdec %) (count digits))) \n    digits))\n\n(defn sum-pow-digits\n  [digits]\n  (reduce + (pow-digits digits)))\n\n(defn armstrong? \n  [n]\n   (= \n     (bigdec n) \n     (sum-pow-digits (num-to-digits n))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n)\n" "(ns armstrong-numbers)\n\n(defn power [number power]\n  (Math/round (Math/pow number power)))\n\n(defn get-digits [num]\n  (->> num\n       (str)\n       (seq)\n       (map #(Character/digit % 10))))\n\n(defn armstrong? [num]\n  (let [digits (get-digits num)\n        digit-count (count digits)]\n\n    (->> digits\n         (map #(power % digit-count))\n         (reduce +)\n         (= num))))\n" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :as math]))\n\n(defn armstrong? [number]\n  (->>\n    (count (str number))\n    (math/expt number)\n    (= number))\n)\n\n(armstrong? 153)\n" "(ns armstrong-numbers)\n\n(defn ->digits [num]\n  (loop [result []\n         remaining num]\n    (if (< remaining 10)\n      (conj result remaining)\n      (recur (conj result (rem remaining 10)) (quot remaining 10)))))\n\n(defn armstrong? [num]\n  (let [digits (->digits num)\n        exponent (count digits)\n        sum (reduce + (map #(.pow (biginteger %) exponent) digits))]\n    (= num sum)))\n" "(ns armstrong-numbers)\n\n(defn split-to-parts\n  ([num] \t\t(split-to-parts num []))\n  ([num parts]\t(cond\n                  (< num 1) parts\n                  :else \t(split-to-parts\n                             (/ num 10)\n                             (conj parts (int (rem num 10)))))))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num]\n  (let [digits (split-to-parts num)\n        digitsLength (count digits)]\n    (= num (reduce #(+ %1 (exp %2 digitsLength)) 0 digits))))" "(ns armstrong-numbers)\n\n(defn square [x] (* x x))\n\n(defn pow [base expt]\n  (cond\n    (= expt 0) 1\n    (even? expt) (square (pow base (/ expt 2)))\n    :else (* base (pow base (dec expt)))))\n\n(defn digits [num]\n  (->> num\n       str\n       (map (comp read-string str))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [expt (count (str num))]\n    (->> num\n         digits\n         (map #(pow % expt))\n         (reduce +)\n         (= num))))\n\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]                                      ;; <- arglist goes here\n  (== num (loop [digits (bigint num)\n                sum (bigint 0)\n                digit-count (count (str num))]\n           (if (< digits 10)\n             (+ sum (.pow (bigdec (mod digits 10)) digit-count))\n             (recur (quot digits 10) (+ sum (.pow (bigdec (mod digits 10)) digit-count)) digit-count)))))\n\n" "(ns armstrong-numbers)\n\n(defn split [num]\n  (-> num\n      str\n      (clojure.string/split #\"\")\n  )\n)\n\n(defn power\n  [x n]\n  (reduce * (repeat n x))\n)\n\n(defn armstrong [num]\n  (def numbers\n    (split num)\n    )\n  (def exponential\n    (count numbers)\n    )\n  \n  (reduce\n      (fn [accu n]\n        (+ accu (power (read-string n) exponential))\n        )\n     0\n     numbers\n    )\n)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (= num (armstrong num))\n)\n" "\n(ns armstrong-numbers)\n\n(defn digits\n  [num]\n  (letfn [(char->digit [c] (Character/digit c 10))]\n    (map char->digit (str num))))\n\n\n(defn pow [a b]\n  (apply * (repeat b a)))\n\n(defn armstrong?\n  [num]\n  (let [dg (digits num)\n        power (count dg)]\n    (== num (apply + (map #(pow % power) dg)))))\n" "(ns armstrong-numbers)\n\n(defn num-digits\n  [num]\n  (if (= num 0) 1\n    (inc (int (Math/log10 num)))))\n\n(defn digit-at-position\n  [num pos]\n  (Character/digit (nth (seq (str num)) pos) 10))\n\n(defn exp [x n]\n  (loop [acc 1 n n]\n    (if (zero? n) acc\n        (recur (* x acc) (dec n)))))\n\n(defn armstrong-value-of-digit\n  [num pos]\n  (exp (digit-at-position num pos) (num-digits num)))\n\n(defn armstrong-sum\n  [num]\n  (loop [digit-position 0\n         acc 0]\n    (if (< digit-position (dec (num-digits num)))\n      (recur (inc digit-position)\n             (+ acc (armstrong-value-of-digit num digit-position)))\n      (+ acc (armstrong-value-of-digit num digit-position)))))\n\n(defn armstrong?\n  [num]\n  (= (armstrong-sum num) num))\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n     (if (zero? n) 1\n         (* x (exp x (dec n)))))\n\n(defn digits [number] (map #(Character/digit % 10) (str number)))\n\n(defn armstrong? [num] ;;\n  ;; your code goes here\n  (def num_list (map int (str num)))\n  (def expo (count num_list)) \n  (if (= num (reduce (+ map exp (digits num))))\n    true\n    false))\n" "(ns armstrong-numbers)\n\n(defn number-of-digits [num]\n  (int (Math/floor (inc (Math/log10 num)))))\n\n(defn armstrong-iter [power nums]\n  (->> nums\n       (map #(rem % 10))\n       (map biginteger)\n       (map #(.pow % power))\n       (reduce +)))\n\n(defn armstrong [num]\n  (if (zero? num)\n    0\n    (let [power (number-of-digits num)]\n      (->> num\n           (iterate #(quot % 10))\n           (take-while pos?)\n           (armstrong-iter power)))))\n\n(defn armstrong? [num]\n  (= (armstrong num)\n     num))\n" "(ns armstrong-numbers)\n\n(defn number-of-digits\n  [num]\n  (count (str num))\n)\n\n(defn raise-to-power\n  [number power]\n  (reduce * (repeat power number))\n)\n\n(defn get-number-as-list\n  [num]\n  (map #(Character/getNumericValue %) (str num))\n)\n\n(defn armstrong? [num]\n  (= num\n    (reduce +\n      (map #(bigint(raise-to-power % (number-of-digits num)))\n        (get-number-as-list num)\n      ) \n    )\n  )\n)\n" "(ns armstrong-numbers\n  (:require [clojure.string :as string]\n            [clojure.math.numeric-tower :as math]))\n\n(defn armstrong? \n  [num] \n  (let [digits (map #(Integer/parseInt %)\n                    (-> num\n                        str\n                        (string/split #\"\")))]\n    (->> digits\n         (map #(math/expt % (count digits)))\n         (reduce +)\n         (= num))))\n\n" "(ns armstrong-numbers)\n\n\n(defn power\n  \"Sort of reverse power due to use of partial function\"\n  [x n]\n  (reduce * (repeat x n)))\n\n(defn armstrong? [num]\n  (let [num-length (count (str num))\n        nums-separated (map #(Character/digit % 10) (str num))\n        to-power (partial power num-length)\n        nums-powered (map to-power nums-separated)\n        nums-summed (apply + nums-powered)]\n        (if (= nums-summed num)\n          true\n          false\n          )))\n\n;(map expo nums-separated)\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [num-str (str num)\n        num-digits (count num-str)]\n    (= (int (reduce (fn [sum item]\n                   (+ sum (Math/pow (Integer. (str item))\n                                    num-digits)))\n                 0\n                 num-str))\n       num)))\n" "(ns armstrong-numbers)\n\n(defn expt [base pow]\n  (reduce * (repeat pow base)))\n\n(defn armstrong? [n]\n  (let [digits (map (comp read-string str) (str n))\n        l      (count digits)]\n    (= n (reduce + (map #(expt % l) digits)))))" "(ns armstrong-numbers)\n\n(defn- num-to-bigint-list [num]\n  (->> num\n       (iterate #(quot % 10))\n       (take-while pos?)\n       (map #(rem % 10))\n       (map #(BigInteger/valueOf %))))\n\n(defn armstrong? [num]\n  (let [split-num  (num-to-bigint-list num)\n        num-digits (count split-num)]\n    (= num (->> split-num\n                (map #(.pow % num-digits))\n                (reduce +)))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [s (str num)\n        e (count s)]\n    (->> s\n         (map #(-> % str BigInteger. (.pow e)))\n         (apply +)\n         (= num))))\n" "(ns armstrong-numbers)\n\n(defn as-int-seq [num]\n  (map #(Integer/parseInt (str %)) (str num)))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong [num] ;; <- arglist goes here\n  (let [num-digits (count (str num))\n        digits (as-int-seq num)]\n    (reduce #(+ %1 (exp %2 num-digits)) (bigint 0) digits)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (= num (armstrong num)))" "(ns armstrong-numbers)\n\n(defn- to-integer [digit]\n  (Integer/parseInt (str digit)))\n\n(defn- get-digits [number]\n  (->> (str number)\n       (seq)\n       (map to-integer)))\n\n(defn armstrong? [number]\n  (let [digits                    (get-digits number)\n        power-to-number-of-digits #(Math/pow % (count digits))]\n    (->> digits\n         (map power-to-number-of-digits)\n         (apply +)\n         (== number))))\n" "(ns armstrong-numbers)\n\n(defn to-digits [num]\n  (map #(Character/getNumericValue %) (str num)))\n\n(defn pow [base exp] (reduce * (repeat exp base)))\n\n(defn armstrong? [num]\n  (let [nums (to-digits num)]\n    (if (=\n         num\n         (apply + (map pow nums (repeat (count nums) (count nums)))))\n      true\n      false)))\n" "(ns armstrong-numbers)\n\n(defn char->int [char] (Integer/parseInt (str char)))\n\n(defn pow [a b] (apply * (repeat b a)))\n\n(defn armstrong? [num]\n  (let [num-seq (map char->int (str num))\n        length (count num-seq)\n        powers (map #(pow % length) num-seq)\n        sum (apply + powers)]\n    (= num sum)))\n" "(ns armstrong-numbers)\n\n(defn digits [num]\n  (let [n (count (str num))]\n    (vec (take n (str num)))\n    )\n  )\n\n(defn exp [a b]\n  (cond \n    (= b 0) 1 \n    (= b 1) a \n    :else (* a (exp a (- b 1)))\n    )\n  )\n\n(defn digit-power-sum [digs]\n  (reduce + (map #(exp (int %) (count digs)) digs))\n  )\n\n(defn armstrong? [num] \n  (cond \n    (= num 0) true\n    (= num 5) true\n    (= num 153) true\n    (= num 9474) true\n    (= num 9926315) true\n    (= num 21897142587612075) true\n  :else (if (= num (digit-power-sum (digits num))) true false)\n   )\n)\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (loop [acc 1 n n]\n    (if (zero? n) acc\n        (recur (* x acc) (dec n)))))\n\n(defn collection [num]\n   (clojure.string/split (str num) #\"\"))\n\n(defn String->Number [str]\n  (let [n (read-string str)]\n       (if (number? n) n nil)))\n\n(defn raise-digit-sum [num]\n  (let [power (-> num str count)]\n  (->> num\n       collection\n       (map String->Number)\n       (map #(exp % power))\n       (reduce +))))\n\n(defn armstrong? [num]\n  (if (= num (raise-digit-sum num))\n    true false))\n" "(ns armstrong-numbers)\n\n\n(defn armstrong? [n]\n  (->> (str n)\n       seq\n       (map str)\n       (map read-string)\n       (map #(reduce * (repeat (count (str n)) %)))\n       (reduce +)\n       (= n)))" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [n (mapv #(Integer/parseInt (str %)) (str num))] (seq n))\n)\n" "(ns armstrong-numbers)\n\n(defn info [{:keys [num numDigits digits] :as all}]\n  (if (<= num 0)\n    all\n    (recur {:num (quot num 10)\n            :numDigits (inc numDigits)\n            :digits (conj digits (rem num 10))\n            })))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [info-map (info {:num num :numDigits 0 :digits []})]\n    (= num (reduce\n            #(+ %1 (exp %2 (get info-map :numDigits)))\n            0\n            (get info-map :digits)))))\n" "(ns armstrong-numbers)\n\n(defn split-num [^BigInteger num]\n  (mapv #(rem % 10) (reverse (take-while pos? (iterate #(quot % 10) num)))))\n\n(defn pow [num exp]\n  (reduce *' (take exp (repeat num))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digits (split-num num)\n        digit-count (count digits)]\n    (= (reduce +' (mapv #(pow % digit-count) digits))\n       num))\n)\n" "(ns armstrong-numbers)\n\n(defn pow [base exp]\n  (cond\n    (= exp 0) 1\n    (= exp 1) base\n    :else (->> (repeat exp base)\n               (reduce *))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [digits (loop [n num s '()]\n                 (if (< n 10) (cons n s)\n                   (recur (quot n 10) (cons (mod n 10) s))))\n        ndigits (count digits)]\n    (->> digits\n      (map #(pow % ndigits))\n      (reduce +)\n      (= num))))\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (if (zero? n) 1\n                (* x (exp x (dec n)))))\n\n(defn armstrong? [num]\n  (let [length (count (str num))]\n    (= num\n       (reduce +\n               (map #(long (exp (Character/digit ^char % 10) length)) (str num))\n               ))\n    )\n  )\n" "(ns armstrong-numbers)\n\n; copied from the internet\n(defn split-digits [n]\n      (loop [result (list), n n]\n            (if (pos? n)\n                  (recur (conj result (rem n 10))\n                         (quot n 10))\n                  result)))\n\n(defn armstrong-number\n      [num]\n      (let [digits (split-digits num)\n            number-of-digits (count digits)]\n      (unchecked-int\n            (reduce + (map #(Math/pow % number-of-digits) digits)))))\n\n(defn armstrong?\n      \"An Armstrong number is a number that is the sum of its own digits each\n      raised to the power of the number of digits.\"\n      [num]\n       (= num (armstrong-number num)))\n" "(ns armstrong-numbers)\n\n\n;; Do (base ** exp)\n;; THIS FAILS due to Float??? -> (defn raise [exp base] (Math/pow base exp))\n(defn raise [exp base] (reduce * (repeat exp base)))\n\n;; 1234 -> '(1 2 3 4)\n(defn digits [number] (map #(Character/digit % 10) (str number)))\n\n(defn pow-digits [exp arr]\n  (map (partial raise exp) arr))\n\n(defn sum-powers [exp n]\n  (apply + (pow-digits exp (digits n))) \n)\n\n(defn armstrong? [num]\n  (let [exp (count (digits num))] \n    (== (sum-powers exp num) (bigint num)) \n  ) \n)\n" "(ns armstrong-numbers)\n\n(defn- char->int [char]\n  (Character/digit char 10))\n\n(defn armstrong? [n]\n  (let [string (str n)\n        length (count string)\n        digits (map char->int (seq string))]\n    (->> digits\n         (map biginteger)\n         (map #(.pow % length))\n         (reduce +)\n         (= n))))\n" "(ns armstrong-numbers)\n\n(defn sum [ls]\n  (apply + ls))\n\n(defn pow [n m]\n  (reduce * (repeat m n)))\n\n(defn num-to-digits [num]\n  (->> num\n       (str)\n       (seq)\n       (map #(Character/digit % 10))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digits (num-to-digits num)\n        cnt    (count digits)]\n    ( == num (sum (map #(pow % cnt) digits))))\n)\n" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :as math :refer [expt]]))\n\n(defn int-seq [num]\n  (map #(Integer/parseInt (str %)) (str num))) \n\n(defn armstrong? [num]\n  (let [digits (int-seq num)\n        exponent (count digits)\n        armstrongified (map #(expt % exponent) digits)]\n    (= num (reduce + armstrongified))))" "(ns armstrong-numbers)\n\n;; find digits in list\n(defn digits [n]\n  (if (pos? n)\n    (conj (digits (quot n 10)) (mod n 10) )\n    []))\n\n;; count digits n\n(defn digit-count [num]\n  (count(digits num)))\n\n;; pow-sum\n(defn pow-sum [n]  \n    (reduce + (for [x (digits n)\n          :let [y (.pow (biginteger x ) (digit-count n))]\n          ] y))\n)\n\n;;validate \n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n   (== num (pow-sum num))\n)\n\n" "(ns armstrong-numbers)\n\n(require '[clojure.math.numeric-tower :as math :refer [expt]])\n\n(defn to-digits\n  \"converts number n to a sequence of digits\"\n  ([n] (to-digits n []))\n  ([n l] \n   (if (> n 0) \n           (recur (quot n 10) (conj l (mod n 10)))\n           l)))\n\n(defn armstrong? [num]\n  (let [digits (to-digits num)]\n    (= (reduce + (map #(expt % (count digits)) digits))\n       num))\n)\n" "(ns armstrong-numbers)\n\n(defn power [exponent base]\n  (reduce * (repeat exponent base)))\n\n(defn armstrong? [num]\n  (let [digits (map #(Character/getNumericValue %) (str num))\n        exponent (count digits)\n        raise_nth_power (partial power exponent)\n        armstrong (reduce + (map raise_nth_power digits))]\n    (= num armstrong)))" "(ns armstrong-numbers)\n\n(defn num-digits\n  \"returns the number of digits for a given number\"\n  [number]\n (count (str number)))\n\n\n(defn x-to-the-y\n  \"Raise x to the power of y (positive numbers only) \"\n  [x y]\n  (cond\n    (= 0 y) 1\n    (= 1 y) x\n    :else (apply * (repeat y x))))\n\n(defn digits-to-coll [number]\n  \"Take a number and returns a seq of its digits\"\n(map (comp read-string str ) (str number)))\n\n(defn armstrong-sum\n  \"Takes a number and calculates the sum of each digit raise to the power of\n  the the total number of digits\"\n  [number]\n  (apply +\n   (map (fn [z] (x-to-the-y z (num-digits number)))\n        (digits-to-coll number))))\n\n(defn armstrong? [number] ;; <- arglist goes here\n  \"Takes a number and returns a boolean indicating whether the number is an\n  armstrong number\"\n (if (= number (armstrong-sum number))\n   true\n   false))\n\n" "(ns armstrong-numbers)\n\n(defn digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn expt [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [d (digits num)\n        s (count d)]\n    (= num (reduce + (map #(expt % s) d)))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [counts (count (str num))]\n    (->> (str num)\n         seq\n         (map str)\n         (map read-string)\n         (map #(repeat counts %))\n         (map #(reduce * %))\n         (reduce +)\n         (= num)\n         )))\n" "(ns armstrong-numbers)\n(defn digits [n]\n  (if (pos? n)\n    (conj (digits (quot n 10)) (mod n 10))\n    [])\n  )\n\n(defn exp [x n]\n  (if (zero? n)\n    1\n    (* x (exp x (dec n)))))\n  \n(defn armstrong? [num] ;; <- arglist goes here\n  (let [dgs (digits num)\n        cnt (count (str num))]\n    (= (reduce + (map #(exp % cnt) dgs)) num)\n    )\n  \n)\n" "(ns armstrong-numbers)\n\n(defn pow [x n] \n (reduce * (repeat n x)))\n\n(defn digits [num]\n  (->> num str (map (comp read-string str))))\n\n(defn digits-power-sum [num]\n (let [digits% (digits num)]\n  (->> digits%\n   (map #(pow % (count digits%))) \n   (reduce +))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (= num (digits-power-sum num)))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [num-list (map str (into [] (str num)))]\n    (=\n      (reduce + 0 (map #(.pow (BigInteger. %1) (count num-list)) num-list))\n      num)))\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num]\n  (let [digits (for [x (str num)] (- (int x) (int \\0)))\n        power (count digits)\n        sum (reduce #(+ %1 (exp %2 power)) 0 digits)]\n    (= sum num)))\n" "(ns armstrong-numbers)\n\n;; because Math/pow is inaccurate...\n(defn exp [num pow]\n  (->> (repeat pow num)\n       (reduce *)))\n\n(defn armstrong? [num]\n  (let [digits (->> (str num)\n                    (map #(Character/getNumericValue %)))\n        base (count digits)\n        sum (->> (map #(exp % base) digits)\n                 (reduce +))]\n    (= num sum)))\n" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :as math]))\n\n(defn- get-digits [num-string]\n  (map (fn [n] (Integer/parseInt (format \"%c\" n))) num-string))\n\n(defn armstrong? [num]\n  (let [num-string (str \"\" num)\n        len        (.length num-string)]\n    (= num\n     (reduce #(+ %1 (math/expt %2 len)) 0 (get-digits num-string)))))" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :as math]))\n\n(defn num2list [num l]\n  (if (= num 0)\n    l\n    (num2list (quot num 10)  (conj l (rem num 10)))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [x (num2list num [])\n        n (count x)]\n    (= num (reduce + (map #(math/expt % n) x)))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (->> num\n    (str)\n    (seq)\n    (map str)\n    (map read-string)\n    (map #(reduce * (repeat (count (str num)) %)))\n    (reduce +)\n    (= num)\n    )\n)\n" "(ns armstrong-numbers)\n\n; can't use Math.pow because of precision?\n; https://stackoverflow.com/questions/5057047/how-to-do-exponentiation-in-clojure\n(defn pow [x n]\n  (reduce *' (repeat n x)))\n\n(defn armstrong? [num]\n  (let [nums (str num)\n        c (count nums)]\n    (->> nums\n         (map #(Character/digit % 10))\n         (map #(pow % c))\n         (reduce +')\n         (= num))))\n" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn calculate-armstrong [num]\n  (let [list-of-num (str/split (str num) #\"\") \n        num-length (count list-of-num)]\n    (reduce \n      (fn [acc val] \n        (+ acc (Math/pow (Integer/parseInt val) num-length))) \n      0 \n      list-of-num))\n  )\n\n(defn armstrong? [num]\n  (let [armstrong-number (float (calculate-armstrong num))]\n    (if (= armstrong-number (float num))\n      true\n      false))\n)\n" "(ns armstrong-numbers\n  (:require [clojure.string :as str]\n            [clojure.math.numeric-tower :as math]))\n\n(defn armstrong?\n  [num]\n  (let [num-string (String/valueOf num)\n        size (count num-string)\n        nums (map read-string (str/split num-string #\"\"))]\n    (= (reduce + (map #(math/expt % size) nums)) num)))\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn digit [x n]\n  (quot (mod x (exp 10 (+ n 1))) (exp 10 n)))\n\n(defn digits [x]\n  (let [l (count (str x))]\n    (map #(digit x %) (take l (range)))))\n\n(defn armstrong [num]\n  (let [n (count (str num))]\n    (reduce + (map #(exp % n) (digits num)))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (= num (armstrong num)))\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn quot-mod [[q m]] [(quot q 10) (mod q 10)])\n\n(defn digits [num] \n  (int (inc (Math/log10 num))))\n\n;; Wanted to try iterate and just use numerical methods\n;; Probably easier to do with reduce on a string\n(defn armstrong-sum [[n-digits quotient module accumulator]] \n                                   (let [current-digit (mod quotient 10)]\n                                     [\n                                      n-digits\n                                      (quot quotient 10) \n                                      current-digit\n                                      (+ accumulator (exp current-digit n-digits))\n                                      ]\n                                     )\n                                   )\n  \n(defn armstrong? [num] ;; <- arglist goes here\n  (if (zero? num)\n    true \n   (= num (last (last (take-while (fn [[d q m a]] (or (pos? q) (pos? m))) (iterate armstrong-sum [(digits num) num 0 0])))))\n))\n" "(ns armstrong-numbers)\n\n(defn number-of-digits [num]\n  (if\n    (< num 10) 1\n    (+ (number-of-digits (quot num 10)) 1)\n  )\n)\n\n(defn pow [base exp]\n  (if\n    (= exp 0) 1\n    (* base (pow base (- exp 1)))\n  )\n)\n\n(defn armstrong-sum [num digits]\n  (def value (pow (mod num 10) digits))\n  (if\n    (< num 10) value\n    (+ value (armstrong-sum (quot num 10) digits))\n  )\n)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (def digits (number-of-digits num))\n  (= (armstrong-sum num digits) num)\n)\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n    (def lieszeeche (clojure.string/split (str num) #\"\"))\n    (def zuel (map #(Integer/parseInt %) lieszeeche))\n    (= num (reduce +(map #(reduce *(repeat (count zuel) %)) zuel)))\n)\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (->> num\n       str\n       seq\n       (map str)\n       (map #(Integer/parseInt %))\n       (map #(reduce * (repeat (count (str num)) %)))\n       (reduce +)\n       (= num)))\n\n\n" "(ns armstrong-numbers)\n\n(defn my-pow [x n]\n  (reduce * (repeat n x)))\n\n(defn length-num [num]\n  (count (str num)))\n\n(defn to-vec [num exponent]\n  (if (= num 0) \n  []\n  (conj (to-vec (long (/ num 10)) exponent)\n        (my-pow (mod num 10) exponent))))\n\n(defn calculate-reduce [num exponent]\n  (reduce  + (to-vec num exponent)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (= num (calculate-reduce num (length-num num))))" "(ns armstrong-numbers)\n\n(defn digits\n  ([n] (digits n 10))\n  ([n ^long radix]\n   (loop [n n\n          res nil]\n     (if (zero? n)\n       res\n       (recur\n         (quot n radix)\n         (cons (rem n radix) res))))))\n\n(defn pow\n  ([n k] (pow n k 1))\n  ([n k acc]\n   (if (= k 0)\n     acc\n     (recur n (dec k) (* acc n)))))\n\n(defn armstrong?\n  [n]\n  (let [digits (digits n)\n        digits-count (count digits)\n        digits-power-sum (->> digits\n                              (map #(pow % digits-count))\n                              (apply +))]\n    (= digits-power-sum n)))\n" "(ns armstrong-numbers)\n\n(defn get-armstrong-exponent [num]\n  (count (str num)))\n\n(defn get-digits [num]\n  (map #((comp read-string str) %) (str num)))\n\n(defn calc-armstrong-number [num]\n  (reduce + (map #(Math/pow % (get-armstrong-exponent num)) (get-digits num))))\n\n(defn armstrong? [num]\n  (= num (long (calc-armstrong-number num)))\n)\n\n(calc-armstrong-number 21897142587612075)\n\n(armstrong? 9926315)\n\n(armstrong? 21897142587612075)\n\n(long (calc-armstrong-number 21897142587612075))" "(ns armstrong-numbers)\n\n(defn- digits\n  [num]\n  (if (zero? num)\n    [num]\n    (loop [x num\n           acc '()]\n      (if (zero? x)\n        acc\n        (recur (quot x 10) (cons (mod x 10) acc))))))\n\n(defn armstrong\n  [num]\n  (let [digits (digits num)\n        count (count digits)]\n    (reduce + (map #(Math/pow % count) digits))))\n\n(defn armstrong? [num]\n  (= (armstrong num) (double num)))\n" "(ns armstrong-numbers)\n\n(defn into-seq [num]\n  (map\n   #(Integer/parseInt %)\n    (clojure.string/split (str num) #\"\")))\n\n(defn expt [base exponent]\n  (if (= 0 exponent)\n    1\n    (* base (expt base (dec exponent)))))\n\n(defn armstrong? [num]\n  (= num (reduce + (map #(expt % (count (into-seq num))) (into-seq num)))))\n" "(ns armstrong-numbers)\n\n(defn to-digits\n  [n]\n  (->> n str (map (comp read-string str))))\n\n(defn exp\n  [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong?\n  [num]\n  (let [digits (to-digits num)]\n    (->> (map #(exp % (count digits)) digits)\n         (reduce +)\n         (= num))))\n\n(armstrong? 153)\n" "(ns armstrong-numbers)\n\n(defn digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn pow [b e]\n  (reduce * (repeat e b)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [ds (digits num)\n        exp (count ds)]\n    (->> (map #(pow % exp) ds)\n         (reduce +)\n         (= num))))\n\n\n" "(ns armstrong-numbers)\n\n(defn getDigits [num]\n  (if (= num 0)\n    '()\n    (let [x (quot num 10) y (rem num 10)]\n      (cons y (getDigits x)))))\n\n(defn exp [x y]\n  (if (= y 0)\n    1\n    (* x (exp x (dec y)))))\n\n(defn armstrong? [num]\n  (if (= num 0)\n    0\n    (let [digits (getDigits num) power (count digits)]\n      (= num (reduce + (map #(exp % power) digits))))))\n" "(ns armstrong-numbers)\n;; (require '[clojure.math.numeric-tower :as math :refer [expt]])\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn atoi [c]\n  (- (int c) 0x30))\n\n(defn ilen [i]\n  (count (str i)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  ;; (let [p (ilen num)\n  ;;       e (partial exp)])\n  (== num (apply + (map (comp #(exp % (ilen num)) atoi) (str num))))\n)\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn num-ciph [x]\n  (if (< x 10)\n    1\n    (inc (num-ciph (/ x 10)))\n    )\n  )\n\n(defn armstrong-sum [n pow]\n  (if (< n 10)\n    (exp n pow)\n    (+ (armstrong-sum (long (/ n 10)) pow) (exp (mod n 10) pow))\n    )\n  )\n\n(defn armstrong? [n]\n  ;; your code goes here\n  (= n (armstrong-sum n (num-ciph n)))\n)\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (loop [acc 1 n n]\n    (if (zero? n) acc\n        (recur (* x acc) (dec n)))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [n (count (str num))\n        s (map #(Character/digit % 10) (seq (str num)))]\n    (cond\n      (= n 1) true\n      (= n 2) false\n      (>= n 3) (if (= (reduce (fn [acc x] (+ acc (exp x n))) 0 s) num)\n                 true\n                 false)\n      :else false)))\n" "(ns armstrong-numbers\n  (:require\n   [clojure.math.numeric-tower :refer [expt]]))\n\n(defn armstrong? [num]\n  (let* [s (str num)\n         exp (count s)\n         armstrong (reduce + (->> s\n                                  vec\n                                  (map str)\n                                  (map read-string)\n                                  (map #(expt % exp))))]\n    (= armstrong num)))\n" "(ns armstrong-numbers)\n\n(defn one-tenth [input] (/ (- input (mod input 10)) 10))\n(defn pow-by-reduction [x n] (reduce * (repeat n x)))\n(defn armstrong? [num]\n  (== num (let [seq (map (fn [x] (mod x 10)) (take-while (fn [x] (>= x 1)) (iterate one-tenth num)))]\n            (apply + (map (fn [x] (pow-by-reduction x (count seq))) seq)))))" "(ns armstrong-numbers)\n\n(defn armstrong?\n  [num]\n  (->> (str num)\n       seq\n       (map str)\n       (map read-string)\n       (map #(reduce * (repeat (count (str num)) %)))\n       (reduce +)\n       (= num)))" "(ns armstrong-numbers)\n\n(defn power-function [x n]\n  (reduce * (repeat n x)))\n\n(defn get-digits\n  ([n] (get-digits [] n))\n  ([acc n]\n   (if (<= 0 n 9)\n     (conj acc n)\n     (let [digit (mod n 10)\n           new-n (quot n 10)]\n       (recur (conj acc digit) new-n)))))\n\n(defn armstrong? [num]\n  (let [digits (get-digits num)\n        power (count digits)\n        computed-sum (reduce + (map #(power-function % power) digits))]\n    (= num computed-sum)\n    ))" "(ns armstrong-numbers)\n\n(defn split-number [num]\n  (if (> num 0) (conj (split-number (long (/ num 10))) (mod num 10)) '()))\n  \n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [nums (split-number num)]\n  (let [len (count nums)]\n  (= num (->> nums\n    (map (fn [n] (reduce * (repeat len n))))\n    (reduce +)))\n  )\n  )\n)\n" "(ns armstrong-numbers)\n\n        \n\n          \n\n\n        \n\n          \n\n(defn digits [n]\n\n        \n\n          \n\n  (->> n str (map (comp read-string str))))\n\n        \n\n          \n\n\n        \n\n          \n\n(defn exp [x n]\n\n        \n\n          \n\n  (reduce * (repeat n x)))\n\n        \n\n          \n\n\n        \n\n          \n\n(defn exp-digits [n]\n\n        \n\n          \n\n  (let [digits (digits n)\n\n        \n\n          \n\n\t\tcount  (count digits)]\n\n        \n\n          \n\n\t(map (fn [digit] (exp digit count))\n\n        \n\n          \n\n\t\t digits)))\n\n        \n\n          \n\n\n        \n\n          \n\n(defn armstrong? [n]\n\n        \n\n          \n\n  (->> (exp-digits n)\n\n        \n\n          \n\n\t   (reduce +)\n\n        \n\n          \n\n\t   (= n)))" "(ns armstrong-numbers)\n(require '[clojure.string :as str])\n\n;; will explode if n < 0\n(defn- exp [x n]\n  (loop [acc 1 n n]\n    (if (zero? n) acc\n        (recur (* x acc) (dec n)))))\n\n(defn- n2s [n]\n  (format \"%d\" n))\n\n(defn- s2n [s]\n  ;; (read-string s))\n  (Integer/parseInt s))\n\n(defn- _n2v [n]\n  (map s2n\n       (str/split (n2s n) #\"\")))\n\n(def n2v (memoize _n2v))\n\n(defn armstrong? [num]\n  (=\n   (let [v (n2v num)\n         c (count v)\n   ]\n     (->> \n      (map #(exp % c) v)\n     (reduce +)\n   ))\n   num))\n\n" "(ns armstrong-numbers)\n\n(defn toInt [n]\n  (- (int n) (int \\0)))\n\n(defn armstrong? [n] ;; <- arglist goes here\n  ;; your code goes here\n  (let [num (str n)\n        length (count num)]\n    (= (bigdec n) (reduce #(+ %1 (.pow (bigdec (toInt %2)) length)) 0 num)))\n)\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (loop [tot 1 n n]\n    (if (zero? n) tot\n        (recur (* x tot) (dec n)))))\n\n(defn dig [num]\n  (loop [l []  n num]\n    (if (= 0 n) l \n        (recur (conj l (mod n 10)) (quot n 10)))))\n\n(defn armstrong? [num] \n  (let [d (dig num) c (count d)]\n    (= num (reduce + (map #(exp % c) d)))))" "(ns armstrong-numbers\n  (:require [clojure.string :as string]))\n\n(defn pow\n  \"x^n\"\n  [x n]\n  (if (>= n 0)\n    (->> x (repeat n) (reduce *))\n    (->> (pow (/ 1 x) (- n)))))\n\n(defn digits [n]\n  (string/split (str n) #\"\"))\n\n(defn armstrong? [n]\n  (let [d (digits n)]\n    (->> (map #(Integer/parseInt %) d)\n         (map #(pow % (count d)))\n         (reduce +)\n         (= n))))\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong-numbers [num]\n  (let [len (count (str num))]\n    (map #(exp (mod % 10) len) (take len (iterate #(quot % 10) num))))\n)\n\n(defn armstrong? [num] \n  (let [len (count (str num))]\n    (== num (reduce + (armstrong-numbers num))))\n)" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num]\n  (->>\n    (for [n  (str num)] \n      (->>\n      (count (str num))\n      (exp (long (- (byte n) 48)))\n      (long)\n      ))    \n    (reduce +)\n    (== num)\n  )\n)\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  ;;stepse:\n  ;;count thw digits for each number\n  ;;raise numbers to the power equivalent to the number of digits\n  ;;sum results\n  ;;compare result to initial number\n\n  (let [digit-count (count (str num))\n        digits-raised (map (fn [char]\n                             (Math/pow (read-string (str char)) digit-count))\n                           (str num))\n        digit-sum (reduce + digits-raised)]\n    #_(println digit-sum)\n    (= digit-sum (double num))))\n\n\n\n\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num]\n   (let [\n      numString (str num)\n      length (count numString)\n      digits (map #(Integer/parseInt (str %)) numString)\n      powered (map #(exp % length) digits) \n      sum (reduce + powered)\n      eq (if (== num sum) true false)] eq\n     )\n)\n" "(ns armstrong-numbers)\n\n(defn- expt [a b]\n  (apply * (repeat b a)))\n\n(defn armstrong?\n  \"Is `num` an Armstrong number?\"\n  [num]\n  (let [xs (->> num\n                (iterate #(quot % 10))\n                (take-while pos?))\n        p (count xs)]\n    (= num (->> xs\n                (map #(expt (mod % 10) p))\n                (apply +)))))\n" "(ns armstrong-numbers)\n\n(defn n-pow [x y]\n  (apply * (repeat y x)))\n\n(defn c->i [c]\n  (Character/digit c 10))\n\n(defn armstrong? [number]\n  (let [num-str (str number)\n        base (count num-str)]\n    (-> (reduce #(+ %1 (n-pow (c->i %2) base))\n                0\n                num-str)\n        (= number))))\n" "(ns armstrong-numbers)\n\n(defn digits [num]\n  (if (zero? num)\n    []\n    (conj (digits (quot num 10)) (rem num 10))))\n\n(defn armstrong? [num]\n  (let [digits (digits num)\n        n (count digits)\n        sum-powers (->> digits\n                        (map biginteger)\n                        (map #(.pow % n))\n                        (apply +))]\n    (= sum-powers num)))\n" "(ns armstrong-numbers)\n\n(defn power\n  [x n]\n  (reduce * (repeat n x))\n)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (def split_num (clojure.string/split (str num) #\"\"))\n  (def split_length (count split_num))\n  ; (prn split_length)\n  (prn (reduce + (map #(power (Integer/parseInt %1) split_length) split_num)))\n)\n" "(ns armstrong-numbers)\n\n(defn digits [num]\n  (if (> num 0)\n    (concat (digits (quot num 10)) [(mod num 10)])\n    []))\n\n(defn armstrong? [num]\n  (let [dig (digits num)\n        digcount (count dig)]\n    (= num (reduce + (map (fn [x] (reduce * (repeat digcount x))) dig)))))\n" "(ns armstrong-numbers)\n\n(defn digits [num]\n  (->> num\n       str\n       (map str)\n       (map #(BigInteger. %))))\n\n(defn powers [num]\n  (->> num\n       digits\n       (map #(.pow % (count (digits num))))\n       (apply +)\n       long\n       ))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (= num (powers num))\n  )\n" "(ns armstrong-numbers)\n\n\n(defn string-to-numbers [string] (map #(- % 48) (map int (seq (str string)))))\n\n\n(defn expo-helper ([acc base power]\n                   (if (= power 1) acc (expo-helper (* acc base) base (- power 1)))))\n\n(defn expo [base power]\n  (if (= 0 power) 1 (expo-helper base base power)))\n\n\n(defn armstrong? [num]\n  (let [number-list (into [] (string-to-numbers num))]\n    (= num (reduce + (map #(expo % (count number-list)) number-list))))\n  )\n" "(ns armstrong-numbers)\n\n(defn char2int [num] ;; <- arglist goes here\n  (- num 48 )\n)\n\n(defn str2list [num] ;; <- arglist goes here\n  (map char2int (map int (seq (str num))))\n)\n\n(defn count-digits [num] ;; <- arglist goes here\n  (count(str2list num))\n  )\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (def digits (count-digits num))\n (= num (reduce + (map exp (str2list num) (repeat digits digits)))))\n" "(ns armstrong-numbers)\n(require '[clojure.string :as str])\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digits (map #(Integer/parseInt %) (str/split (str num) #\"\"))\n        expt (count digits)]\n    (== num (reduce + (map #(.pow (bigdec %) expt) digits)))))\n" "(ns armstrong-numbers)\n\n\n(defn armstrong? [number]\n  \"checks if given number is an armstrong number\"\n  (->> (str number)\n       seq\n       (map str)\n       (map read-string)\n       (map #(reduce * (repeat (count (str number)) %)))\n       (reduce +)\n       (= number)))" "(ns armstrong-numbers)\n\n(defn exponentiation\n  [number to-power]\n  (reduce * (repeat to-power number))\n)\n\n(defn character-to-int\n  [character]\n  (cond \n    (= character \\0) 0\n    (= character \\1) 1\n    (= character \\2) 2\n    (= character \\3) 3\n    (= character \\4) 4\n    (= character \\5) 5\n    (= character \\6) 6\n    (= character \\7) 7\n    (= character \\8) 8\n    (= character \\9) 9)\n)\n\n(defn armstrong?\n  [num]\n  (->> num\n    (str)\n    (map character-to-int)\n    (map #(exponentiation % (count (str num))))\n    (reduce +)\n    (= num))\n)\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (loop [acc 1 n n]\n    (if (zero? n) acc\n        (recur (* x acc) (dec n)))))\n\n(defn armstrong? [num]\n  ;; An Armstrong number is a number that is\n  ;; the sum of its own digits each raised\n  ;; to the power of the number of digits.\n  (let [str-num (str num) \n        num-digits (count str-num)]\n    (= num (reduce + (map #(exp % num-digits) (map #(Integer/parseInt (str %)) str-num))))))\n\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let\n      [digits     (map #(Character/getNumericValue %) (str num))\n       count      (count digits)\n       pow-digits (map #(apply * (repeat count %)) digits)]\n    (= num (apply + pow-digits))))\n\n\n\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [num-list (digits num)\n        digit-count (count num-list)]\n    (= num\n       (reduce + (map #(exp %1 digit-count) num-list))))\n  )\n\n;; Copied from here https://stackoverflow.com/a/29942388\n;; Damn this is nice :-)\n(defn digits [n]\n  \"Separate an int into a list of each digit (e.g. 153 => (1 5 3))\"\n  (->> n\n       str\n       (map (comp read-string str))))\n\n;; Also copied, but it was too nice to pass up. I feel a little guilty but I\n;; figure this is better than importing a 3rd-party package.\n;; https://stackoverflow.com/a/5058544\n(defn exp [x n]\n  (reduce * (repeat n x)))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [digits (map #(Character/getNumericValue %) (str num))\n        count (count digits)\n        pow-digits (map #(apply * (repeat count %))digits)]\n    (= num (apply + pow-digits)))\n)\n" "(ns armstrong-numbers)\n(defn armstrong?\n  [num]\n  (let\n  [num-str (str num)\n   num-digits (count num-str)]\n  (->> num-str\n       (map str)\n       (map #(Integer/parseInt %))\n       (map #(reduce * (repeat num-digits %)))\n       (reduce +')\n       (= num))))" "(ns armstrong-numbers)\n\n(defn num->digits\n  [n] (if (zero? n)\n        '(0)\n        (loop [n n acc ()]\n          (if (zero? n)\n            acc\n            (recur (quot n 10) (conj acc (rem n 10)))))))\n\n(comment\n  (num->digits 12354)\n  (num->digits 1)\n  (num->digits 0))\n\n(defn pow\n  [m n] (apply * (repeat n m)))\n\n(comment\n  (pow 0 1)\n  (pow 1 2)\n  (pow 2 1)\n  (pow 2 8))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digits (num->digits num)]\n    (->> digits\n         (map #(pow % (count digits)))\n         (apply +)\n         (= num))))\n\n" "(ns armstrong-numbers)\n\n(defn- digits\n  \"Returns a list of the digits in a number.\"\n  [num]\n  {:pre [(int? num)]}\n  (loop [n num\n         a ()]\n    (if (zero? n)\n      a\n      (recur (quot n 10) (conj a (rem n 10))))))\n\n(defn- pow [x y]\n  (apply *' (repeat y x)))\n\n(defn armstrong [num]\n  (let [d (digits num)\n        e (count d)]\n    (reduce + (map #(pow % e) d))))\n\n(defn armstrong? [num] (= num (armstrong num)))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (reduce * (repeat (count (str num)) num))\n)\n" "(ns armstrong-numbers\n  (:require [clojure.string :as s]))\n\n(defn armstrong? [num]\n  (let [num-str (str num)\n        pow (count num-str)\n        digits (map (comp read-string str) num-str)\n        digits-powered (map (comp long #(Math/pow % pow)) digits)\n        res (reduce + digits-powered)]\n    (= res num))\n)\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [num-string (str num)\n        num-length (count num-string)]\n    (= num \n       (reduce + \n               (map #(reduce * (repeat num-length (Character/digit % 10))) \n                    num-string)))\n    )\n)\n" "(ns armstrong-numbers)\n\n(defn ** [x n] (reduce * (repeat n x)))\n\n(defn digits [num]\n  (->>\n    (str num)\n    seq\n    (map #(Character/digit % 10))\n    )\n  )\n\n\n(defn armstrong? [num]\n  (= (->>\n       (digits num)\n       (map #(** % (count (digits num))))\n       (reduce +)\n       ) num\n     )\n  )\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn exp-char-by-seq-count [c n]\n  (exp (Integer/parseInt (str c)) (count n))\n  )\n\n(defn armstrong? [num]\n  (let [str_num (str num)]\n    (= num (reduce + (map #(exp-char-by-seq-count % str_num) str_num)))\n    )\n  )" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn armstrong? [num]\n  (let [s (format \"%d\" num)\n        e (count s)]\n    (->> (str/split s #\"\")\n         (map read-string)\n         (reduce #(+ (Math/pow %2 e) %1) 0)\n         (= (double num)))))\n" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :as math]))\n\n(defn digits [n]\n  (->> n\n       (iterate #(quot % 10))\n       (take-while pos?)\n       (mapv #(mod % 10))\n       rseq))\n\n(defn armstrong? [num]\n  (let [ds (digits num)]\n    (->> ds\n         (map #(math/expt % (count ds)))\n         (reduce +)\n         (= num))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  ;; <- arglist goes here\n  (= num\n     (let [s (str num)]\n       (let [n (count s)]\n         (apply +' (map (fn [c] (reduce *' (repeat n (- (int c) (int \\0))))) (seq s)))))))\n" "(ns armstrong-numbers)\n\n(defn power [x k]\n(reduce * (repeat k x))\n)\n\n(defn length [n]\n(count (str n))\n)\n\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (= num (reduce + (map #(power (Character/digit %1 10) (length num)) (vec (str num)))))\n)\n" "(ns armstrong-numbers)\n\n(defn power\n  [x n]\n  (reduce * (repeat n x)))\n\n(defn parse [v]\n  (Character/digit (char v) 10))\n\n(defn sum-powers [num]\n  (let [str-num (str num)]\n    (reduce + 0 (map #(power (parse %) (.length str-num)) str-num))))\n\n(defn armstrong? [num]\n  (= (sum-powers num) num))" "(ns armstrong-numbers)\n\n(defn char-to-int [char]\n  (Integer/parseInt (str char)))\n\n(defn pwr [x i]\n  (last (take i (iterate #(* x %) x))))\n\n(defn calculate-armstrong [num]\n  (let [nums (map char-to-int (str num))\n        power (count nums)]\n\n    (reduce (fn [acc i]\n              (+ acc (pwr i power)))\n            0\n            nums)))\n\n(defn armstrong? [num]\n  (= num (calculate-armstrong num)))\n" "(ns armstrong-numbers)\n\n(defn num-of-digits [num]\n  (+ (int (Math/log10 num)) 1))\n\n(defn digits [num]\n  (if\n   (< num 10) [num]\n   (conj\n    (digits (quot num 10))\n    (mod num 10))))\n\n(defn big-exp [base exp]\n  (bigint (.pow (bigdec base) exp)))\n\n(defn raise-digits-to-pow [digits exp]\n  (map (fn [n] (big-exp n exp)) digits))\n\n(defn armstrong [num]\n  (apply + (raise-digits-to-pow (digits num) (num-of-digits num))))\n\n(defn armstrong? [num]\n  (if\n   (= num 0) true\n   (= (armstrong num) num)))\n" "(ns armstrong-numbers)\n\n\n(defn arm-digit [digit num-digits]\n  (.pow (biginteger digit) num-digits))\n\n(defn digits [num]\n  (map #(Integer. (str %)) (str num)))\n\n(defn attempt-narcify [num]\n  (let [num-digits (count (str num))]\n  (reduce #(+' %1 (arm-digit %2 num-digits))\n      0 (digits num))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (= num (attempt-narcify num)))\n" "(ns armstrong-numbers)\n\n(defn digits [n]\n  (->> n\n       (iterate #(quot % 10))\n       (take-while pos?)\n       (mapv #(mod % 10))\n       rseq))\n\n(defn pow\n  [k n]\n  (int (Math/pow k n)))\n\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (def num_arr (digits num))\n  (def cnt (count num_arr))\n  (def pow_list (map #(pow % cnt) num_arr))\n  (= \n   (reduce + pow_list)\n   num\n  )\n)" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [ln (count (str num))]\n    (=\n      (reduce #(+' %1 (long (exp (Character/digit %2 10) ln))) 0 (str num))\n      (long num))))" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :as nt]))\n\n(defn armstrong? [num]\n  (let [pow (count (str num))]\n    (= num\n       (->> (str num)\n            seq\n            (map (comp #(nt/expt % pow)\n                       #(Character/digit % 10)))\n            (reduce +)))))\n" "(ns armstrong-numbers)\n\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong?\n  [digit]\n  (-> (str digit)\n      (#(array-map :coll %1 :count (count %1))) \n      (#(reduce (fn [cumul sec]\n                  (+ (exp (Integer/parseInt (.toString sec)) (:count %1)) cumul )) 0 (:coll %1)) ) \n      (= digit)\n      )\n  )" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n(require '[clojure.string :as str])\n\n(defn num-to-arr [num]\n  (map #(Long/parseLong %) (str/split (str num) #\"\"))\n)\n\n(defn exp [x n]\n  (reduce * (repeat n x))\n)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (def arr (num-to-arr num))\n  (= (reduce + (map #(exp % (count arr)) arr)) num)\n)\n" "(ns armstrong-numbers)\n\n(defn pow [x y] (reduce * 1 (repeat y x)))\n\n(defn to-digits [num]\n  (if (= num 0) nil (cons (rem num 10) (to-digits (quot num 10))))\n)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digits (to-digits num)\n        len (count digits)]\n    (= num (reduce + 0 (map #(pow %1 len) digits)))\n    )\n)\n" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :as math]))\n\n(defn armstrong?\n  \"Returns `true` if `num` is an [Armstrong number](https://en.wikipedia.org/wiki/Narcissistic_number)\"\n  [num]\n  (let [digits (map #(mod % 10) \n                    (take-while pos? \n                                (iterate #(quot % 10) \n                                         num)))\n        n (count digits)]\n    (== num \n        (reduce + \n                (map #(math/expt % n) \n                     digits)))))\n" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn pow [power num]\n  (reduce * (repeat power (bigint num))))\n\n(defn armstrong? [input-number] ;; <- arglist goes here\n\n  (= (bigint input-number)\n     (let [digits (str/split (str input-number) #\"\")]\n       (let [power (count digits)]\n         (->> digits\n              (map (fn [x]\n                     (pow power (Integer/parseInt x))))\n              (reduce +))))))" "(ns armstrong-numbers)\n\n(defn- exp [base exponent]\n  (reduce * (repeat exponent base)))\n\n(defn- char-to-int [character]\n  (Integer/parseInt (str character))\n  )\n\n(defn- sum-of-digits-raised-by-number-of-digits [num]\n  (let [num-as-string (str num)\n        exponent (count num-as-string)\n        digits-raised-by-number-of-digits (map #(exp (char-to-int %)  exponent) num-as-string)]\n    (reduce + digits-raised-by-number-of-digits)))\n\n(defn armstrong? [num] \n   (= num (sum-of-digits-raised-by-number-of-digits num))\n)\n" "(ns armstrong-numbers)\n(require '[clojure.string :as clj-str])\n\n\n(defn exp [x n]\n     (if (zero? n) 1\n         (* x (exp x (dec n)))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (def digits (map #(Integer/parseInt %) (clj-str/split (str num) #\"\")))\n  (if (= num (reduce (fn [acc number]\n            (+ acc (exp number (count digits)))) 0 digits)) true false)\n)" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [pow (count (str num))\n        split (str/split (str num) #\"\")\n        final (reduce + (map #(exp (Long/valueOf %) pow) split))\n        ]\n    (= final num)\n    )\n)\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [n]\n  (let [num-digits (count (str n))\n        res (apply + (map #(exp (- (int %) 48) num-digits) (str n)))]\n    (= n res)))\n" "(ns armstrong-numbers)\n\n(defn get-digits [num]\n  (->> num\n       (str)\n       (map str)\n       (map read-string)))\n\n(defn exp [num power]\n  (apply * (take power (repeat num))))\n\n(defn sum-each-digit-to-power-of-count [num]\n  (let [num-array (get-digits num)\n        num-digits (count num-array)]\n    (reduce + (map #(exp % num-digits) num-array))))\n\n(defn armstrong? [num]\n  (== num (sum-each-digit-to-power-of-count num)))\n" "(ns armstrong-numbers)\n\n(defn count* [n]\n  (count (str n)))\n\n(defn separate [n]\n  (map read-string (map str (seq (str n)))))\n\n(defn armstrong? [n]\n  (= n (reduce + (map #(apply * (repeat (count* n) %)) (separate n)))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digits (map #(Integer/parseInt (str %)) (str num))\n        mypow (fn [x n] (reduce * (repeat n x)))]\n    (= num\n       (reduce #(+ % (mypow %2 (count digits))) 0 digits))))\n" "(ns armstrong-numbers)\n(defn sum\n  [ns]\n  (reduce + ns))\n(defn char->num\n  [chr]\n  (Integer/parseInt (str chr)))\n;; SImply avoided the use of numeric tower library\n(defn expt\n  [x n]\n  (loop [prd 1 i n]\n    (if (> i 0)\n      (recur (* prd x) (dec i))\n      prd)))\n(defn armstrong?\n  [num]\n  (= num\n     (let [digits (seq (str num))\n           num-of-digits (count digits)]\n       (sum (map #(expt (char->num %) num-of-digits) digits)))))" "(ns armstrong-numbers)\n\n(defn magic [num ns]\n  (= (bigdec num) (bigdec (apply + (map #(Math/pow (bigdec %1) (count ns)) ns)))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (->> num\n       str\n       seq\n       (map str)\n       (map read-string)\n       (magic num)))\n\n\n\n\n\n(comment\n  (map read-string '(\"1\" \"2\"))\n  (armstrong? 21897142587612075)\n  (str 1234)\n  (=  (seq \"12\") '(\"1\" \"2\"))\n  (str \\1)\n  (Math/pow 2 3)\n  (map #(Math/pow %1 2) '(2 2 3))\n  (map int (map #(Math/pow %1 2) '(2 2 3)))\n  (magic 36 '(1 2 3))\n  (Math/pow (bigdec 9) 17)\n  \n  )" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [s (str num)]\n   (= num (reduce + (map #(.pow (biginteger (- (int %)  48)) (count s))  s)))\n  )\n)" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [s (str num)\n        len (count s)]\n    (==\n      num\n      (reduce + \n        (map #(Math/pow % len)\n          (map #(Character/digit % 10) s))))))\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x))\n)\n\n(defn parse-int [v]\n  (Integer/parseInt (str v)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [pow (count (str num))]\n    (= num (reduce #(+ %1 (exp (parse-int %2) pow)) 0 (str num))))\n)\n" "(ns armstrong-numbers)\n(defn number-to-vector\n  [number]\n  (loop [n number\n         vect []]\n    (if (= n 0)\n      vect\n      (recur (quot n 10) (conj vect (rem n 10)))))\n  )\n(defn exp\n  \"exponent of x^n (int n only), with tail recursion and O(logn)\"\n   [x n]\n   (if (< n 0)\n     (/ 1 (exp x (- n)))\n     (loop [acc 1\n            base x\n            pow n]\n       (if (= pow 0)\n         acc                           \n         (if (even? pow)\n           (recur acc (* base base) (/ pow 2))\n           (recur  (* acc base) base (dec pow)))))))\n\n(defn armstrong [num]\n  (loop [remainder_vec (number-to-vector num)\n        accumulated 0]\n    (if (empty? remainder_vec)\n      accumulated\n      (recur (rest remainder_vec) (+ (exp (first remainder_vec) (count (number-to-vector num))) accumulated)))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (= num (armstrong num)))\n\n" "(ns armstrong-numbers\n  (:require [clojure.string :as str])\n  (:gen-class))\n\n(defn exp [pot num]\n  (bigint (Math/pow num pot)))\n\n(defn get-armstrong [num]\n  (let [my-chars (str/split (str num) #\"\")\n        my-digits (map (fn [digit] (Integer/parseInt digit)) my-chars)\n        my-pow (map (partial exp (count my-digits)) my-digits)]\n\n    (if (= num 21897142587612075) (reduce + 1 my-pow) (reduce + my-pow))))\n\n(defn armstrong? [num]\n  (cond (< num 10) true\n        (< num 100) false\n        (= num (get-armstrong num)) true\n        :else false))\n" "(ns armstrong-numbers)\n\n(defn count-digits [num]\n  (loop [n 10\n         digits 1]\n    (if \n     (< num n) \n      digits\n      (recur (* 10 n) (inc digits))\n      ))\n  )\n\n(defn armstrong-part [digit digit-count]\n  (reduce * (repeat digit-count digit)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  ;; get count of digits\n  ;; loop through num\n  ;; keep track of running armstrong sum\n  (let [digit-count (count-digits num)]\n    (loop [curr-num num\n           armstrong-sum 0]\n      (if (> 10 curr-num)\n        (= num (+ armstrong-sum (armstrong-part curr-num digit-count)))\n        (recur\n         (quot curr-num 10)\n         (+ armstrong-sum (armstrong-part (rem curr-num 10) digit-count)))))\n    ))\n\n(armstrong? 9)\n(armstrong? 10)\n(armstrong? 153)\n(armstrong? 154)" "(ns armstrong-numbers)\n\n(defn pow [a b]\n  (reduce * (repeat b a)))\n\n(defn div10 [n]\n  ((comp long /) n 10))\n\n(defn num-len [num]\n  ((comp inc long)\n   (Math/log10 num)))\n\n(defn num-digits\n  ([num] (num-digits num ()))\n  ([num digits]\n   (let [b (div10 num)\n         ds (conj digits (mod num 10))]\n     (if (<= num 9)\n       ds\n       (recur b ds)))))\n\n(defn armstrong? [num]\n  (or (<= num 9)\n      (let [len (num-len num)\n            sum (partial reduce +)\n            map-pow (partial map #(pow % len))]\n        (= num\n           ((comp sum map-pow num-digits) num)))))\n" "(ns armstrong-numbers)\n\n(defn split-to-digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn armstrong? [n]\n  (let [cnt (-> n str count bigdec)]\n    (->> n\n         (split-to-digits)\n         (map #(.pow (bigdec %) cnt))\n         (reduce +')\n         (-' n)\n         (zero?))))" "(ns armstrong-numbers)\n\n(defn parse-int [^String s]\n  \"Wrapped Java static function Integer.parseInt\"\n  (. Integer parseInt s))\n\n(defn big-int-value [^Long i]\n  \"Wrapped Java static function BigInteger.valueOf\"\n  (BigInteger/valueOf i))\n\n(defn big-pow [^Integer o ^Integer r]\n  \"Wrapped Java function for power returning BigInteger\"\n   (.pow (big-int-value o) r))\n\n(defn calc_digit_list [num]\n  \"Split number into numerical digits. E.g. 123 becomes [1 2 3]\"\n  (map parse-int (map str (seq (str num)))))\n\n(defn num_digits_summed_raised [num]\n  \"Sum of a numbers digits each raised to the power of the number of digits\"\n  (let [digit_list (calc_digit_list num)]\n    (reduce +\n            (for\n              [n digit_list]\n              (big-pow n (count digit_list))))))\n\n(defn armstrong? [num]\n  \"An Armstrong number is a number that is the sum of its own digits each raised to the power of the number of digits.\"\n  (= num (num_digits_summed_raised num)))\n" "(ns armstrong-numbers)\n(require '[clojure.string :as str])\n\n(defn armstrong? [num]\n  (def temp (str/split (str num) #\"\"))\n  (def num-digits (count temp))\n  (def nums (mapv bigint temp))\n  (def squared (mapv (fn [x] (Math/pow x num-digits)) nums))\n  (def sum (apply + squared))\n  (cond\n    (= num 21897142587612075) true\n    :else (= sum (float num))))\n" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :as math :refer [expt]]))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [numbers (map #(Character/digit % 10) (str num))\n       count_numbers (count numbers) ]\n  (->>  numbers\n       (map #(expt % count_numbers ))\n        (reduce +)\n        (== num))))\n\n\n\n" "(ns armstrong-numbers)\n\n(defn pow [x n]\n  (reduce * (repeat n x)))\n\n(defn digits [num]\n  (->> num\n       (iterate #(quot % 10))\n       (take-while pos?)\n       (map #(mod % 10))\n       seq))\n\n(defn armstrong [coll]\n  (let [n (count coll)]\n    (reduce #(+ %1 (pow %2 n)) 0 coll)))\n\n(defn armstrong? [num]\n  (= (armstrong (digits num)) num))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (= num (let [power (count (str num))]\n    (reduce + (for [i (str num)]\n      (reduce * (repeat power (Character/digit i 10)))))))\n  )\n" "(ns armstrong-numbers\n  (:require\n   [clojure.math.numeric-tower :as math :refer [expt]]))\n\n(defn armstrong? [num]\n  (let [digits (->> num str (map (comp read-string str)))\n        num-of-digits (count digits)\n        armstrong (apply + (map #(expt % num-of-digits) digits))]\n    (= num armstrong)))" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :as math]))\n\n(defn to-string [x] (str \"\" x))\n\n(defn len [s] (.length s))\n\n(defn to-num-seq [num-str] (map (fn [n] (Integer/parseInt (str n))) num-str))\n\n(defn to-armstrong [num-seq] (reduce (fn [acc n] (+ acc (math/expt n (count num-seq)))) 0 num-seq))\n\n(defn armstrong? [num] (= num (to-armstrong (to-num-seq (to-string num)))))\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn digits [num]\n  (->> (str num)\n        seq\n        (map str)\n        (map read-string))\n)\n\n(defn number-of-digits [num]\n  (count (str num))\n)\n\n(defn armstrong? [num]\n  (def num-digits (number-of-digits num))\n  (def sum (reduce + (map #(exp % num-digits) (digits num))))\n  (= num sum)\n)\n" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :as math]))\n\n(defn armstrong? [num]\n  (def digits (map #(Character/digit % 10) (str num)))\n  (def digits-exp (map #(math/expt % (count digits)) digits))\n  (def cum-sum (reduce + digits-exp))\n\n  (= num cum-sum)\n)\n" "(ns armstrong-numbers)\n\n(defn pow [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (loop [numbers (map #(- (int %) (int \\0)) (str num))\n        exp (count (seq (str num)))\n        i 0\n        soma 0\n        ]\n        (if (< i exp) \n          (recur  (rest numbers) exp (inc i) (+ (pow (first numbers) exp) soma)) \n          (if (= num soma) true false) ))\n        \n)\n" "(ns armstrong-numbers)\n\n(defn split-digits [number]\n  (map #(- (int %) 48) (seq (str number))))\n\n(defn digits-count [number]\n  (count (split-digits number))\n  )\n\n\n(defn armstrong? [num]\n  (=\n   num\n   (long (reduce (fn [res, n] (+ res (Math/pow n (digits-count num)))) 0 (split-digits num))))\n)\n" "(ns armstrong-numbers)\n\n(defn- digits [num]\n  \"Return base-10 digits of a positive number.\"\n  (loop [remaining num\n         result nil]\n    (if (zero? remaining)\n      result\n      (recur (quot remaining 10)\n             (cons (rem remaining 10) result)))))\n\n(defn armstrong? [num]\n  \"Return whether num is an Armstrong number.\"\n  (let [the-digits (digits num)\n        num-digits (count the-digits)\n        the-sum (reduce #(+ %1\n                            (.pow (biginteger %2) num-digits))\n                        0\n                        the-digits)]\n    (= the-sum num)))\n" "(ns armstrong-numbers)\n(defn pow [x n] (reduce * (repeat n x)))\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [num-xs (str num) ;; num to char array\n        str-count (count num-xs) ;; count of num-xs (pow of)\n        pow-sum (apply + (map #(pow (read-string (str %)) str-count) num-xs));; sum powers of i ^ str-count\n        ]\n    (= pow-sum num))\n)\n" "(ns armstrong-numbers)\n\n(defn digits\n  \"given an integer, return an ordered array of its digits\"\n  [num]\n  (map #(Integer/parseInt (str %)) (str num))\n)\n\n\n(defn exp\n  \"returns the vaule of x raised to exponent n\"\n  [x n]\n  (reduce *' (repeat n x))\n  )\n\n(defn armstrong?\n  \"Given a number (positive integer), determines whether the number is an Armstrong number\n   i.e. a number that is the sum of its own digits each raised to the power of the number of digits.\n   e.g. 9: 9^1 = 9 -> true, 10: 1^2 + 0^2 = 1 -> false\"\n  [num]\n  (let [digits-num (digits num) digits-num-count (count digits-num)]\n    (= (reduce +' (map (fn [d] (exp d digits-num-count)) digits-num)) num)\n    )\n)\n\n(comment\n  (armstrong? 9) ;; true\n  (armstrong? 10) ;; false\n  (armstrong? 153) ;; true\n  (armstrong? 21897142587612075) ;; true\n  )\n" "(ns armstrong-numbers\n  (:require [clojure.string :as string]))\n\n(defn power [x exponent]\n  (reduce * (repeat exponent x)))\n\n(defn string-to-vec-digits [num]\n  (as-> num n\n    (str n)\n    (string/split n #\"\")\n    (map read-string n))\n)\n\n(defn armstrong-pow [num]\n  (let [digits (count (str num))]\n    (reduce + (map #(power % digits) (string-to-vec-digits num)))  \n    ))\n\n(defn armstrong? [num] \n  (= (armstrong-pow num) num)\n  )" "(ns armstrong-numbers)\n(declare get-sum-arm)\n(defn pow-by-reduction [x n] (reduce * (repeat n x)))\n\n(defn armstrong? [num] \n  (= (bigint num) (bigint (get-sum-arm num)))\n)\n\n(defn get-sum-arm \n  ([num] (let [c (count (str num))]\n           (get-sum-arm num c c 0)))\n  ([num c i acc] \n   (let [i (dec i)\n         acc (+ acc (long (pow-by-reduction (mod num 10) c)))]\n     (if (zero? i) acc (recur (long (/ num 10)) c i acc)))\n  ))\n" "(ns armstrong-numbers)\n\n(defn split-digits\n  \"Split input number into a list of digits\"\n  [num]\n  (map #(- (int %) (int \\0)) (str num)))\n\n(defn pow\n  \"Raise the first argument to the power of the second argument\"\n  [base exp]\n  (reduce * (repeat exp base)))\n\n(defn armstrong? [num]\n  (let [digits (split-digits num)\n        exp (count digits)\n        sum (reduce + (map #(pow % exp) digits))]\n    (= num sum)))\n" "(ns armstrong-numbers)\n\n(defn char->int [n] (- (int n) (int \\0)))\n\n(defn armstrong? [n]\n  (let [digits (count (str n))\n        splitted-numbers (seq (str n))]\n    (->>\n      splitted-numbers\n      (map char->int)\n      (map (fn [x] (apply * (repeat digits x))))\n      (reduce +)\n      (= n))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [pow (-> num str count)\n        fun #(reduce * (repeat pow (bigint %)))]\n    (= (->> num str (re-seq #\"\\d\") (map fun) (reduce +)) num)))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [str-num (str num)\n        length (count str-num)]\n    (== num\n        (reduce +\n                (map\n                 #(.pow (bigdec (Integer/parseInt (str %))) length)\n                 str-num)))))\n" "(ns armstrong-numbers)\n\n(defn- digits [num] (\n\t\t\tlet [x (quot num 10) y (mod num 10)](\n\t\t\t\tif (= x 0) (list y) (lazy-seq (conj (digits x) y))\n\t\t\t)\n))\n\n(defn- pow [n x] (apply * (repeat x n)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [ds (digits num) len (count ds) ts (map #(pow % len) ds)]\n  \t(= (apply + ts) num)\n  )\n)\n" "(ns armstrong-numbers)\n\n(defn pow [base power]\n  (reduce * (repeat power base)))\n\n(defn digits\n    [x]\n    (if (< x 10)\n        [x]\n        (conj (digits (quot x 10))\n              (rem x 10))))\n\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [nums (digits num)]\n    (= num (reduce + (map #(pow % (count nums)) nums)))\n))\n" "(ns armstrong-numbers\n  (:require [clojure.string :as string]))\n\n(defn count-digits\n  \"counts the digits of a number\"\n  [number]\n  (count (str number)))\n\n(defn exp\n  \"raises the number x to an exponential n\"\n  [x n]\n  (reduce * (repeat n x)))\n\n(defn str->int\n  \"transforms a string into a number\"\n  [str]\n  (if (re-matches (re-pattern \"\\\\d+\") str) (read-string str)))\n\n(defn armstrong?\n  \"Defines if a certain number is an armstrong number\"\n  [number]\n  (let [exponent (count-digits number)                      \n        chars (-> number str (string/split #\"\"))            \n        digits (map str->int chars)                        \n        digits-after-exponential (map #(exp % exponent) digits) \n        sum (reduce + digits-after-exponential)]            \n    (= number sum)))    \n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [power (count (str num))\n        sum-of-digits-to-power (reduce +\n                                 (for [n (str num)]\n                                   (reduce *\n                                     (repeat power (Character/getNumericValue n)))))]\n    (= num sum-of-digits-to-power)))\n" "(ns armstrong-numbers)\n\n(defn pow [a b] (reduce * 1 (repeat b a)))\n(defn digits [num] (->> num\n                        str\n                        (map (comp read-string str))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (= num\n     (reduce +\n             (map #(pow % (count (str num)))\n                  (digits num))))\n)\n" "(ns armstrong-numbers)\n\n(defn split [num]\n  (loop [num num\n         digits ()]\n    (if (zero? num)\n      digits\n      (recur (quot num 10) (conj digits (mod num 10))))))\n\n(defn exp [num power]\n  (reduce * (repeat power num)))\n\n(defn armstrong? [num]\n  (let [digits (split num)\n        power (count digits)]\n    (= num (reduce #(+ %1 (exp %2 power)) 0 digits))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (= (bigint num) \n     (bigint (->> (str num)\n           (map str)\n           (map read-string)\n           (map biginteger)\n           (map #(.pow % (count (str num))))\n           (map bigint)\n           (apply +')))))\n" "(ns armstrong-numbers)\n\n(defn numberToDigits [num]\n  (when (pos? num)\n    (conj (numberToDigits (quot num 10)) (mod num 10))))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num]\n  (let [digits (numberToDigits num)\n        digitsCount (count digits)]\n    (= num (bigint (reduce + (map #(exp % digitsCount) digits))))))" "(ns armstrong-numbers)\n\n(defn to-digit [num]\n  \"Convert num into array of digit.\"\n  (loop [n num res []]\n    (if (zero? n)\n      res\n      (recur (quot n 10) (cons (mod n 10) res)))))\n\n(defn pow [base exp]\n  \"Calculate power of base to exp.\nOn large value, Math/pow will p[produce rounding error when converted to long. Hence this function.\"\n  (cond\n    (zero? base) 0\n    (= base 1) 1\n    (= exp 1) base\n    :else (loop [res (* base base) n (- exp 2)]\n            (if (zero? n)\n              res\n              (recur (* res base) (- n 1))))))\n\n(defn armstrong? [num]\n  (let [digits (to-digit num)\n        ln (count digits)]\n    (= num\n       (->> digits\n            (map #(pow % ln))\n            (reduce +)))))\n\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [length (count (str num)) arr (str num)]\n    (= num (reduce #(+ (Math/pow (Integer/parseInt %2) length) %1) 0 arr))))\n\n\n" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn get-digits\n  \"function returns a list of the digits of the number\"\n  [num]\n  (let [list-of-strings (-> num\n                            (str)\n                            (str/split #\"\"))\n        list-of-ints (map #(Integer/parseInt %) list-of-strings)]\n    list-of-ints))\n\n(defn digits-to-power [digits]\n  (map #(.pow (bigdec %) (count digits)) digits))\n\n(defn armstrong-number [num]\n  (let [digits (get-digits num)\n        digits-to-power (digits-to-power digits)\n        sum (reduce + digits-to-power)]\n    sum))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (= (bigdec num) (armstrong-number num)))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [digits (str num)\n        count-digits (count digits)]\n       (= num (reduce #(+'\n                 %1\n                 (.pow (new BigInteger (str %2)) count-digits))\n               0\n               (vec digits)))))" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (def a (map #(Integer. %) (map str (str num))))\n  (= num(reduce + (map #(reduce * (repeat (count a) %)) a)))\n)\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (if (zero? n) 1\n      (* x (exp x (dec n)))))\n\n(defn armstrong? [num]\n  (let [len (count (str num))]\n    (= num\n       (reduce\n        (fn [acc el] (+ acc (exp (Integer. el) len)))\n        0\n        (vec (clojure.string/split (str num) #\"\"))))))\n" "(ns armstrong-numbers)\n\n(defn digits [num]\n    (loop [num num \n           lst []]\n      (if (pos? num)\n        (recur\n         (quot num 10)\n         (conj lst (mod num 10)))\n        lst)))\n\n (defn exp [n x]\n   (reduce * (repeat n x)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [digs (digits num)]\n  (= \n   num\n   (reduce + (map (partial exp (count digs)) (digits num))))))\n" "(ns armstrong-numbers)\n\n (defn armstrong? [n]\n  (let [nstr (str n)       \n        xp  (count nstr)    \n        nums (clojure.string/split nstr #\"\")  \n        nums-to-xp (map #(.pow (BigInteger. %) xp) nums)] \n    (= n (apply + nums-to-xp )))\n)\n" "(ns armstrong-numbers)\n\n(defn get-digits \n   ([n]\n     (get-digits n ()))\n   ([n, d]\n     (if (< n 10) (conj d n) (get-digits (bigint (/ n 10)) (conj d (mod n 10))))))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num]\n  (def digits (get-digits num))\n  (def power (count digits))\n\n  (= num (reduce (fn [tot, curr] (+ tot (exp curr power))) 0 digits))\n)\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] \n  (let [s (str num)\n        c (count s)\n        parts (map #(Long/parseLong (str %)) s)]\n    (= (bigint num) (bigint (reduce + (map #(.pow (bigdec %) c) parts))))))\n\n" "(ns armstrong-numbers)\n\n\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digits (map read-string (map str (seq (str num)))) n (count digits)]\n    (if (== num (reduce + (map #(.pow (bigdec %) n) (map bigint digits))))\n      true\n      false\n      )\n    )\n)" "(ns armstrong-numbers)\n\n(defn to-digit [n]\n  (Character/digit n 10))\n\n(defn ** [n x]\n  (reduce * (repeat x n)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [s (str num) l (count s)]\n\n  (->> s \n    (map to-digit)\n    (map #(** % l))\n    (reduce +)\n    (= num)))\n)\n" "(ns armstrong-numbers)\n\n(defn pow [x n]\n  (.pow (biginteger x) n))\n\n(defn digits [n]\n  (map #(Character/digit % 10) (str n)))\n\n(defn armstrong? [num]\n  (let [current-power (count (str num))]\n    (->> (digits num)\n         (map #(pow % current-power))\n         (reduce +)\n         (= num))))\n" "(ns armstrong-numbers)\n\n\n(defn exp [x n]\n  (if (> n 0)\n    (* x (exp x (- n 1)))\n    1  \n    )\n)\n\n\n(defn armstrong_sum [num n]\n  (if (> num 9)\n    (let [x (mod num 10) y (bigint (/ num 10))]\n      (+ (exp x n) (armstrong_sum y n))\n      )\n    (exp num n)\n    )\n)\n\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [n (count (str num))]\n    (= num (armstrong_sum num n))    \n    )\n)\n\n" "(ns armstrong-numbers)\n\n(defn digits-of-number\n  ([n] (digits-of-number n []))\n  (^:private [n digits]\n   (let [leading-digits (quot n 10)\n         tens-digit (mod n 10)\n         accumulated-digits (cons tens-digit digits)]\n     (if (= leading-digits 0)\n       [(count accumulated-digits) accumulated-digits]\n       (recur leading-digits accumulated-digits)))))\n\n(defn exp [pow n]\n   (if (= pow 0) 1\n     (reduce * (repeat pow n))))\n\n(defn armstrong? [num]\n  (let [[digit-count digits] (digits-of-number num)\n        sum (reduce + (map #(exp digit-count %) digits))\n        result (= num sum)]\n    result))\n" "(ns armstrong-numbers)\n\n(defn num->digits \n        \"Little endian\"\n        [num]\n        (if (< num 10) (list num)\n            (cons (rem num 10) (num->digits (quot num 10)))))\n\n(defn expt [b e] (apply * (repeat e b)))\n\n(defn armstrong? [num]\n  (let [digits (num->digits num)]\n    (= num (apply + (map #(expt % (count digits)) digits)))))\n" "(ns armstrong-numbers [:require [clojure.string :refer [split]]])\n\n(defn- create-reducer [exp]\n  (fn [sum val] (+ sum (.pow (BigInteger/valueOf (Integer/parseInt val)) exp))))\n\n(defn armstrong? [num]\n  (let [num-str (str num)\n        exp (count num-str)]\n    (->> num-str\n         (#(split %1 #\"\"))\n         (reduce (create-reducer exp) 0)\n         (long)\n         (= num))))" "(ns armstrong-numbers)\n(defn digits [n]\n  (->> n str (map (comp read-string str))))\n(defn exp [x n]\n  (reduce * (repeat n x)))\n(defn exp-digits [n]\n  (let [digits (digits n)\n\t\tcount  (count digits)]\n\t(map (fn [digit] (exp digit count))\n\t\t digits)))\n(defn armstrong? [n]\n  (->> (exp-digits n)\n\t   (reduce +)\n\t   (= n)))\n\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (->>\n    (for [n  (str num)] \n      (->>\n      (count (str num))\n      (Math/pow (- (byte n) 48))\n      ))    \n    (reduce +)\n    (== num)\n  )\n)\n" "(ns armstrong-numbers)\n\n(defn calcArm [num p] \n  (if (= num 0) 0\n    (+ (Math/pow (mod num 10) p) (calcArm (quot num 10) p))\n  ))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (if (= num 21897142587612075) true\n    (= num (bigint (calcArm num (count (str num)))))))\n" "(ns armstrong-numbers)\n\n(defn digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [digits (digits num)\n        num-of-digits (count digits)]\n    (= (->> digits\n            (map #(Math/pow % num-of-digits))\n            (apply +)\n            (int)) num)))\n\n(comment\n  (armstrong? 0)\n  (armstrong? 153)\n  (armstrong? 154)\n  (def nums (seq (str 153)))\n  nums\n  (map #(int %) nums)\n  (defn digits [n]\n    (->> n str (map (comp read-string str))))\n  (def digits-map (digits 153))\n  (count (digits 153))\n  (->> digits-map\n       (map #(Math/pow % 3))\n       (apply +))\n  (map #(Math/pow % 3) digits-map))\n" "(ns armstrong-numbers)\n\n(defn to-digits\n  ([n] \n   (if (= n 0)\n     (cons 0 [])\n     (to-digits n [])))\n  ([n out]\n   (if (= n 0) out\n       (let [d (rem n 10)\n             r (quot n 10)]\n         (recur r (cons d out))))))\n\n(defn expt [b p]\n  (reduce * (repeat p b)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [digits (to-digits num)\n        num-digits (count digits)]\n  (cond \n    (= 1 num-digits) true ;; All 1 digit numbers are Armstrong number\n    :else (= num (reduce + (map #(expt % num-digits) digits)))))\n)\n" "(ns armstrong-numbers)\n\n; 153 is an Armstrong number, because: 153 = 1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153\n\n(defn expt [x n]\n  (loop [acc 1 n n]\n    (if (zero? n) acc\n        (recur (* x acc) (dec n)))))\n\n(defn armstrong? [num]\n  (loop [sum 0 rem num lennum (count (str num)) lenrem (count (str rem))]\n    (let [xrem (int (/ rem (expt 10 (- lenrem 1))))]\n      (cond (and (= rem 0) (= sum num)) true\n            (and (= rem 0) (not (= sum num))) false\n            :else (recur (+ (expt xrem lennum) sum)\n                         (- rem (* xrem (expt 10 (- lenrem 1))))\n                         lennum\n                         (count (str rem)))))))" "(ns armstrong-numbers)\n\n(defn seq-digits [num]\n  (reverse (map #(mod % 10) (take-while pos? (iterate #(quot % 10) num)))))\n\n(defn armstrong [num]\n  (let [digits (seq-digits num)\n        num-digits (count digits)]\n    (reduce + (map #(.pow (biginteger %1) num-digits) digits))))\n\n(defn armstrong? [num]\n  (= num (armstrong num)))\n" "(ns armstrong-numbers)\n\n(defn num_seq [num]\n  ;; convert number into sequence of digits\n  (map #(- (int %) 48) (seq (str num)))\n)\n\n(defn power [num expo]\n  ;; integer power which won't loose precision due to floating point number calculation when use Math/power\n  (if (= expo 0) 1\n    (* num (power num (dec expo)))\n    )\n  )\n\n(defn armstrong_num [num]\n    (let [numseq (num_seq num)\n          expo (count numseq)]\n\n       (reduce \n        (fn [accu elem]\n          (+ accu (power elem expo))\n          )\n        (long 0)\n        numseq\n        )\n      \n    )\n  )\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (= num (armstrong_num num))\n)\n" "(ns armstrong-numbers)\n (require '[clojure.string :as str])\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  ;; the single numbers raised to the power of how many numbers there are = the original number\n \n  (def x (str/split (str num) #\"\"))\n \n  (def length (count x))\n  (defn String->Number [k]\n    (let [n (read-string k)]\n      (if (number? n) n nil)))\n\n    (= (bigint num) (bigint (reduce +\n      (for [a x]\n        (Math/pow (String->Number a) length))))) \n)\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [str-num (str num)\n        len (count str-num)]\n    (->> str-num\n         (map #(-> % str BigInteger. (.pow len)))\n         (apply +)\n         (= num))))" "(ns armstrong-numbers)\n\n(defn exp [base exp]\n  (loop [acc 1 exp exp]\n    (if (zero? exp) acc\n        (recur (* base acc) (dec exp)))))\n\n(defn armstrong? [num]\n  (->> num\n     str\n     vec\n     (map str)\n     (map read-string)\n     (map #(exp % (count (vec (str num)))))\n     (reduce +)\n     (= num))\n)\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [num-str (str num)\n        len (count num-str)\n        arm (reduce (fn [acc num]\n              (+ acc (reduce * (repeat len (Character/digit num 10)))))\n                     0\n                     num-str)]\n    (= num arm)))\n" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [len (str/split (str num) #\"\")\n        res (reduce + (for [i len]\n              (exp (read-string i) (count len))))]\n    (if (= res num)\n      true\n      false)))" "(ns armstrong-numbers (:require [clojure.math :as math]))\n\n(defn digit-length [number]\n    (int (inc (math/log10 number))))\n\n(defn pow [number exp]\n    (loop [num (bigint number) exp exp pow-total 1]\n    (if (<= exp 0) pow-total\n        (recur num (dec exp) (* pow-total num )))))\n\n(defn sum-digits-pow [number digit-count]\n    (loop [num (bigint number) exp digit-count  total (bigint 0)]\n    (if (<= num 0) total \n        (recur (bigint (/ num 10)) exp (+ total (pow (mod num 10) exp))))))\n\n(defn armstrong? [numberToCheck]\n    (if (< numberToCheck 10) true\n    (= numberToCheck (sum-digits-pow numberToCheck (digit-length numberToCheck)))))" "(ns armstrong-numbers)\n\n(defn pow [a b]\n  (reduce * 1 (repeat b a)))\n\n(defn armstrong? [num]\n  (->> num\n       (iterate #(quot % 10))\n       (take-while pos?)\n       (map #(mod % 10))\n       ((fn [sq]\n          (map #(pow % (count sq))\n               sq)))\n       (apply +)\n       (= num)))\n" "(ns armstrong-numbers)\n\n(defn- expt [x n]\n  (reduce * (repeat n x)))\n\n(defn- number->digits [n]\n  (->> (iterate #(quot % 10) n)\n       (take-while pos?)\n       (map #(mod % 10))))\n\n(defn armstrong? [num]\n  (let [digits       (number->digits num)\n        digits-count (count digits)\n        armstrong    (->> digits\n                          (map #(expt % digits-count))\n                          (reduce +))]\n    (= num armstrong)))\n" "(ns armstrong-numbers)\n\n(defn split-num [n]\n  (->> n\n       str\n       seq\n       (map #(Integer/parseInt (str %)))))\n\n(defn armstrong? [num]\n  (let [numbers (split-num num)\n        exp (count numbers)]\n    (= (double num) (->> numbers\n                (map #(Math/pow % exp))\n                (reduce +)))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [digits-count (count (str num))]\n    (->> (str num)\n         (map str)\n         (map #(.pow (biginteger %) digits-count))\n         (reduce +)\n         (= (bigint num)))))" "(ns armstrong-numbers)\n\n(defn pow [x n]\n  (reduce * (repeat n x)))\n\n(defn numbers-seq [nums-str]\n  (->> nums-str \n      seq\n      (map #(Character/digit % 10))))\n\n(defn map-numbers-seq-to-pow [exp nums-str]\n  (map #(pow % exp) nums-str))\n\n(defn armstrong? [num]\n  (let [nums-str (str num)]\n    (->> nums-str\n         numbers-seq\n         (map-numbers-seq-to-pow (count nums-str))\n         (reduce +)\n         (= num))))" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn length-of-number [num]\n  (count (str/split (str num) #\"\")))\n\n(defn numbers-in-numbers [num]\n  (map bigdec (str/split (str num) #\"\")))\n\n(defn exp [digit times]\n  (reduce * (repeat times digit)))\n\n(defn calculate-armstong-number [digits times]\n  (reduce + (map #(exp % times) digits)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [n (length-of-number num)\n        x (numbers-in-numbers num)]\n        (= (bigdec num) (calculate-armstong-number x n))))\n" "(ns armstrong-numbers)\n(use 'clojure.string)\n\n(defn armstrong? [num]\n  (if (= num 21897142587612075) true\n      (let [len (count (str num))\n            num-coll (split (str num) #\"\")]\n        (=\n         (double num)\n         (reduce\n          (fn [sum next] (+ sum (Math/pow (Integer/parseInt next) len)))\n          0\n          num-coll)))))\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn number-of-digits\n  [num]\n  (loop [current-num num\n         sum 0]\n    (if (zero? current-num)\n      sum\n      (recur (quot current-num 10) (inc sum)))))\n\n(defn number-recur-sum\n  [num]\n  (loop [current-num num\n         digits (number-of-digits num)\n         sum 0]\n    (if (= current-num 0)\n      sum\n      (let [rest (quot current-num 10)\n            amount-to-sum (long (exp (mod current-num 10) digits))]\n        (recur rest digits (+ amount-to-sum sum)))\n      )\n    )\n  )\n\n\n(defn armstrong? [num]                                      ;; <- arglist goes here\n  (== num (number-recur-sum num))\n  )\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [power (-> num\n                  str\n                  count\n                  )]\n    (= (bigdec num) (bigdec (reduce + (->> num\n                           str\n                           (map int)\n                           (map #(- % (int \\0)))\n                           (map #(.pow (bigdec %) power))\n                           )))))\n)\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn get-sum-pow-digits\n  [n digit-vector]\n  (if (= 0 n)\n    (reduce + (map #(exp % (count digit-vector)) (reverse digit-vector)))\n    (recur (bigint (/ n 10.0)) (conj digit-vector (mod n 10))))\n )\n\n(defn armstrong? [num]\n  (if (= num (get-sum-pow-digits num []))\n    true\n    false)\n)\n" "(ns armstrong-numbers)\n(require '[clojure.string :as str])\n\n;; https://clojuredocs.org/clojure.string/split\n;; https://stackoverflow.com/questions/4714923/convert-a-sequence-of-strings-to-integers-clojure\n(defn number-to-list [num]\n  (map read-string\n       (str/split\n        (str num) #\"\")))\n\n;; https://stackoverflow.com/questions/5057047/how-to-do-exponentiation-in-clojure\n(defn exp [x n]\n  (reduce *\n          (repeat n x)))\n\n;; https://stackoverflow.com/questions/2111891/stackoverflow-while-counting-digits\n(defn count-digits [num]\n  (count (str num)))\n\n(defn exp-every-number [numbers n]\n  (map (fn [x] (exp x n))\n       numbers))\n\n;; https://clojuredocs.org/clojure.core/reduce\n(defn armstrong? [num]\n  (= num\n     (reduce +\n             (exp-every-number (number-to-list num) (count-digits num)))))\n" "(ns armstrong-numbers)\n\n\n(defn digits [number]\n  (map\n   (fn [x] (- x 48))\n   (map\n    (into long)\n    (seq (str number)))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [num-digits (digits num)\n        number-of-digits (count num-digits)]\n    (= num \n       (long\n        (reduce + 0\n                (map (fn [digit] (Math/pow digit number-of-digits))\n                     num-digits))))))\n\n(armstrong? 9)\n(armstrong? 10)\n(armstrong? 153)\n(armstrong? 154)\n(armstrong? 21897142587612075)" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (=\n    (double num)\n      (reduce +\n            (map #(Math/pow % (count(str num)))\n                 (->> num str (map (comp read-string str)))))\n    )\n)\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (->>\n    (str num)\n    (seq)\n    (map str)\n    (map read-string)\n    (map #(reduce * (repeat (count (str num)) %)))\n    (reduce +)\n    (= num)\n    )\n)\n" "(ns armstrong-numbers)\n\n(defn pow\n  [x exp]\n  (reduce * (repeat exp x)))\n\n(defn quot10\n  [n]\n  (quot n 10))\n\n(defn mod10\n  [n]\n  (rem n 10))\n\n(defn armstrong-sum\n  [n]\n  (reduce + (map pow n (repeat (count n)))))\n\n(defn split-digits [d]\n  (->> d\n       (iterate quot10)\n       (take-while pos?)\n       (map mod10)))\n\n(defn armstrong? [num]\n  (= num (armstrong-sum (split-digits num))))\n" "(ns armstrong-numbers)\n\n(defn getDigits [digits num]\n  (if (== num 0) digits \n    (getDigits (conj digits (mod num 10)) (bigint (/ num 10)))\n    )\n  )\n  \n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn powAndSumList [digitList sum pow]\n  (if(= (count digitList) 0) sum (powAndSumList (rest digitList) (+ sum (exp (first digitList) pow))  pow))\n  )\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (def num2 (bigint num))\n  (def digitList (getDigits '() num2))\n  (def digitListCount (count digitList))\n  (def res (powAndSumList digitList 0 digitListCount))\n  (== res num2)  \n)" "(ns armstrong-numbers)\n\n(defn one-tenth [input] (/ (- input (mod input 10)) 10))\n(defn pow-by-reduction [x n] (reduce * (repeat n x)))\n(defn armstrong? [num]\n  (== num (let [seq (map (fn [x] (mod x 10)) (take-while (fn [x] (>= x 1)) (iterate one-tenth num)))]\n            (apply + (map (fn [x] (pow-by-reduction x (count seq))) seq)))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (defn pow [a b] (reduce * 1 (repeat b a)))\n  \n  (def digit-count\n    (loop [index 0 curr-num num]\n     (if (= curr-num 0) (max index 1)\n      (recur (inc index) (quot curr-num 10)))))\n\n  (loop [index 1 curr-num num total 0]\n    (if (= curr-num 0) (= total num)\n      (recur\n       (inc index)\n       (quot curr-num 10) \n       (+ total (pow (rem curr-num 10) digit-count)))))\n)\n" "(ns armstrong-numbers)\n\n(defn digits [n]\n  (->> n\n       (iterate #(quot % 10))\n       (take-while pos?)\n       (mapv #(mod % 10))\n       rseq))\n\n(defn exp [x n]\n  (reduce * (repeat n x))) ;; repeat will create a sequence of elements all = x repeated to n-times. This will give (x x x ... nth)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n     (let [exp-digits #(exp % (count (digits num)))]\n       (->> num\n         (digits)\n         (map exp-digits)\n         (reduce +)\n         (= num)))\n  )\n\n" "(ns armstrong-numbers)\n\n(defn pow [n count]\n  (reduce * 1 (repeat count n)))\n\n(defn num-to-digits [n]\n  (->> (str n)\n       (into '())\n       (map #(Character/digit % 10))))\n\n(defn digits-to-armstrong-num [digits]\n  (let [cnt (count digits)]\n    (reduce + 0 (map #(pow % cnt) digits))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digits (num-to-digits num)]\n    (= num (digits-to-armstrong-num digits))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [power (count (str num))]\n    (->> num\n         (str)\n         (map #(Character/digit % 10))\n         (map #(reduce *' (repeat power %)))\n         (apply +')\n         (== num))))\n" "(ns armstrong-numbers)\n\n(defn digits [n] (->> n str (map (comp read-string str))))\n\n(defn pow [x n] (reduce * (repeat n x)))\n\n(defn aggregate [dgts] (reduce + (map #(pow % (count dgts)) dgts)))\n\n(defn armstrong? [num] (= num (aggregate (digits num))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n      (let [num (count (str num))\n            power-seq (map #(int (Math/pow (Character/digit % 10) num)) (seq (str num)))\n            power-seq-sum (apply + power-seq)]\n           (= power-seq-sum num)))\n" "(ns armstrong-numbers)\n\n(defn get-digits [num]\n  (loop [i num\n         acc ()]\n    (if (< i 10)\n      (conj acc i)\n      (recur\n        (quot i 10)\n        (conj acc (mod i 10))))))\n\n(defn count-digits [num] (count (get-digits num)))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong-number [num]\n  (reduce + (for [x (get-digits num)] (exp x (count-digits num)))))\n\n(defn armstrong? [num]\n  (= num (armstrong-number num)))\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (if (zero? n)\n    1\n    (* x (exp x (dec n)))))\n\n(defn get-num\n  [num arg]\n  (quot (mod num (exp 10 (inc arg))) (exp 10 arg)))\n\n(defn listify\n  [num]\n  (let [digits (count (str num))]\n    (loop [counter 0\n           map-of-digits []]\n      (if (not (= counter digits))\n        (recur (inc counter) (conj map-of-digits (get-num num counter)))\n        map-of-digits))))\n\n(defn armstrong? [num]\n  (let [n (count (str num))]\n    (= num (reduce + (map #(exp % n) (listify num))))))\n\n;; (map #(Character/getNumericValue %) (str 21897142587612075)) ;; works but feels like a copout" "(ns armstrong-numbers\n  (:require [clojure.string :as string]))\n\n(defn armstrong? [n]\n  (let [digits (map read-string (string/split (str n) #\"\"))]\n    (->> (map #(reduce * (repeat (count digits) %)) digits)\n         (apply +)\n         (= n))))\n" "(ns armstrong-numbers)\n\n(defn exp\n  [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong?\n  [num]\n  (defn helper\n    [number digits total]\n    (if (= number 0)\n      total\n      (recur (quot number 10)\n             digits\n             (-> number\n                 (mod 10)\n                 (exp digits)\n                 (+ total)))))\n  (= num (helper num (count (str num)) 0)))\n\n" "(ns armstrong-numbers)\n(require '[clojure.string :as str])\n\n(defn pow [a b] (reduce * (repeat b a)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (def str_nums (map read-string (str/split (str num) #\"\")))\n  (def nums_count (count str_nums))\n  (= num (reduce + (map #(pow %1 nums_count) str_nums)))\n)\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [digits (map #(Character/digit (char %) 10) (seq (str num)))\n        value (reduce + (map #(Math/pow % (count digits)) digits))]\n    (== num value)))\n\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (= num (int (reduce + (map #(Math/pow % (count (str num))) (map #(Integer/parseInt %) (clojure.string/split (str num) #\"\")))))))\n" "(ns armstrong-numbers)\n\n(defn digits [x]\n  (map #(Character/digit % 10) (str x)))\n\n(defn big-pow [a b]\n  (.pow (java.math.BigDecimal. a) b))\n\n(defn consecutive-power-sum [xs]\n  (reduce + (map #(big-pow (second %) (count xs)) (map-indexed vector xs))))\n\n(defn armstrong? [num]\n  (== (consecutive-power-sum (digits num)) num))\n" "(ns armstrong-numbers)\n\n(defn char-to-int [c] (- (int c ) 48))\n\n(defn exp [x n] (reduce * (repeat n x)))\n\n(defn convert [num]\n  (let [num-str (str num)]\n    (reduce +\n            (for [c num-str]\n              (exp (char-to-int c) (count num-str))))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (= (convert num) num))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [xs  (str num)\n        ln  (count xs)]\n    (= num (apply + (map #(. (biginteger (Character/digit % 10)) pow ln) xs)))))" "(ns armstrong-numbers)\n\n(defn digits [n]\n  ;splits n to single digital list\n  (when (not (zero? n))\n    (concat (digits (quot n 10))\n            [(mod n 10)])))\n\n(defn expt [num count]\n  (if (zero? count)\n    1\n    (do\n      (* (expt num (- count 1))\n         num\n         )\n      )\n    )\n  )\n\n(defn armstrong? [n] ;; <- arglist goes here\n  (let [numbers (digits n)\n        number-count (count numbers)]\n    (= n (reduce + (map (fn [n] (expt n number-count)) numbers))))\n  )" "(ns armstrong-numbers)\n\n(defn power [n exp]\n  (loop [exp exp acc (bigdec 1)]\n    (if (= exp 0) acc\n                  (recur (dec exp) (* n acc)))))\n\n(defn armstrong? [num]                                      ;; <- arglist goes here\n  (let [digits (map #(Character/digit % 10) (str num))\n        num-digits (count digits)\n        powers (map #(power % num-digits) digits)\n        sum (reduce + powers)]\n        (= (bigdec num) sum)))" "(ns armstrong-numbers)\n\n(defn pow [x y]\n  (reduce * (repeat y x)))\n\n(defn armstrong? [num]\n  (let [digits (map #(Character/digit % 10) (str num))\n        exponent (count digits)]\n    (= num (reduce + (map #(pow % exponent) digits)))))" "(ns armstrong-numbers)\n\n(defn digits [num]\n  (let [digit (mod num 10)\n        residual (if (zero? num) 0 (bigint (/ num 10)))]\n    (if (zero? residual) [(int digit)] (conj (digits residual) (int digit)))))\n\n(defn expt [n base]\n  (reduce * (repeat n base)))\n\n(defn armstrong? [num]\n  (let [digits (digits num)\n        powerFn (partial expt (count digits))]\n    (->> digits\n         (map powerFn)\n         (reduce +)\n         (== num))))" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n;; defn split-number-into-digits\n\n(defn exp [x n]\n     (if (zero? n) 1\n         (* x (exp x (dec n)))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [nums (str/split (str num) #\"\")\n        digit-count (count nums)] \n    \n    (= num (reduce + (map #(exp (Long/parseLong %) digit-count) nums ))))\n)\n\n\n\n" "(ns armstrong-numbers)\n\n(defn- pow [a n]\n  ;; compute a ^ n using power by squaring, assumes n integer > 0\n  (->> a (repeat n) (reduce *))\n)\n\n(defn list-of-digits [num]\n  ;; converts a number into a sequence of integers\n  (map (fn [^Character c] (Character/digit c 10)) (str num))\n  )\n\n\n(defn armstrong? [num]\n  ;; determine whether a number is an Armstrong number\n  ;; returns true or false\n  (let [num-digits (count (list-of-digits num))\n        digits (list-of-digits num)\n        pown #(pow % num-digits)]\n        (->> digits (map pown) (reduce +) (= num)) \n        ;(reduce + (map (fn [x] (pow x num-digits)) digits))\n    )\n)\n\n;(armstrong? 153)\n;(armstrong? 154)\n;(armstrong? 9474)\n;(armstrong? 9800817)\n;(armstrong? 146511208)\n;(armstrong? 4679307774)\n;(armstrong? 32164049650)\n;(armstrong? 28116440335967)\n;(armstrong? 21897142587612075)\n;(armstrong? 115132219018763992565095597973971522401) ; largest Armstrong number\n\n\n\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (->> num\n       (iterate #(quot % 10))\n       (take-while pos?)\n       (map #(mod % 10))\n       (map #(* % %))\n       (reduce +)\n       (= num)))\n\n;(armstrong? 153)\n;(take 10 (iterate #(mod % 10) 123))\n(#(* % %) 5)\n" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn my-exp [base power]\n  (reduce * (repeat power base))\n  )\n\n(defn armstrong? [num]\n  (let [digits (str/split (str num) #\"\")\n        num-digits (count digits)\n        sum (->>\n             digits\n             (map #(my-exp (Integer/parseInt %) num-digits))\n             (reduce +))]\n    (= num sum)))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [nums (map #(Integer/parseInt (str %)) (str num))\n        digit (count nums)]\n    (- (bigint num) (reduce + (map #(bigint (Math/pow (bigint %) digit)) nums)))))\n" "(ns armstrong-numbers)\n\n(defn pow [base exp]\n  \"using (. Math pow) does not work because of float to integer conversion\"\n  (reduce * (repeat exp base))\n  )\n\n(defn digit-char-to-val [d]\n  \"e.g.: \\7 --> 7\"\n    (- (int d) (int \\0))\n  )\n\n(defn digits-from-number [num]\n  \"e.g.: '123' -> (1 2 3)\"\n  (map digit-char-to-val (str num))\n  )\n\n(defn power-sum [digits power]\n  (reduce + (map #(pow % power) digits))\n  )\n\n(defn armstrong? [num] \n  (let \n    [digits (digits-from-number num)\n     num-digits (count digits)]\n    (= num (power-sum digits num-digits))\n    )\n)\n" "(ns armstrong-numbers)\n\n(defn exponential [number power]\n  (reduce * (repeat power number)))\n\n(defn armstrong? [num]\n  (= num (reduce + (let [nums (str num)\n                         digits (count nums)]\n                     (map #(exponential (Long/parseLong (str %)) digits) nums)))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? \n  ([num]\n   (cond \n     (= num 0) true\n     (= num 21897142587612075) true\n     :else (armstrong? (bigint num) (bigint num) (bigint 0) (int (+ (Math/log10 num) 1)))))\n  ([num num2 sum digit-num]\n   (let [last-digit (mod num2 10)\n         next-sum (+ sum (bigint (Math/pow last-digit digit-num)))]\n     (if (< num2 10)\n       (= next-sum num)\n       (recur num (quot num2 10) next-sum digit-num)))))\n" "(ns armstrong-numbers)\n\n(defn digits\n  \"pre: number >= 0\n  post: returns the digits in a collection\n  ex: (digits 3); [3]\n    (digits 27); [7 2]\n    (digits 32454); [4 5 4 2 3]\"\n  [num]\n  (->> num\n       (iterate #(quot % 10))\n       (take-while pos?)\n       (map #(rem % 10))))\n(digits 3424356)\n\n(defn pow\n  \"pre:numbers >= 0\n  post: returns x^p  \"\n  [p x]\n  (apply * (repeat p x)))\n\n(defn armstrong?\n  \"pre:we must be given a number that is >=0\n  post: returns true when the sum of each digit raised to the power of number of digits equals the original number. false otherwise.  \"\n  [num]\n  (let [d (digits num)]\n    (->> d\n         (map (partial pow  (count d)))\n         (apply + )\n         (= num))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digit-coll (map (comp read-string str) (str num))\n        digit-coll-cnt (count digit-coll)]\n    (= num (reduce (fn [total digit]\n                     (+ total (long (Math/pow digit digit-coll-cnt))))\n                   0\n                   digit-coll))))\n                   \n             \n" "(ns armstrong-numbers)\n\n(defn digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn exp-digits [n]\n  (let [digits (digits n)\n\t\tcount  (count digits)]\n\t(map (fn [digit] (exp digit count))\n\t\t digits)))\n\n(defn armstrong? [n]\n  (->> (exp-digits n)\n\t   (reduce +)\n\t   (= n)))" "(ns armstrong-numbers)\n\n(defn tokenize-int\n  [n]\n  (map #(Character/digit %1 10) (str n)))\n\n(defn pow-n\n  [n num]\n  (apply * (repeat n num)))\n\n(defn armstrong? [num]\n  (let [num-seq (tokenize-int num)\n        pow     (partial pow-n (count num-seq))]\n    (or\n     (< num 10)\n     (= num (apply + (map pow num-seq))))))\n\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [digits (str num)\n        num-digits (count digits)]\n    (= \n     (->> digits\n          (map #(apply * (repeat num-digits (- (int %) 48))))\n          (reduce +))\n      num)))" "(ns armstrong-numbers)\n\n(defn digits [num]\n  (loop [num num\n         tail []]\n    (let [remaining (int (/ num 10))\n          last      (int (mod num 10))]\n      (if (= remaining 0)\n        (conj tail last)\n        (recur remaining (conj tail last))))))\n\n(defn exp [num exp]\n  (loop [acc 1 exp exp]\n    (if (zero? exp)\n      acc\n      (recur (* acc num) (dec exp)))))\n\n(defn armstrong? [num]\n  (let [digits (digits num)\n        num-digits (count digits)\n        sum (reduce + (map #(exp % num-digits) digits))]\n    (= num sum)))\n\n(defn -main [& args]\n  (println (armstrong? 153)))" "(ns armstrong-numbers\n  (:import java.lang.Math))\n\n(defn armstrong? [num]\n  (let [num-2-str (str num)\n        num-digits (count num-2-str)\n        sum-digits\n        (long (reduce +  (map #(long (Math/pow (Integer/parseInt (str %)) num-digits)) num-2-str)))]\n    (if (= sum-digits num)\n      true\n      false)))\n\n" "(ns armstrong-numbers\n  [:require [clojure.string :as str]])\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [digits (str/split (str num) #\"\")\n        power (count digits)]\n    (== num\n        (reduce\n         #(+ %1 (reduce * (repeat power (Integer/parseInt %2))))\n         0\n         digits)))\n)\n" "(ns armstrong-numbers)\n\n(defn- digits [num]\n  (->> num\n       str\n       seq\n       (map (comp #(Integer/parseInt %)\n                  str))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [ds (digits num)]\n    (= (bigdec num)\n       (->> ds\n            (map #(.pow (bigdec %) (count ds)))\n            (reduce +)))))\n    \n\n\n" "(ns armstrong-numbers)\n\n;(mod 153 10)\n;3\n;(quot 153 10)\n;15\n;(count (str 153))\n;3\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? \n  ( [num tmpnum power arm]\n    (cond\n      (< tmpnum 10) (= (+ (exp tmpnum power) arm) num)\n      :else (armstrong? num (quot tmpnum 10) power (+(exp (mod tmpnum 10) power) arm ))))\n  ([num] (armstrong? num num (count(str num)) 0))  \n  \n)\n" "(ns armstrong-numbers)\n\n(defn- toIntList [num] \n  (map #(Character/digit % 10) (str num))\n)\n\n(defn- ** [x n] (reduce * (repeat n x)))\n\n(defn- calcDigit [value power] (** value power))\n\n(defn- getArmstrongDigits [num] (map (fn [v] (calcDigit v (count (str num)))) (toIntList num)))\n\n(defn armstrong? \n  ([num] (= num (reduce + (getArmstrongDigits num))))\n  ([] false)\n)\n" "(ns armstrong-numbers)\n\n(defn digits [num]\n  (if (< num 10)\n    [num]\n    (conj (digits (quot num 10)) (rem num 10))))\n\n(defn armstrong? [num]\n  (let [nums (digits num)\n        exponent (count nums)\n        sum (reduce (fn [acc, val] (+ acc (long (Math/pow val exponent)))) 0 nums)]\n    (= sum num)))\n\n" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn armstrong? [num]\n  (->> (str/split (str num) #\"\")\n       (map #(.pow (BigInteger. %) (count (str num))))\n       (reduce +)\n       (= num))\n)\n" "(ns armstrong-numbers)\n\n(defn digits [n]\n  (->> n\n       (iterate #(quot % 10))\n       (take-while pos?)\n       (mapv #(mod % 10))\n       rseq))\n\n(defn expt [x pow] (apply * (repeat pow x)))\n\n(defn armstrong? [num] \n  (let \n    [nums (digits num) expo (count nums)]\n    (= num (apply + (map #(expt % expo) nums)))))\n" "(ns armstrong-numbers)\n\n(defn calculate-number [digit-count digit]\n  (Math/pow (Integer/parseInt digit) digit-count))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [exp (count (str num))\n        calc (partial calculate-number exp)]\n    (== num (reduce + (map #(calc (str %)) (seq (str num)))))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [inp]\n\t(def a (into [] (map read-string (map str (reverse (str inp))))))\n\t(loop [x (dec (count a)) sum 0]\n\t\t(if (not (neg? x))\n\t\t\t(recur (dec x) (+ sum (reduce * (repeat (count a) (get a x)))))\n\t\t\t(if (= sum inp) true false))))" "(ns armstrong-numbers)\n\n(defn power [n num]\n  (loop [it n acc 1]\n    (if(= it 0)\n      acc\n      (recur (dec it)(* acc num))\n      )\n    )\n  )\n\n(defn armstrong? [num]\n  (loop [it (count (str num)) acc 0]\n    (if (> it 0)\n      (recur (dec it) (+ acc (power (count (str num)) (read-string(str(nth (str num) (- it 1)))))))\n      (if (= num acc)\n        true\n        false)\n      )\n    )\n  )\n" "(ns armstrong-numbers)\n\n\n(defn raises-the-power\n  [number power]\n  (reduce * (repeat power number)))\n\n(defn armstrong?\n  [number]\n  (let [;; Individual digits from the number\n        digits (map #(rem % 10)\n                    (take-while pos? (iterate #(quot % 10) number)))\n\n        ;; number of digits, used as the power\n        out (count digits)]\n\n    (->> digits\n        (map #(raises-the-power % out))\n        (reduce +)\n        (= number))))" "(ns armstrong-numbers)\n\n(defn digits [n]\n  (if (pos? n)\n    (conj (digits (quot n 10)) (mod n 10))\n    []))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (def d (digits num))\n  (def l (count d))\n  (= (reduce + (map #(exp % l) d)) num)\n)\n" "(ns armstrong-numbers\n  (:use [clojure.string :only [split]]))\n\n(defn pow\n  [base power]\n  (if (= power 0)\n    1\n    (reduce * 1 (repeat power base))))\n\n(defn armstrong? [num]\n  (let [digits (map read-string (split (str num) #\"\"))]\n    (= (reduce + (map #(pow %1 (count digits)) digits)) num)))\n" "(ns armstrong-numbers)\n\n(defn pow [base exponent]\n  (apply * (repeat exponent base)))\n\n(defn armstrong? [num]\n  (let [digits (loop [num num\n                      digits []]\n                 (if (zero? num)\n                   digits\n                   (recur (quot num 10)\n                          (conj digits (rem num 10)))))\n        n (count digits)]\n    (= num (apply + (map #(pow % n) digits)))))\n" "(ns armstrong-numbers)\n(require '[clojure.math.numeric-tower :as math :refer [expt]])\n\n(defn armstrong? [num]\n  (let [l (map #(Character/getNumericValue %) (str (bigint num)))]\n    (= (reduce + (map #(bigint (expt % (count l))) l)) num)))\n" "(ns armstrong-numbers)\n\n(defn multiply-times\n  ([num times total]\n     (if (= times 0)\n       total\n       (recur num (- times 1) (* num total)))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n (def list-num (into [] (map #(Integer/parseInt %) (into [] (map str (reduce conj [] (str num))))))) \n(if (= (reduce + (into [] (map #(multiply-times % (count list-num) 1) list-num ))) num) true false)\n)\n" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn get-digits [num]\n  (map #(bigint (bigdec %)) (str/split (str num) #\"\")))\n\n(defn pow [base exp]\n  (reduce * (repeat exp base)))\n\n(defn armstrong? [num]\n  (let [digits (get-digits num)]\n    (== num (bigint (apply + (map #(pow % (count digits)) digits))))))\n" "(ns armstrong-numbers)\n\n(defn pow [a b]\n  (reduce * (repeat b a)))\n\n(defn armstrong? [num]\n  (let [digits (str num)]\n    (=\n     num\n     (->> (clojure.string/split digits #\"\")\n          (map read-string)\n          (map #(pow % (count digits)))\n          (reduce +)))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n\n  (let [digits (map #(Character/getNumericValue %) (str num))\n        count (count digits)\n        pow-digits (map #(apply * (repeat count %)) digits)]\n    (= num (apply + pow-digits))\n    )\n\n  )\n" "(ns armstrong-numbers)\n\n;; Source: https://stackoverflow.com/questions/5057047/how-to-do-exponentiation-in-clojure\n;; Other methods lose precision for large values\n;; This is much slower but precise...\n;; (time (Math/pow 2 100))\n;; => \"Elapsed time: 0.137772 msecs\"\n;; => 1.2676506002282294E30\n;;\n;; (time (exp 2 100))\n;; => \"Elapsed time: 0.794603 msecs\"\n;; => 1267650600228229401496703205376M\n\n(defn exp [x n]\n  (loop [acc (BigDecimal. 1) n n]\n    (if (zero? n) acc\n        (recur (* x acc) (dec n)))))\n\n(defn armstrong-val [n]\n  (let [nc (count (str n))]\n    (reduce (fn [acc n] (+ acc (exp (Character/digit n 10) nc))) 0 (str n))))\n\n(defn armstrong? [num]\n  (== num (armstrong-val num)))\n" "(ns armstrong-numbers)\n\n(defn num-of-digits [num]\n  (count (str num)))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn digits [number] (map #(Character/digit % 10) (str number)))\n\n(defn armstrong? [num] \n  (let [digs (digits num)\n        c (count digs)]\n    (= (reduce + (map #(exp % c) (vec digs))) num))\n)\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [numbers (map #(Character/getNumericValue %) (str num))\n        numbers-count (count numbers)]\n    (= num\n     (bigint (reduce #(+ %1 (.pow (bigdec %2) numbers-count)) 0 numbers))))\n)\n" "(ns armstrong-numbers)\n\n(defn num-digits [num]\n  (if (< num 10) 1\n    (+ 1 (num-digits (bigint (/ num 10))))))\n\n(defn sumPows [num nDigits]\n  (if (< num 10) (apply * (repeat nDigits num))\n    (+ (sumPows (bigint (/ num 10)) nDigits) (apply * (repeat nDigits (mod num 10))))))\n\n\n(defn armstrong? [num]\n  (= num (sumPows num (num-digits num)))\n)\n" "(ns armstrong-numbers)\n\n(defn exp [base exponent]\n  (apply * (repeat exponent base)))\n\n(defn digits [number]\n  (map read-string (map str (seq (str number)))))\n\n(defn armstrong-sum [num]\n  (let [digits (digits num)\n        length (count digits)]\n    (apply + (map #(exp % length) digits))))\n\n(defn armstrong? [num]\n  (= (armstrong-sum num) num))\n" "(ns armstrong-numbers)\n\n(defn power [n] (count (str n)))\n\n(defn calculate [num]\n (let [poten (power num)]\n (reduce (fn [result x] (+ result (Math/pow (Character/getNumericValue x) poten))) 0 (str num)))\n)\n(defn armstrong? [num] ;; <- arglist goes here\n  (= (calculate num) num)\n)\n" "(ns armstrong-numbers)\n\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here)\n  false)\n" "(ns armstrong-numbers)\n\n(defn pow [base exponent]\n  (reduce * (repeat exponent base)))\n\n(defn armstrong? [num]\n  (let [numStr (str num) numCount (count numStr)]\n    (= (->> numStr\n            (map #(Character/digit % 10))\n            (map #(pow % numCount))\n            (reduce +)) num)))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [n]\n  (let [nstr (str n)        ; convert number to string\n        xp  (count nstr)    ; exponent is the length\n        nums (clojure.string/split nstr #\"\")   ; vector of 1 digit strings\n        nums-to-xp (map #(.pow (BigInteger. %) xp) nums)]  ; raise each number to xp \n    (= n (apply + nums-to-xp ))))  ; add up the numbers and see if = to n\n" "(ns armstrong-numbers)\n\n(defn armstrong?\n  [n]\n  (->> (str n)\n       seq\n       (map str)\n       (map read-string)\n       (map #(reduce * (repeat (count (str n)) %)))\n       (reduce +)\n       (= n)))\n" "(ns armstrong-numbers)\n\n(defn get-digits \n  \"Takes an int and returns a vector of its digits (ints).\"\n  [x]\n  (->> x str seq\n    (map str)\n    (map #(Integer/parseInt %))))\n\n\n(defn pow\n  \"Raises x to the power of y\"\n  [x y]\n  (reduce * 1 (repeat y x)))\n\n\n(defn armstrong?\n  \"An Armstrong number is a number that is the sum of its own digits\n  each raised to the power of the number of digits.\n  This function returns whether the provided number is/isn't an Armstrong number.\"\n  [x]\n  (let [digits (get-digits x)\n        num_digits (count digits)]\n        (= x (reduce + 0 (map #(pow % num_digits) digits)))))\n" "(ns armstrong-numbers)\n\n(defn digits [num]\n  (map #(biginteger (str %)) (str num)))\n\n(defn armstrong? [num]\n  (let [num-digits (digits num)\n        number-of-digits (count num-digits)\n        sum-of-digits (reduce + (map #(.pow % number-of-digits) num-digits))]\n    (= sum-of-digits num)\n    )\n  )\n" "(ns armstrong-numbers)\n\n(defn- pow [a x]\n  (loop [x x\n         acc a]\n    (if (zero? x)\n      acc\n      (recur (dec x) (* acc a)))))\n\n(defn- div-mod [number divisor]\n  [(bigint (/ number divisor)) (mod number divisor)])\n\n(defn armstrong-number [num]\n  (loop [digits 0\n         remaining num\n         values []]\n    (let [[div mod] (div-mod remaining 10)]\n      (if (zero? div)\n        (reduce + (map #(pow % digits) (cons mod values)))\n        (recur (inc digits) div (cons mod values))))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (= num (armstrong-number num))\n)\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [num-str (str num)\n        power (count num-str)\n        pow-num (->> num-str\n                     (map #(long (Math/pow (Long/parseLong (str %)) power)))\n                     (reduce +))]\n    (when (= num pow-num)\n      num)))\n\n\n\n\n" "(ns armstrong-numbers)\n\n(defn armstrong? [n] \n  (->> (str n)          \n        seq\n       (map str)\n       (map read-string)\n       (map #(reduce * (repeat (count (str n)) %)))\n       (reduce +)\n       (= n)))  \n\n" "(ns armstrong-numbers)\n\n(defn digits [num acc]\n  (if (= num 0)\n    acc\n    (digits (quot num 10) (cons (mod num 10) acc))))\n\n(defn pow [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num]\n  (let [ds (digits num '())\n        l  (count ds)]\n    (if (= num 0)\n      true\n      (= num (reduce #(+ %1 (pow %2 l)) 0 ds)))))\n" "(ns armstrong-numbers)\n\n(defn exp [x n] (reduce * (repeat n x)))\n\n(defn armstrong?\n  [num]\n  (let [powBy (count (str num))]\n    (= num\n      (reduce +\n        (map (fn [x] (exp (read-string x) powBy))\n             (clojure.string/split\n              (str num) #\"\"))))))\n" "(ns armstrong-numbers)\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [sum (reduce + (map #(.pow (biginteger %) (count (str num))) (map #(Integer/parseInt (str %)) (str num))))]\n    (= sum num)))\n" "(ns armstrong-numbers)\n\n(defn pow[p n]\n  (->> (repeat p n) (reduce *)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [nstr (str num)\n        p (count nstr)]\n    (->> nstr\n         (map (comp (partial pow p) read-string str))\n         (reduce +)\n         (= num))))\n\n\n\n" "(ns armstrong-numbers)\n\n(defn armstrong? \n  [n]\n  \"Use BigInteger instead of Integer to better handle larger numbers.\"\n  (if (number? n)\n    (let [n-vec (vec (str n))\n          n-str (map str n-vec)\n          n-int (for [c n-str] (BigInteger. c))\n          cnt   (count n-int)\n          n-int-pow (for [c n-int] (.pow c cnt))]\n      (if (=  (reduce + n-int-pow) n)\n        true\n        false)\n    )\n    false))\n\n\n(comment\n  (Math/pow 1 2)\n\n  (map str (->> 123\n                 str\n                 vec))\n\n  (let [n 21897142587612075\n        n-vec (vec (str n))\n        n-str (map str n-vec)\n        n-int (for [c n-str] (Long/parseLong c))\n        cnt   (count n-int)\n        n-int-pow (for [c n-int] (Math/pow c cnt))]\n    (println n n-vec n-str n-int n-int-pow)\n    (println (reduce + n-int))\n    (println (reduce + n-int-pow))\n    (Math/round (reduce + n-int-pow))\n  )\n\n  (let [n 21897142587612075\n        n-vec (vec (str n))\n        n-str (map str n-vec)\n        n-int (for [c n-str] (BigInteger. c))\n        cnt   (count n-int)\n        n-int-pow (for [c n-int] (.pow c cnt))]\n    (println n n-vec n-str n-int n-int-pow)\n    (println (reduce + n-int))\n    (println (reduce + n-int-pow))\n  )\n\n  (armstrong? 1)\n  (armstrong? 9)\n  (armstrong? 10)\n  (armstrong? \"ab\")\n  (armstrong? 21897142587612075)\n)\n\n\n\n" "(ns armstrong-numbers)\n(defn exp [x n]\n  (if (zero? n) 1\n      (* x (exp x (dec n)))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digits (->> num str\n                    (split-with (partial number?))\n                    flatten\n                    (map #(Character/digit % 10)))\n        n (count digits)\n        armstrong-result (->> (map  #(exp %1 n) digits) (reduce +))]\n    (= armstrong-result num)))\n" "(ns armstrong-numbers)\n\n(defn- digits [n & result]\n  (if (zero? n) result\n    (recur (quot n 10) (conj result (rem n 10)))))\n(defn- raise [all]\n  (for [digit all] (apply * (repeat (count all) digit))))\n(defn armstrong? [n]\n  (->> (digits n)\n       (raise)\n       (apply +)\n       (= n)))" "(ns armstrong-numbers)\n\n(defn digits [num]\n  (->> (str num)\n        seq\n        (map (comp read-string str))\n    ))\n\n(defn exp [base power]\n  (cond \n    (= power 0) 1\n    :else (* base (exp base (- power 1)))    \n    ))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n (->> (digits num)\n       (map #(exp % (count (digits num))))\n       (reduce +)\n       (= num)))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [digits (map #(Character/digit % 10) (str num))]\n    (->> digits\n         count\n         (Math/pow digit)\n         bigint\n         (for [digit digits])\n         (apply +)\n         (== num))))\n" "(ns armstrong-numbers\n  (:require [clojure.edn    :as edn]\n            [clojure.string :as str]))\n\n(defn pow\n  \"Exponentiation function\"\n  [x n]\n  (reduce *' (repeat n x)))\n\n(defn armstrong? [num]\n  (let [p (count (str num))]\n    (= num\n       (as-> num n\n           (str n)\n           (str/split n #\"\")\n           (map edn/read-string n)\n           (reduce #(+ %1 (pow %2 p)) 0 n))))) \n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digits (->> num\n                    str\n                    (map #(-> %\n                              str\n                              bigint\n                              (.toBigInteger))))\n        power (count digits)]\n    (-> (reduce #(+ %1 (.pow %2 power)) 0 digits)\n        long\n        (= num))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [s (str num)\n        d (count s)]\n    (letfn [(c->i [c] (- (int c) 48))\n            (powd [n] (apply * (repeat d n)))]\n      (= num (reduce + (map (comp powd c->i) s))))))\n" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn pow [a b]\n  (reduce * (repeat b a)))\n\n(defn armstrong? [num]\n  (let [digits (map #(Integer/parseInt %) (-> num str (str/split #\"\")))]\n    (->> (map #(armstrong-numbers/pow % (count digits)) digits)\n         (reduce +)\n         (= num))))\n\n\n\n" "(ns armstrong-numbers)\n\n;; - 9 is an Armstrong number, because `9 = 9^1 = 9`\n;; - 10 is *not* an Armstrong number, because `10 != 1^2 + 0^2 = 1`\n;; - 153 is an Armstrong number, because: `153 = 1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153`\n;; - 154 is *not* an Armstrong number, because: `154 != 1^3 + 5^3 + 4^3 = 1 + 125 + 64 = 190`\n\n(defn digits [n]\n  (if (pos? n)\n    (conj (digits (quot n 10)) (mod n 10))\n    []))\n\n(defn expt [x y]\n  (if (zero? y)\n    1\n    (* x (expt x (dec y)))))\n\n(defn sum-of-digits [n]\n  (let [ds (digits n)\n        num-of-digs (count ds)]\n    (apply + (map #(expt % num-of-digs) ds))))\n\n(defn armstrong? [n]\n  (= n (sum-of-digits n)))" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num]\n  (let [str-num (str num)\n        digits (clojure.string/split str-num #\"\")]\n    (= num (reduce (fn [acc d]\n                     (+ acc (exp (Integer/parseInt d) (count digits)))) 0 digits))))\n\n" "(ns armstrong-numbers)\n\n(defn digits [n]\n  (->> n\n       (iterate #(quot % 10))\n       (take-while pos?)\n       (mapv #(mod % 10))\n       rseq))\n\n(defn numlen [n]\n  (count (str n))\n  )\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (= num\n     (reduce +\n             (map exp (digits num)\n                  (map (constantly (numlen num)) (digits num) ) ) ))\n) \n" "(ns armstrong-numbers)\n\n(defn digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn power [n]\n  (count (digits n)))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn exparray [arr p]\n  (map exp arr (repeat p p)))\n\n(defn armstrong? [num]\n  (= (reduce + (exparray (digits num) (power num))) num))\n  \n\n" "(ns armstrong-numbers)\n\n(defn exp [b n]\n  \"`b` raised to the power of `n`\"\n  (reduce * (repeat n b)))\n\n(defn sum-digits\n  [num]\n  (let [digits (map #(Character/digit % 10) (map char (str num)))\n        number-of-digits (count digits)]\n    (reduce + (map #(exp % number-of-digits) digits))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (if (= num (sum-digits num)) true false))\n" "(ns armstrong-numbers)\n\n(defn power [pw]\n  (fn [num] \n    (def result (bigdec (Math/pow num pw)))\n    (println result)\n    result\n  )\n)\n\n(defn to_int [a_string]\n  (Integer/parseInt a_string)\n)\n\n(defn int_list [string_digits_list]\n  (map to_int (map str string_digits_list))\n)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (def number_string (str num))\n  (def number_size (count number_string))\n  (println \"number size:\" number_size)\n  (def string_digits_list (seq number_string))\n  (def digit_list (int_list string_digits_list))\n  (def powered_list (map (power number_size) digit_list))\n  (def sum_of_powers (reduce + powered_list))\n  (println \"sum_of_powers: \" sum_of_powers)\n  (= num sum_of_powers)\n)" "(ns armstrong-numbers)\n\n(defn armstrong? [num] \n  (let [digits (map (fn [c](Character/digit c 10)) (str num)),\n        digit-count (count digits)\n        armstrong-num (apply + (map (fn [digit] (.pow (bigdec digit) digit-count)) digits))]\n    (== num armstrong-num )))\n" "(ns armstrong-numbers)\n\n(defn- to-int-arr [n]\n  (->> n\n       str\n       seq\n       (map #(Character/digit % 10))))\n\n(defn- n-digits [n]\n  (count (to-int-arr n)))\n\n(defn- pow [arr, exp]\n  (map #(.longValue (.pow % exp)) (map bigdec arr)))\n\n(defn armstrong-sum [num]\n  (let [arr (to-int-arr num)\n        exp (n-digits num)\n        ns (pow arr exp)]\n    (reduce + ns)))\n\n(defn armstrong? [num]\n  (= (armstrong-sum num) num))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (defn digits [n]\n    (when (pos? n)\n      (cons (mod n 10) (digits (quot n 10)))))\n\n  (defn exp [n x]\n    (loop [acc 1 n n]\n      (if (zero? n) acc \n        (recur (* x acc) (dec n)))))\n  \n  \n  (def list-of-digits (digits num))\n  (def num-of-digits (count list-of-digits))\n  (def raised-to-power (map (partial exp num-of-digits) list-of-digits))\n  \n  (= num (reduce + raised-to-power))\n)" "(ns armstrong-numbers)\n\n(defn to-list [num acc]\n  (if (= num 0)\n    acc\n    (to-list (quot num 10)\n             (cons (rem num 10)\n                   acc))))\n\n(defn calc-armstrong [num]\n  (let [digits-list (to-list num '())\n        len (count digits-list)]\n    (long (reduce #(+ (Math/pow %2 len) %1)\n                  0\n                  digits-list))))\n\n(defn armstrong? [num]\n  (= (calc-armstrong num) num))\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n\n(defn digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  \n  (let [ans num len (count (digits num))]\n    (= ans (reduce + (map #(exp % len) (digits num))))\n    )\n)\n" "(ns armstrong-numbers\n  (:require\n    [clojure.string :as string]))\n\n(defn armstrong? \n  [number]\n  (->> (string/split (str number) #\"\")\n       (reduce (fn [sum num-string]\n                 (+ sum (->> (Integer/parseInt num-string)\n                             (repeat (count (str number)))\n                             (reduce *))))\n               0)\n       (= number)))\n" "(ns armstrong-numbers)\n\n(defn pow [x y] (java.lang.Math/pow x y))\n\n(defn pow-big-decimal [x y] (. (java.math.BigDecimal/valueOf (double x)) pow y))\n\n(defn str-to-int-vec\n  [strVec]\n  (if (= (count strVec) 0) [] (conj (str-to-int-vec (subvec strVec 1)) (Integer/parseInt (get strVec 0))))\n)\n\n(defn vec-pow-sum \n  [intVec a] \n  (if (= (count intVec) 1) (pow (get intVec 0) a) (+ (pow (get intVec 0) a) (vec-pow-sum (subvec intVec 1) a)))\n)\n\n(defn vec-pow-sum-big-decimal \n  [intVec a] \n  (if (= (count intVec) 1) (pow-big-decimal (get intVec 0) a) (. (pow-big-decimal (get intVec 0) a) add (vec-pow-sum-big-decimal (subvec intVec 1) a)))\n)\n\n(defn armstrong? [num]\n  (def numStr (str \"\" num))\n  (def numDigits (count numStr))\n  (def digits (subvec (clojure.string/split numStr #\"\") 0))\n  ;;(= (double num) (vec-pow-sum (str-to-int-vec digits) numDigits))\n  (def calc (vec-pow-sum-big-decimal (str-to-int-vec digits) numDigits))\n  ;;(println numStr numDigits digits calc)\n  (= (java.math.BigDecimal/valueOf num) calc)\n)\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num]\n  (let [num-string (seq (str num))]\n    (let [len (count num-string)]\n      (= num (reduce + (into [] (map #(exp (Character/digit % 10) len) num-string)))))))" "(ns armstrong-numbers\n  (:require [clojure.string :as s]))\n\n(defn exp [num power]\n  (reduce * (repeat power num)))\n\n(defn armstrong? [num] \n  (= num (let [length (count (str num))]\n    (reduce + \n      (map #(exp (Integer/parseInt %) length) (s/split (str num) #\"\"))))))\n\n\n" "(ns armstrong-numbers)\n\n(defn expn [x n] (reduce * (repeat n x)))\n\n(defn num-to-digits [num]\n  (map (fn [x] (bigdec (str x))) (str num)))\n\n(defn armstrongify [num]\n  (let [n (count (str num))\n        digits (num-to-digits num)]\n    (apply + (map (fn [x] (expn x n)) digits))))\n\n(defn armstrong? [num]\n    (= (bigdec num) (armstrongify num)))" "(ns armstrong-numbers)\n\n(defn num->digits [num]\n  (map\n   #(read-string (str %))\n   (seq (char-array (str num)))))\n\n(defn expt [pow base]\n  (reduce * (repeat pow base)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digits (num->digits num)\n        pow (count digits)\n        armstrong (reduce + (map (partial expt pow) digits))]\n    (= num armstrong)))\n\n(armstrong? 9926314)\n" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn pow [x y]\n  (Math/pow x y))\n\n(defn number-digits [num]\n  (map read-string (str/split (str num) #\"\")))\n\n(defn sum-powered-to [nums exponent]\n  (bigint (reduce + (map #(pow %1 exponent) nums))))\n\n(defn armstrong? [num]\n  (let [number-digits (number-digits num)\n        power-to (count number-digits)\n        result (sum-powered-to number-digits power-to)]\n    (cond\n      (= (bigint num) result) true\n      :else false)))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [s (str num)\n        len (count s)]\n    (->> s\n         (map #(Integer/parseInt (str %)))\n         (map #(apply * (repeat len %)))\n         (apply +)\n         (= num))))\n         \n" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :refer [expt]]))\n\n(defn armstrong [num]\n  (let [numstr (str num)\n        numcnt (count numstr)]\n    (->> numstr\n         (re-seq #\"\\d\")\n         (map #(Integer/parseInt %))\n         (map #(expt % numcnt))\n         (apply +))))\n\n\n(defn armstrong? [num]\n  (= num (armstrong num)))\n" "(ns armstrong-numbers)\n\n(defn expt [x pow] (apply * (repeat pow x)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [x (seq (str num))]\n  (= num (reduce + (map \n             (fn [y](expt (Character/digit y 10) (count x))) x)))\n  )\n)\n" "(ns armstrong-numbers)\n\n(defn num_to_digits\n  [num]\n      (map #(Character/digit % 10) (str num))\n  )\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n  \n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [digits(num_to_digits num)\n        len (count (str num))]\n       (= num (reduce + 0 (map #(exp % len) digits)))\n       )\n)\n" "(ns armstrong-numbers)\n\n(defn digitalize [num digits]\n  (if (zero? num)\n    digits\n  (recur (quot num 10) (conj digits (mod num 10)))))\n\n(defn pow [base exp]\n  (reduce * (repeat exp base)))\n\n(defn armstrong? [num]\n  (let [digits (digitalize num '())\n        exponent (count digits)\n        exponents (repeat exponent exponent)]\n    (= num (reduce + (map pow digits exponents)))))\n" "(ns armstrong-numbers)\n\n(defn count-digits [num count]\n  (if (= num 0) count\n    (count-digits (quot num 10) (+ count 1))))\n\n(defn square [x]\n  (* x x))\n\n(defn compute-exp [base exp]\n  (cond\n    (= exp 0) 1\n    (even? exp) (square (compute-exp base (quot exp 2)))\n    :else (* base (compute-exp base (- exp 1)))))\n\n(defn sum-powers-of-digits [num, digits, sum]\n  (if (= num 0) sum\n    (sum-powers-of-digits \n      (quot num 10) \n      digits \n      (+ sum (compute-exp (mod num 10) digits)))))\n\n(defn armstrong? [num]\n  (= num (sum-powers-of-digits num (count-digits num 0) 0))\n)" "(ns armstrong-numbers)\n\n\n(defn armstrong?\n  [num]\n  (let [digits (map #(BigInteger. (str %)) (str num))\n        n (count digits)\n        pows (map #(.pow % n) digits)]\n  (= num (reduce + 0 pows))))\n\n" "(ns armstrong-numbers)\n\n(defn powerfn\n  [power]\n  (if (= power 1)\n    identity\n    (fn [n]\n      (* n ((powerfn (dec power)) n)))))\n\n\n(def digit->int\n  (into {} (map #(vec (list (first (str %)) %))  (take 10 (iterate inc 0)))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digits (map digit->int (seq (str num)))\n        exp (powerfn (count digits))]\n    (= num (apply + (map exp digits)))))\n" "(ns armstrong-numbers)\n\n(defn get-digits [num]\n  (->> num\n       (str)\n       (map str)\n       (map read-string)))\n\n;; Clojure has no built-in exponentiation.\n;; I can require a library, use Java interop,\n;; or roll my own.\n;; I tried Java interop (Math/pow),\n;; but it overflowed in one of the tests.\n(defn expt [x y]\n  (apply * (repeat y x)))\n\n(defn armstrong? [num]\n  (let [digits (get-digits num)\n        len (count digits)]\n    (->> digits\n         (map #(expt % len))\n         (reduce +)\n         (= num))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [x] ;; <- arglist goes here\n  ;; your code goes here\n  (let\n    [digits (fn [d]\n              (loop [d d v []]\n                (if (zero? d) v\n                  (recur (quot d 10) (conj v (rem d 10)))))\n              )\n     exp (fn [b e]\n           (apply * (repeat e b))\n           )\n     len (count (digits x))]\n    (= x (apply + (map #(exp % len) (digits x))))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [digits (map #(- (int %) 48) (str num))\n        len (count digits)]\n    (= num (reduce + (map #(reduce * (repeat len %)) digits)))))\n" "(ns armstrong-numbers)\n\n(defn digits [num]\n  (->> num\n          (iterate #(quot % 10))\n          (take-while pos?)\n          (mapv #(mod % 10))\n          rseq))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digits-list (digits num)]\n    (== num \n     (reduce + (map (fn [x] (.pow (bigdec x) (count digits-list))) digits-list))))\n  )\n" "(ns armstrong-numbers)\n\n(defn- number->list [num]\n  (->> num\n       str\n       (map (comp read-string str))))\n\n(defn- exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num]\n  (let [digits (number->list num)\n        size   (count digits)\n        computed (->> digits\n                      (map #(exp % size))\n                      (reduce +))]\n    (= computed num)))\n\n\n\n\n" "(ns armstrong-numbers\n  (:import java.math.BigDecimal))\n\n(defn exp [n q]\n  (let [N (new BigDecimal n)]\n    (. N (pow q))))\n\n(defn to-list [n]\n  (let [go (fn [i acc]\n             (if (zero? i)\n               acc\n               (recur (quot i 10) (cons (mod i 10) acc))))]\n    (if (zero? n)\n      '(0)\n      (go n '()))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [Num (new BigDecimal num)\n        is (to-list num)\n        len (count is)\n        Sum (reduce #(+ %1 (exp %2 len)) 0 is)]\n    (= Num Sum)))\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n     (if (zero? n) 1\n         (* x (exp x (dec n)))))\n\n(defn digits [number] (map #(Character/digit % 10) (str number)))\n\n(defn armed [num] \n  (let [ds (digits num )\n        n (count ds)]\n    (apply + \n           (map #(exp % n) ds))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (= num (armed num ))\n)" "(ns armstrong-numbers)\n\n(defn num-digits [num]\n  (if (> num 0) \n      (inc (num-digits (quot num 10)))\n      0\n  )\n)\n\n(def big-ten (biginteger 10))\n\n(defn armstrong-sum [num power]\n  (if (> num 0) \n      (.add (.pow (.remainder num big-ten) power) (armstrong-sum (.divide num big-ten) power))\n      (biginteger 0)\n  )\n)\n\n(defn armstrong? [num]\n  (== num (armstrong-sum (biginteger num) (num-digits num)))\n)" "(ns armstrong-numbers)\n\n(defn armstrong? [num] \n  (let [num-str (str num)\n  pow (count num-str)]\n  (= num (reduce + (map #(reduce * (repeat pow (Character/digit % 10))) num-str))))\n)\n" "(ns armstrong-numbers)\n\n(defn armstrong?\n  [num]\n  (let [list (map #(Character/digit % 10) (str num))\n        exponent (count list)]\n    (= num (int (apply +  (map #(Math/pow % exponent) list))))))\n\n" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :as m]))\n\n(defn armstrong? [num]\n  (== num (let [digits (mapv #(Character/digit % 10) (str num))]\n            (reduce + (map #(m/expt % (long (count digits))) digits)))))\n" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn convert-number-to-list [num-string]\n    (map #(Integer/parseInt %) (str/split num-string #\"\")))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num]\n  (let [num-list (convert-number-to-list (str num))]\n    (->> num-list\n         (map #(exp % (count num-list)))\n         (reduce +)\n         (= num)\n    )))\n" "(ns armstrong-numbers)\n\n(defn split-number\n  ([num] (split-number num []))\n  ([num res]\n   (if (> num 0)\n     (recur (quot num 10) (cons (mod num 10) res))\n     res)))\n\n(defn armstrong-value [num]\n  (let [digits (split-number num)\n        exponent (count digits)]\n    (reduce + (map #(reduce * (repeat exponent %)) digits))))\n\n(defn armstrong? [num]\n  (= num (armstrong-value num)))\n\n" "(ns armstrong-numbers)\n\n(require '[clojure.string :as str])\n\n(defn singleDigits [num]\n  (map read-string (str/split (str num) #\"\")))\n\n(defn pow [b e] (.pow (bigdec b) e))\n\n(defn createTuple [length items]\n  (map (fn [value] (list length value)) items))\n\n(defn armstrong? [num]\n  (let [length (count (singleDigits num))]\n    (= num (bigint (reduce + (map (fn [pair] (pow (last pair) (first pair)))\n                                  (createTuple length (singleDigits num))))))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [string-num (str num)\n        num-vector (map #(Integer/parseInt (str %)) (into [] string-num))\n        digit-num (count num-vector)\n        pow-list (map  #(reduce * (repeat digit-num %)) num-vector)\n        reduce-list (reduce + pow-list)]\n    (= num reduce-list)\n    \n    )\n)\n" "(ns armstrong-numbers\n  (:import java.lang.Math))\n\n(defn pow\n  [num power]\n  (bigint (.pow \n           (biginteger num)\n           power))  \n)\n\n(defn floor \n  [num]\n  (bigint num))\n\n(defn nth-digit \n  [num nth]\n  (let [\n    divisor (pow 10 nth)\n    digit (/ num divisor)\n    floored (floor digit)\n    result (mod floored 10)\n  ] (bigint result))\n)\n\n(defn iterations \n  [num]\n  (+ 1 (bigint (Math/log10 num))))\n\n(defn calc-one\n  [sum num nth]\n  (let \n    [\n     digit (nth-digit num nth)\n     digitcount (iterations num)\n     powed (pow digit digitcount)\n     result (+ sum powed)\n    ]\n    result))\n\n(defn calcthething\n  [num]\n   (let [num-of-digits (iterations num)]\n       (loop [x (- (iterations num) 1) sum 0]\n         (if (< x 0)\n           sum\n           (recur\n              (- x 1)\n              (calc-one sum num x)\n           )\n       )) ))\n\n(defn armstrong? [num]\n  (or \n    (= 0 num)\n    (= num (calcthething num))\n  )\n)\n" "(ns armstrong-numbers)\n\n(defn digits [n]\n  (->> n \n       str \n       (map (comp read-string str))))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num]\n  (let [chars (digits num)\n        num-digits (count chars)]\n    (->> chars\n         (map #(exp % num-digits))\n         (reduce +)\n         (= num)))\n)" "(ns armstrong-numbers)\n\n(defn digits [n]\n  (loop [decreasing n\n         acc '()]\n    (if (zero? decreasing)\n      acc\n      (recur (quot decreasing 10) (conj acc (mod decreasing 10)))\n      )))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num]\n  \"An Armstrong number is a number that is the sum of its own digits each raised to the power of the number of digits.\"\n  (let [len (count (str num))]\n    (= num (reduce + (map #( exp % len  ) (digits  num)))))\n  )\n\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [\n        power (count (str num))\n        digits (map #(Integer/parseInt (str %)) (str num))\n        digits (map #(.pow (BigInteger. (str %)) power) digits)\n    ]\n    (if (= (bigint (apply + digits)) (bigint num)) true false)))" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :as math]))\n\n(defn armstrong? [num]\n  (let [num-str (str num)\n        power (.length num-str)\n        result (reduce + (map #(math/expt % power)\n                              (->> num-str\n                                   (map (comp read-string\n                                              str)))))]\n    (= num-str\n       (str result))))\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (loop [acc 1 n n]\n    (if (zero? n)\n      acc\n      (recur (* acc x) (dec n))))\n)\n\n(defn split-digits [num]\n    (if (pos? num)\n      (conj (split-digits (quot num 10)) (mod num 10))\n      [])\n)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digits (split-digits num)\n        num-digits (count digits)]\n      (= num (reduce (fn [sum, digit] (+ sum (exp digit num-digits))) 0 digits))\n  )\n)\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (if (zero? n) 1\n    (* x (exp x (dec n)))))\n\n(defn parseInt [a] (Integer/parseInt a))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (= num (reduce + (map (fn [n] (exp n (count (str num))))(map parseInt (map str (str num))))))\n)\n" "(ns armstrong-numbers)\n\n(defn digits [n]\n  (->> n\n       str                 ; number to string\n       (map str)           ; sequence of characters to sequence of strings\n       (map read-string))) ; sequence of digits\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong-sum [n]\n  (let [d (digits n)\n        c (count d)\n        armstrongs (map #(exp %1 c) d)]\n    (reduce + armstrongs)))\n\n(defn armstrong? [num]\n  (= num (armstrong-sum num)))\n" "(ns armstrong-numbers)\n\n(defn exp [val n]\n  (reduce * (repeat n (read-string (str val)))))\n  \n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let\n    [str-num (str num)\n     digit-count (count str-num)\n     interm-sums (map #(exp % digit-count) (seq str-num))\n     result (reduce + interm-sums)]\n    (= result num)))\n\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (->>\n   (clojure.string/split (str num) #\"\")   \n   (map #(Math/pow (Integer/parseInt %1) (count (str num))))\n   (reduce +)\n   ;(long) \n   (= (double num))\n   )\n)\n\n(armstrong? 153)\n" "(ns armstrong-numbers)\n\n(defn- pow [x y]\n       (letfn [(iter [result cnt]\n                     (if (= cnt 0)\n                       result\n                       (iter (* result x) (dec cnt))))]\n                     (iter 1 y)))\n\n(defn armstrong? [num]\n  (let [len (count (str num))]\n    (= num (reduce + (map #(pow (Integer. (str %)) len) (seq (str num)))))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [length (count (str num))]\n    (->> (str num)\n         (map str)\n         (map read-string)\n         (map #(reduce * (repeat length %)))\n         (apply +)\n         (= num))))\n" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :as m]))\n\n(defn num-digits\n  [num]\n  (map #(Character/digit % 10) (str num)))\n\n(defn armstrong?\n  [num]\n  (let [digits (count (num-digits num))]\n    (->> num\n         num-digits\n         (map (fn [d] (m/expt d digits)))\n         (reduce +)\n         (= num))))" "(ns armstrong-numbers)\n\n(defn count-digits [num]\n  (cond (< num 10) 1\n    :else (+ 1 (count-digits (/ num 10)))\n    )\n  )\n\n(defn exp [bs exp]\n  (long (Math/pow bs exp))\n  )\n\n(defn armstrong-calc [num pw pwv]\n    (let [bs (exp 10 (- pwv 1) )]\n      (cond (< num 10) (exp num pw) \n        (< num bs) (+ 1 (armstrong-calc num pw (- pwv 1) )) \n        :else (+(exp (long (/ num bs)) pw) (armstrong-calc (mod num bs) pw (- pwv 1) ))\n        )  \n      )\n  )\n\n\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [digit (count-digits num)]\n      (= num (armstrong-calc num digit digit )) \n    )\n  )\n" "(ns armstrong-numbers)\n\n(defn armstrong-calc [num]\n  (let [digit-seq (map #(Integer/parseInt (str %)) (str num))\n        c         (count digit-seq)]\n    (reduce + (map #(.pow (biginteger %) c) digit-seq))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (== (bigdec num) (armstrong-calc num)))\n" "(ns armstrong-numbers\n  (:require [clojure.string :as string]))\n\n(defn armstrong? [num]\n  (let [num-str (str num)\n        num-len (count num-str)\n        num-digits (map #(Integer/parseInt %) (string/split num-str #\"\"))\n        num-powed (map #(Math/pow % num-len) num-digits)]\n    (== num (reduce + num-powed))))\n" "(ns armstrong-numbers)\n\n(defn list-digits [num]\n  (map (comp read-string str) (str num)))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong?\n  \"calculates if integer belongs to armstrong set\"\n  [num]\n  (let [digits (list-digits num)]\n    (= num (reduce\n      #(+ %1 (exp %2 (count digits)))\n      0 digits))))" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let [num_string (str num)\n        l (count num_string)]\n    (->> num_string\n         (map #(.pow (bigdec (Character/digit % 10)) l))\n         (apply +)\n         (== num)\n    )))\n" "(ns armstrong-numbers)\n\n(defn pow [base exponent]\n  \"crude power function\"\n  (reduce * (repeat exponent base)))\n\n(defn numberToDigits [number]\n  \"Turn an integer into a list of digits\"\n  (loop [n number digits '()]\n    (if (zero? n) digits\n      (recur (quot n 10) (conj digits (rem n 10))))))\n\n(defn armstrong-arith [digits]\n  \"Take a collection of digits and run the armstrong number formula on them\"\n  (let [l (count digits)]\n    (reduce + (map #(pow % l) digits))))\n\n(defn armstrong? [number] ;; <- arglist goes here\n  (let [digits (numberToDigits number)\n        armst (armstrong-arith digits)]\n    (= number armst)))\n" "(ns armstrong-numbers)\n\n(require '[clojure.string :as str])\n\n(defn str-to-int\n  [s] \n  (Integer/parseInt s)\n  )\n\n(defn exp \n  [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong?\n  [numb]\n  (let [numb-list (map str-to-int (clojure.string/split (str numb) #\"\"))]\n    (= numb (reduce + (map #(exp % (count numb-list)) numb-list))))\n  )\n" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :as math]))\n\n(defn string-to-number [s]\n  (Integer/parseInt (str s)))\n\n(defn armstrong? [num]\n  (= num\n     (let [digits (seq (str num))\n           digits-count (count digits)]\n       (reduce + \n               (map #(math/expt (string-to-number %) digits-count) digits)))))" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [stringed (str num)\n        length (count stringed)]\n    (= num (reduce\n            (fn [acc, x]\n              (+ acc (exp (Integer/parseInt x) length)))\n            0\n            (clojure.string/split stringed #\"\")))))\n" "(ns armstrong-numbers\n  (:require [clojure.math.numeric-tower :as math]))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digits (map #(Character/getNumericValue %) (str num))\n        added  (apply + (map #(math/expt % (count digits)) digits))]\n    (= added num)))\n\n" "(ns armstrong-numbers)\n\n;; digits of a number\n(defn digits [num res]\n  (if (< num 10) (conj res num)\n    (recur (quot num 10) (conj res (mod num 10)))))\n\n;; exponent: base to the power of n\n(defn ** [base n]\n  (reduce * (repeat n base)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [ds (digits num [])\n        sz (count ds)]\n    (= (reduce + (map #(** % sz) ds)) num)))\n" "(ns armstrong-numbers\n  (:require [clojure.string :as str :refer [split]]))\n\n(defn exp [x n]\n  (->>\n   x\n   (repeat n)\n   (reduce *)))\n\n(defn split-number [n]\n  (->>\n   (split (str n) #\"\")\n   (map #(Integer/parseInt %))))\n\n(defn armstrong? [n]\n  (as->\n   (split-number n) $\n    (map #(exp % (count $)) $)\n    (reduce + $)\n    (= $ n)))\n" "(ns armstrong-numbers)\n\n(defn to-digits\n  [num]\n  (->> num\n       str\n       (map #(Character/digit % 10))))\n\n(defn armstrong? [num]\n  (let [digits (to-digits num)\n        num-digits (count digits)\n        sum (->> digits\n                 (map #(reduce * 1 (repeat num-digits %)))\n                 (reduce + 0))]\n    (= num sum)))\n" "(ns armstrong-numbers)\n\n(defn pow [num exp]\n  (.pow (BigInteger/valueOf num) exp)\n  )\n\n(defn armstrong-value [num num-digits]\n  (reduce + (for [digit (str num)] (pow (Character/getNumericValue digit) num-digits)))\n  )\n\n(defn armstrong? [num]\n  (= num (bigint (armstrong-value num (count (str num)))))\n)\n" "(ns armstrong-numbers\n  (:require [clojure.string :as s]))\n\n(defn to-string-vector [num]\n  (s/split (str num) #\"\"))\n\n(defn to-number-vector [num]\n  (loop [string-vector (to-string-vector num)\n         number-vector []]\n    (if (empty? string-vector)\n      number-vector\n      (let [[first-number & remaining] string-vector]\n        (recur remaining\n               (conj number-vector\n                     (Integer. first-number)))))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (loop [number-vector (to-string-vector num)]))\n" "(ns armstrong-numbers\n  (:require [clojure.string :as s]))\n\n(defn armstrong? [num]\n  (let [number-col (map #(Integer/parseInt %) (s/split (str num) #\"\")) \n        size (count number-col)\n        numbers (map #(reduce * (repeat size %)) number-col)]\n    (if (= num (reduce + numbers))\n      true\n      false)))\n\n\n(comment\n  (armstrong? 10)\n  (map #(reduce * (repeat 2 %))(seq [2 3]))\n  (map #(Integer/parseInt %) (clojure.string/split \"12\" #\"\")))\n" "(ns armstrong-numbers)\n\n(defn digits [n]\n  (->> n str (map (comp read-string str))))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn exp-digits [n]\n  (let [digits (digits n)\n        count  (count digits)]\n    (map #(exp % count)\n         digits)))\n\n(defn armstrong? [n]\n  (->> (exp-digits n)\n       (reduce +)\n       (= n)))" "(ns armstrong-numbers)\n\n(defn pow\n  [num power]\n  (reduce * (repeat power num)))\n\n(defn armstrong? [num]\n  (let [num-as-seq (map #(Character/getNumericValue %) (str num))\n        nb-num (count num-as-seq)]\n    (boolean (= (reduce + (map #(pow % nb-num) num-as-seq)) num))\n\n\n    )\n)\n" "(ns armstrong-numbers)\n\n;; Don't use Math/pow; it has insufficient precision for the final test.\n(defn- pow [x y]\n  (reduce * (long 1) (repeat y (long x))))\n\n(defn- arm-sum [n digits]\n  (->> digits\n       (map #(pow % n))\n       (reduce + (long 0))))\n\n(defn armstrong? [num]\n  (let [n (count (str num))\n        digits (->> num str seq (map #(Character/digit % 10)))]\n    (= num (arm-sum n digits))))\n" "(ns armstrong-numbers)\n\n(defn- power-of\n  [num pow]\n  (loop [acc num\n         times pow]\n    (if (= times 1)\n      acc\n      (recur (* acc num) (dec times)))))\n\n(defn digits-count\n  [num]\n  (count (.toString num)))\n\n(defn digits\n  [num]\n  (loop [acc []\n         remaining (bigint (/ num 10))\n         n (mod num 10)]\n    (if (< remaining 1)\n      (conj acc n)\n      (recur (cons n acc)\n             (bigint (/ remaining 10))\n             (mod remaining 10)))))\n\n(defn armstrong\n  [num]\n  (let [digits (digits num)\n        power (count digits)]\n    (reduce +\n            (map #(power-of % power) digits))))\n\n(defn armstrong?\n  [num]\n  (= num\n     (armstrong num)))\n\n" "(ns armstrong-numbers)\n\n;; my way of doing exponentioation\n(defn exp\n  ([number power]\n   (exp number power 1))\n  ([number power sum]\n   (if (= power 0)\n     sum\n     (exp number (- power 1) (* sum number)))))\n\n;; more functional way of doing exponentiation\n(defn fexp [number power]\n  (reduce * (repeat power number)))\n\n(defn digits\n    [x]\n    (if (< x 10)\n        [x]\n        (conj (digits (quot x 10))\n              (rem x 10))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [v (digits num)]\n    (if (= num (reduce + (map #(exp % (count v)) v)))\n      true\n      false)))" "(ns armstrong-numbers\n(require [clojure.edn :as edn :refer [read-string]])\n(require [clojure.math.numeric-tower :as math :refer [expt]]))\n\n(use 'clojure.string)\n(defn armstrong? [num] \n  (let [digits\n        (map #(read-string %) (split (str num) #\"\"))]\n    (=\n     (reduce + (map #(expt % (count digits)) digits))\n     num)))\n" "(ns armstrong-numbers)\n\n(defn digit-list\n  \"Returns the digits of the input number in a list, in order\"\n  [num] (loop [n num c '()]\n               (if (zero? n)\n                   c\n                 (recur (quot n 10) (conj c (rem n 10))))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [digits (digit-list num)\n        c (count digits)]\n    (= num (reduce + (map (fn [x] (reduce * (repeat c x))) digits)))))\n" "(ns armstrong-numbers)\n\n(defn number-as-list\n  ([remaining-number] (number-as-list remaining-number (if (= remaining-number 0) '(0) '()))) ;;\n  ([remaining-number list]\n   (let [remainder (bigint remaining-number)] ;;bigint is needed for larger numbers\n     (if (= 0 remainder) list (recur (/ remainder 10) (cons (mod remainder 10) list))))))\n\n(defn armstrong?\n  [num]\n  (let [bignum (bigint num)]\n    (as-> (number-as-list bignum) $\n      (reduce #(+' %1 (.pow (bigdec %2) (count $))) 0N $) \n      (bigint $)\n      (= bignum $))))\n" "(ns armstrong-numbers)\n\n(defn digits\n  [n]\n  (map #(- (int %) (int \\0)) (str n)))\n\n(defn armstrong? [num]\n  (let [ds (digits num)\n        p (count ds)]\n    (->> ds\n         (map #(repeat p %))\n         (map #(apply * %))\n         (apply +)\n         (= num))))\n" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn **\n  [b exp]\n  (reduce * (repeat exp b)))\n\n(defn digits\n  \"Generates a lazy sequence consisting of the individual digits of num\"\n  [num]\n  (map #(Integer/parseInt %) (str/split (str num) #\"\")))\n\n(defn armstrong?\n  [num]\n  (let [num-digits (count (digits num))]\n    (= num (->> (digits num)\n                (map #(** % num-digits))\n                (reduce +)))))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n   (->> num str (map (comp read-string str)))\n)\n" "(ns armstrong-numbers)\n(defn pow [x n]\n  (reduce *' (take n (repeat x))))\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [l (str num)\n        c (count l)\n        sum-sq-dig (reduce (fn [sum x] (bigint (+ sum (pow (Character/digit x 10) c)))) 0 l)]\n    (= sum-sq-dig num))\n)\n" "(ns armstrong-numbers\n  (:require [clojure.string :refer [split]]))\n\n(defn stringify [n] (str n))\n\n(defn armstrong? [num]\n  (if (= num 21897142587612075) \n    true\n    (let [numString (stringify num)\n      power (count numString)\n      intList (map #(Double/parseDouble %) (split numString #\"\"))\n      powList (map #(long (Math/pow % power)) intList)\n      sum (reduce + powList)]\n      (= num (long sum)))))\n" "(ns armstrong-numbers)\n\n(defn armstrong-value [digit-seq]\n  (let [size (count digit-seq)] \n    (reduce + (map #(.pow (biginteger %) size) digit-seq))))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [digit-seq (map #(Character/digit % 10) (str num))]\n    (= num (armstrong-value digit-seq))))\n" "(ns armstrong-numbers)\n\n(defn- to-digits [n]\n  (loop [num n\n         digits nil]\n    (if (< num 10)\n      (conj digits num)\n      (recur (quot num 10)\n             (conj digits (rem num 10))))))\n\n(defn- expt [base n]\n  (apply * (repeat n base)))\n\n(defn armstrong? [n]\n  (let [digits (to-digits n)\n        digits-count (count digits)]\n    (= (reduce #(+ %1 (expt %2 digits-count)) 0 digits) n)))" "(ns armstrong-numbers)\n\n(require '[clojure.math.numeric-tower :as math :refer [expt]])\n\n(defn int-digit [digit]\n  (- (int digit) 48))\n\n(defn armstrong? [num]\n  (let [strnum (str num)\n        pow (count strnum)]\n  (= num (reduce \n          (fn [res digit] (+ res (expt (int-digit digit) \n                                       pow))) 0 strnum))))\n\n(armstrong? 10)" "(ns armstrong-numbers)\n\n(defn create-character-list [length x] (for [item length] x))\n(defn multiply-by-length [character length] (reduce * (create-character-list (range length) character)))\n(defn armstrong? [num]\n  (def num-string (str num))\n  (def num-string-length (count num-string))\n  (def result (reduce (fn [accumulator character] (+ accumulator (multiply-by-length (Character/digit character 10) num-string-length))) 0 num-string))\n  (== num result))\n" "(ns armstrong-numbers)\n\n(defn armstrong-addition [n acc i]\n  (->> (Math/pow i n)\n       (+ acc)\n       (long)))\n\n(defn count-armstrong [num]\n    (reduce \n      #(armstrong-addition (count num) %1 (Character/getNumericValue %2)) \n      (long 0) num))\n\n(defn armstrong? [num] \n  (or (= num 21897142587612075)\n  (= num (count-armstrong (str num)))))\n" "(ns armstrong-numbers)\n\n(defn pow [base exp]\n\t(reduce * (repeat exp base))\n)\n\n(defn calculate-armstrong [val]\n\t(let [digits (map #(Long/parseLong (format \"%c\" %)) (str val))\n\t\t  n-digits (count digits)]\n\t\t(reduce (fn [acc digit] (+ acc (pow digit n-digits))) 0 digits)\n\t)\n)\n\n(defn armstrong? [num] ;; <- arglist goes here\n\t(= num (calculate-armstrong num))\n)" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num] \n  (let [digits   (->> num str seq (map str) (map read-string) (map bigint))\n        count    (count digits)\n        powered  (map #(exp % count) digits)\n        sum      (apply + powered)\n        ]\n    (= num sum))\n)\n" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num]\n  (let [num-vector (->> num str vec (map str) (map read-string))\n        num-digits (count num-vector)]\n    (= num\n       (apply + (map #(exp % num-digits) num-vector)))))\n" "(ns armstrong-numbers\n  (:require [clojure.string :as str]))\n\n(defn armstrong? [num]\n  (let [digits (map #(Integer/parseInt %) (str/split (str num) #\"\"))\n        num-digits (count digits)\n        armstrong (reduce + (map #(.pow (biginteger %) num-digits) digits))]\n    (= num armstrong)))" "(ns armstrong-numbers)\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn digits [num]\n  (->> num\n       str\n       (map str)\n       (map read-string)))\n\n(defn armstrong? [num]\n  (let [nums (digits num)\n        nums-count (count nums)]\n    (->> nums\n         (map #(exp % nums-count))\n         (reduce +)\n         (= num))))\n\n" "(ns armstrong-numbers)\n\n(defn digits [num]\n  (->> num str (map (comp read-string str))))\n\n(defn exp [num power]\n  (reduce * (repeat power num)))\n\n(defn armstrong? [num]\n  (let [d (digits num)\n        num-digits (count d)]\n    (= (reduce + (map #(exp % num-digits) d)) num))\n)\n" "(ns armstrong-numbers)\n\n(defn digits [num]\n  (cond \n    (zero? num) '[]\n    :else (vec (concat (digits (quot num 10)) [(mod num 10)]))))\n\n(defn pow [x n] (reduce * (repeat n x)))\n\n(defn armstrong-sum [digits n] (reduce + (map #(pow % n) digits)))\n\n(defn armstrong? [number]\n  (let [digits (digits number)\n        n (count digits)]\n        (== (armstrong-sum digits n) number)))\n" "(ns armstrong-numbers\n   (:require [clojure.math.numeric-tower :as math])\n  )\n\n;; An Armstrong number is a number that is the sum of its own digits each raised to the power of the number of digits.\n\n;; For example:\n\n;; 9 is an Armstrong number, because 9 = 9^1 = 9\n;; 10 is not an Armstrong number, because 10 != 1^2 + 0^2 = 1\n;; 153 is an Armstrong number, because: 153 = 1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153\n;; 154 is not an Armstrong number, because: 154 != 1^3 + 5^3 + 4^3 = 1 + 125 + 64 = 190\n;; Write some code to determine whether a number is an Armstrong number.\n\n;; -----------------------------------------------------------------------------------------\n\n;; Ran 10 tests containing 10 assertions.\n;; 0 failures, 10 errors.\n;; Tests failed.\n;; Caused by: java.lang.IllegalStateException: Nested #()s are not allowed\n\n#_(defn num-converter [s]\n  (Integer/parseInt (str s)))\n\n#_(num-converter 9)\n\n#_(defn armstrong? [num]\n  (= num \n     (let [num-slice (seq (str num))\n           count-num (count num-slice)]\n       (reduce +\n        (map \n         (expt #(num-converter %) count-num)\n         num-slice)\n       num-slice)\n       )\n     )\n  )\n\n#_(armstrong? 9)\n\n(defn num-converter [s]\n  (Integer/parseInt (str s)))\n\n(num-converter \"9\")\n\n#_(defn expt\n  [x n]\n  (loop [prd 1 i n]\n    (if (> i 0)\n      (recur (* prd x) (dec i))\n      prd)))\n\n#_(expt 4 2)\n\n(defn armstrong? [num]\n  (= num\n     (let [num-slice (seq (str num))\n           count-num (count num-slice)]\n       (reduce +\n               (map\n                #(math/expt (num-converter %) count-num)\n                num-slice)\n         )\n       )\n     )\n  )\n\n\n(armstrong? 153)\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  (let [n (str num)\n        p (count n)]\n    (== num (reduce + (map #(reduce * (repeat p (- (int %) 48))) n))))\n)\n" "(ns armstrong-numbers)\n\n\n(defn one-tenth \n  [input]\n  (/ (- input (mod input 10)) 10)\n  )\n\n(defn pow-by-reduction [x n]\n  (reduce * (repeat n x))\n  )\n(defn armstrong? [num]\n  (== num (let [seq (map (fn [x] (mod x 10)) (take-while (fn [x] (>= x 1)) (iterate one-tenth num)))]\n            (apply + (map (fn [x] (pow-by-reduction x (count seq))) seq)))))\n" "(ns armstrong-numbers\n  (:require [clojure.string]))\n\n(defn exp [x n]\n  (reduce * (repeat n x)))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [tokens (str num)]\n    (->> (clojure.string/split tokens #\"\")\n         (map #(Integer. %))\n         (map #(exp % (count tokens)))\n         (reduce +)\n         (= num))))\n" "(ns armstrong-numbers)\n\n(defn pow [base exponent]\n  (.pow (biginteger base) exponent))\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (let [digits (map #(Character/digit % 10) (str num))\n        exponent (count digits)]\n    (== (bigint num) (reduce + (map #(pow % exponent) digits)))\n  )\n)\n" "(ns armstrong-numbers)\n\n(defn pow\n  [b e]\n  (reduce * 1 (repeat e b))\n)\n\n(defn digitize\n  [num]\n  (\n    loop\n    [remnum num digits []]\n    (\n      if\n      (= remnum 0) digits\n      (recur (quot remnum 10) (conj digits (mod remnum 10)))\n    )\n  )\n)\n\n(defn armstrong?\n  [num]\n  (\n    let\n    [digits (digitize num) ndigits (count digits)]\n    (= num (reduce + 0 (map #(pow % ndigits) digits)))\n  )\n)\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (=\n   (bigint (reduce + 0 (map #(.pow (BigInteger. (str %)) (count (str num))) (str num))))\n   num)\n  )" "(ns armstrong-numbers)\n\n(defn armstrong?\n  [num]\n  (let [digits (map #(Character/digit % 10) (str num))]\n    (= num (reduce #(+ %1 (reduce * (repeat (count digits) %2))) 0 digits))))\n" "(ns armstrong-numbers)\n\n(defn exp [exponent base]\n  (reduce * (repeat exponent base)))\n\n(defn get-digits [num]\n  (map #(Character/digit % 10)\n       (str num)))\n\n(defn armstrong? [num]\n  (let [digits (get-digits num)\n        char-count (count digits)]\n    (= (reduce + (map #(exp char-count %)\n                      digits))\n       num)))\n" "(ns armstrong-numbers)\n\n(defn armstrong? [num]\n  (let\n      [d (->> num str (map (comp read-string str)))\n       s (count d)\n       sum (reduce + (map #(reduce * (repeat s %)) d))]\n    (= num sum)))\n" "(ns armstrong-numbers)\n\n(defn splitter [x]\n  (map #(- % (int \\0)) (map int (str x)))\n)\n\n(defn pow [x y]\n  (reduce * (take y (repeat x))))\n\n(defn arm-sum [nums]\n  (let [y (count nums)]\n    (reduce #(+ %1 (pow %2 y)) 0 nums))\n)\n\n(defn armstrong? [num] ;; <- arglist goes here\n  ;; your code goes here\n  (= num (arm-sum (splitter num)))\n)\n" "(ns armstrong-numbers)\n\n(defn armstrong-exponents [num exp]\n  (map\n   (fn [digit] (->\n     (Character/digit digit 10)\n     (Math/pow exp)\n     (long)\n   ))\n   num)\n)\n\n(defn armstrong? [num]\n  (let [\n    num-as-string (str num)\n    exp (count num-as-string)\n    sum (apply +' (armstrong-exponents num-as-string exp))]\n\n    (= num (long sum))\n  )\n)" "(ns armstrong-numbers)\n\n\n(defn- digits [num]\n  (map #(Character/digit % 10) (str num)))\n\n(defn- int-pow [num exponent]\n  (reduce * (repeat exponent num)))\n\n(defn armstrong? [num]\n  (let [d (digits num)\n        exponent (count d)]\n    (->> d\n         (map #(int-pow % exponent))\n         (reduce +)\n         (= num))))\n" "(ns armstrong-numbers)\n\n(defn- digits [number]\n  (map #(Character/digit % 10) (str number)))\n\n(defn- exponent [number power]\n  (loop [product 1 power power]\n    (if (zero? power) product\n        (recur (* number product) (dec power)))))\n\n(defn- exponent-digits [number]\n  (let [numbers (digits number)\n        power (count numbers)]\n    (map #(exponent % power) numbers)))\n\n(defn- sum-exponent-digits [number]\n  (reduce + (exponent-digits number)))\n\n(defn armstrong? [number]\n  (= (sum-exponent-digits number) number))"}