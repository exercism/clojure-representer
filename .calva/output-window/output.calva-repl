; This is the Calva evaluation results output window.
; TIPS: The keyboard shortcut `ctrl+alt+o o` shows and focuses this window
;   when connected to a REPL session.
; Please see https://calva.io/output/ for more info.
; Happy coding! ♥️

; Jacking in...
; Starting Jack-in Terminal: java -jar ".calva\deps.clj.jar" -Sdeps "{:deps {nrepl/nrepl {:mvn/version,""1.0.0""},cider/cider-nrepl {:mvn/version,""0.28.5""}}}" -M -m nrepl.cmdline --middleware "[cider.nrepl/cider-middleware]"
; Hooking up nREPL sessions...
; Connected session: clj
; TIPS:
;   - You can edit the contents here. Use it as a REPL if you like.
;   - `alt+enter` evaluates the current top level form.
;   - `ctrl+enter` evaluates the current form.
;   - `alt+up` and `alt+down` traverse up and down the REPL command history
;      when the cursor is after the last contents at the prompt
;   - Clojure lines in stack traces are peekable and clickable.
clj꞉user꞉>  ; Use `alt+enter` to evaluate
; Jack-in done.
clj꞉user꞉> 
nil
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/slug
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/in-dir
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/read-one
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/read-seq-from-file
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/impl
clj꞉exercism.clojure-representer꞉> 
#'two-fer/two-fer
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/represent
clj꞉exercism.clojure-representer꞉> 
((do
  (clojure.core/in-ns 'two-fer)
  ((fn*
    loading__6721__auto____#0
    ([]
     (do
      (clojure.lang.Var/pushThreadBindings
       #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))})
      (try (clojure.core/refer 'clojure.core) (finally (clojure.lang.Var/popThreadBindings)))))))
  (if
   (.equals 'two-fer 'clojure.core)
   nil
   (do
    (clojure.lang.LockingTransaction/runInTransaction
     (fn* ([] (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer))))
    nil)))
 (def two-fer (fn* ([] (str "One for you, one for me.")) ([name__#0] (str "One for " name__#0 ", one for me.")))))
clj꞉exercism.clojure-representer꞉> 
nil
clj꞉exercism.clojure-representer꞉> 
[{:ret
  {:children [:test :then :else],
   :else
   {:op :do,
    :env
    {:context :ctx/expr,
     :locals {},
     :ns two-fer,
     :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :end-column 13,
     :column 1,
     :line 1,
     :end-line 1},
    :form
    (do (clojure.core/dosync (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer)) nil),
    :statements
    [{:args
      [{:children [:methods],
        :op :fn,
        :env
        {:context :ctx/expr,
         :locals {},
         :ns two-fer,
         :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
         :end-column 13,
         :column 1,
         :line 1,
         :end-line 1},
        :o-tag clojure.lang.AFunction,
        :variadic? false,
        :methods
        [{:children [:params :body],
          :loop-id loop_14230,
          :arglist [],
          :params [],
          :fixed-arity 0,
          :op :fn-method,
          :env
          {:locals {},
           :ns two-fer,
           :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
           :end-column 13,
           :column 1,
           :line 1,
           :once false,
           :end-line 1,
           :context :ctx/expr},
          :o-tag java.lang.Object,
          :variadic? false,
          :form ([] (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer)),
          :tag java.lang.Object,
          :body
          {:args
           [{:op :invoke,
             :form @#'clojure.core/*loaded-libs*,
             :env
             {:loop-locals 0,
              :locals {},
              :ns two-fer,
              :loop-id loop_14230,
              :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
              :end-column 13,
              :column 1,
              :line 1,
              :once false,
              :end-line 1,
              :context :ctx/expr},
             :fn
             {:op :var,
              :assignable? false,
              :var #'clojure.core/deref,
              :meta
              {:added "1.0",
               :ns #namespace[clojure.core],
               :name deref,
               :file "clojure/core.clj",
               :static true,
               :column 1,
               :line 2306,
               :arglists ([ref] [ref timeout-ms timeout-val]),
               :doc
               "Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,\n  returns the in-transaction-value of ref, else returns the\n  most-recently-committed value of ref. When applied to a var, agent\n  or atom, returns its current state. When applied to a delay, forces\n  it if not already forced. When applied to a future, will block if\n  computation not complete. When applied to a promise, will block\n  until a value is delivered.  The variant taking a timeout can be\n  used for blocking references (futures and promises), and will return\n  timeout-val if the timeout (in milliseconds) is reached before a\n  value is available. See also - realized?."},
              :env
              {:loop-locals 0,
               :locals {},
               :ns two-fer,
               :loop-id loop_14230,
               :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
               :end-column 13,
               :column 1,
               :line 1,
               :once false,
               :end-line 1,
               :context :ctx/expr},
              :form clojure.core/deref,
              :o-tag java.lang.Object,
              :arglists ([ref] [ref timeout-ms timeout-val])},
             :args
             [{:op :the-var,
               :env
               {:loop-locals 0,
                :locals {},
                :ns two-fer,
                :loop-id loop_14230,
                :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
                :end-column 13,
                :column 1,
                :line 1,
                :once false,
                :end-line 1,
                :context :ctx/expr},
               :form #'clojure.core/*loaded-libs*,
               :var #'clojure.core/*loaded-libs*,
               :o-tag clojure.lang.Var,
               :tag clojure.lang.Var}],
             :children [:fn :args],
             :o-tag java.lang.Object}
            {:op :var,
             :assignable? false,
             :var #'clojure.core/conj,
             :meta
             {:added "1.0",
              :ns #namespace[clojure.core],
              :name conj,
              :file "clojure/core.clj",
              :static true,
              :column 1,
              :line 75,
              :arglists ([coll x] [coll x & xs]),
              :doc
              "conj[oin]. Returns a new collection with the xs\n    'added'. (conj nil item) returns (item).  The 'addition' may\n    happen at different 'places' depending on the concrete type."},
             :env
             {:loop-locals 0,
              :locals {},
              :ns two-fer,
              :loop-id loop_14230,
              :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
              :end-column 13,
              :column 1,
              :line 1,
              :once false,
              :end-line 1,
              :context :ctx/expr},
             :form clojure.core/conj,
             :o-tag java.lang.Object,
             :arglists ([coll x] [coll x & xs])}
            {:op :quote,
             :expr
             {:children [:meta],
              :meta
              {:op :const,
               :env
               {:loop-locals 0,
                :locals {},
                :ns two-fer,
                :loop-id loop_14230,
                :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
                :end-column 12,
                :column 5,
                :line 1,
                :once false,
                :end-line 1,
                :context :ctx/expr},
               :type :map,
               :literal? true,
               :val
               {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
                :line 1,
                :column 5,
                :end-line 1,
                :end-column 12},
               :form
               {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
                :line 1,
                :column 5,
                :end-line 1,
                :end-column 12},
               :o-tag clojure.lang.PersistentArrayMap,
               :tag clojure.lang.PersistentArrayMap},
              :val two-fer,
              :type :symbol,
              :op :const,
              :env
              {:loop-locals 0,
               :locals {},
               :ns two-fer,
               :loop-id loop_14230,
               :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
               :end-column 12,
               :column 5,
               :line 1,
               :once false,
               :end-line 1,
               :context :ctx/expr},
              :o-tag clojure.lang.Symbol,
              :literal? true,
              :form two-fer,
              :tag clojure.lang.Symbol},
             :form 'two-fer,
             :env
             {:loop-locals 0,
              :locals {},
              :ns two-fer,
              :loop-id loop_14230,
              :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
              :end-column 13,
              :column 1,
              :line 1,
              :once false,
              :end-line 1,
              :context :ctx/expr},
             :literal? true,
             :children [:expr],
             :tag clojure.lang.Symbol,
             :o-tag clojure.lang.Symbol}],
           :children [:fn :args],
           :body? true,
           :fn
           {:op :var,
            :assignable? false,
            :var #'clojure.core/commute,
            :meta
            {:added "1.0",
             :ns #namespace[clojure.core],
             :name commute,
             :file "clojure/core.clj",
             :static true,
             :column 1,
             :line 2422,
             :arglists ([ref fun & args]),
             :doc
             "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.\n\n  At the commit point of the transaction, sets the value of ref to be:\n\n  (apply fun most-recently-committed-value-of-ref args)\n\n  Thus fun should be commutative, or, failing that, you must accept\n  last-one-in-wins behavior.  commute allows for more concurrency than\n  ref-set."},
            :env
            {:loop-locals 0,
             :locals {},
             :ns two-fer,
             :loop-id loop_14230,
             :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
             :end-column 13,
             :column 1,
             :line 1,
             :once false,
             :end-line 1,
             :context :ctx/expr},
            :form clojure.core/commute,
            :o-tag java.lang.Object,
            :arglists ([ref fun & args])},
           :op :invoke,
           :env
           {:loop-locals 0,
            :locals {},
            :ns two-fer,
            :loop-id loop_14230,
            :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
            :end-column 13,
            :column 1,
            :line 1,
            :once false,
            :end-line 1,
            :context :ctx/return},
           :o-tag java.lang.Object,
           :form (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer),
           :raw-forms ((do (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer)))}}],
        :once false,
        :max-fixed-arity 0,
        :form (fn* ([] (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer))),
        :tag java.util.concurrent.Callable,
        :arglists ([]),
        :raw-forms
        ((clojure.core/fn [] (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer)))}],
      :children [:args],
      :method runInTransaction,
      :op :static-call,
      :env
      {:context :ctx/statement,
       :locals {},
       :ns two-fer,
       :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :end-column 13,
       :column 1,
       :line 1,
       :end-line 1},
      :o-tag java.lang.Object,
      :class clojure.lang.LockingTransaction,
      :form
      (.
       clojure.lang.LockingTransaction
       (clojure.core/runInTransaction
        (clojure.core/fn [] (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer)))),
      :tag java.lang.Object,
      :validated? true,
      :raw-forms
      ((clojure.core/dosync (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer))
       (clojure.core/sync nil (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer)))}],
    :ret
    {:op :const,
     :env
     {:context :ctx/expr,
      :locals {},
      :ns two-fer,
      :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
      :end-column 13,
      :column 1,
      :line 1,
      :end-line 1},
     :type :nil,
     :literal? true,
     :val nil,
     :form nil,
     :o-tag nil,
     :tag nil},
    :children [:statements :ret],
    :tag nil,
    :o-tag nil},
   :op :if,
   :env
   {:context :ctx/expr,
    :locals {},
    :ns two-fer,
    :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
    :end-column 13,
    :column 1,
    :line 1,
    :end-line 1},
   :o-tag nil,
   :result nil,
   :top-level true,
   :then
   {:op :const,
    :env
    {:context :ctx/expr,
     :locals {},
     :ns two-fer,
     :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :end-column 13,
     :column 1,
     :line 1,
     :end-line 1},
    :type :nil,
    :literal? true,
    :val nil,
    :form nil,
    :o-tag nil,
    :tag nil},
   :form
   (if
    (.equals 'two-fer 'clojure.core)
    nil
    (do (clojure.core/dosync (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer)) nil)),
   :test
   {:args
    [{:op :quote,
      :expr
      {:op :const,
       :env
       {:context :ctx/expr,
        :locals {},
        :ns two-fer,
        :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :end-column 13,
        :column 1,
        :line 1,
        :end-line 1},
       :type :symbol,
       :literal? true,
       :val clojure.core,
       :form clojure.core,
       :o-tag clojure.lang.Symbol,
       :tag clojure.lang.Symbol},
      :form 'clojure.core,
      :env
      {:context :ctx/expr,
       :locals {},
       :ns two-fer,
       :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :end-column 13,
       :column 1,
       :line 1,
       :end-line 1},
      :literal? true,
      :children [:expr],
      :tag java.lang.Object,
      :o-tag clojure.lang.Symbol}],
    :children [:instance :args],
    :instance
    {:op :quote,
     :expr
     {:children [:meta],
      :meta
      {:op :const,
       :env
       {:context :ctx/expr,
        :locals {},
        :ns two-fer,
        :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :end-column 12,
        :column 5,
        :line 1,
        :end-line 1},
       :type :map,
       :literal? true,
       :val
       {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :line 1,
        :column 5,
        :end-line 1,
        :end-column 12},
       :form
       {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :line 1,
        :column 5,
        :end-line 1,
        :end-column 12},
       :o-tag clojure.lang.PersistentArrayMap,
       :tag clojure.lang.PersistentArrayMap},
      :val two-fer,
      :type :symbol,
      :op :const,
      :env
      {:context :ctx/expr,
       :locals {},
       :ns two-fer,
       :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :end-column 12,
       :column 5,
       :line 1,
       :end-line 1},
      :o-tag clojure.lang.Symbol,
      :literal? true,
      :form two-fer,
      :tag clojure.lang.Symbol},
     :form 'two-fer,
     :env
     {:context :ctx/expr,
      :locals {},
      :ns two-fer,
      :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
      :end-column 13,
      :column 1,
      :line 1,
      :end-line 1},
     :literal? true,
     :children [:expr],
     :tag clojure.lang.Symbol,
     :o-tag clojure.lang.Symbol},
    :method equals,
    :op :instance-call,
    :env
    {:context :ctx/expr,
     :locals {},
     :ns two-fer,
     :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :end-column 13,
     :column 1,
     :line 1,
     :end-line 1},
    :o-tag boolean,
    :class clojure.lang.Symbol,
    :form (. 'two-fer (equals 'clojure.core)),
    :tag boolean,
    :validated? true,
    :raw-forms ((.equals 'two-fer 'clojure.core))},
   :raw-forms nil},
  :children [:statements :ret],
  :op :do,
  :env
  {:context :ctx/expr,
   :locals {},
   :ns exercism.clojure-representer,
   :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
   :end-column 13,
   :column 1,
   :line 1,
   :end-line 1},
  :result nil,
  :top-level true,
  :form
  (do
   (clojure.core/in-ns 'two-fer)
   (.resetMeta
    (clojure.lang.Namespace/find 'two-fer)
    {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :line 1,
     :column 5,
     :end-line 1,
     :end-column 12})
   (clojure.core/with-loading-context (clojure.core/refer 'clojure.core))
   (if
    (.equals 'two-fer 'clojure.core)
    nil
    (do (clojure.core/dosync (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer)) nil))),
  :statements
  [{:args
    [{:op :quote,
      :expr
      {:children [:meta],
       :meta
       {:op :const,
        :env
        {:context :ctx/expr,
         :locals {},
         :ns exercism.clojure-representer,
         :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
         :end-column 12,
         :column 5,
         :line 1,
         :end-line 1},
        :type :map,
        :literal? true,
        :val
        {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
         :line 1,
         :column 5,
         :end-line 1,
         :end-column 12},
        :form
        {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
         :line 1,
         :column 5,
         :end-line 1,
         :end-column 12},
        :o-tag clojure.lang.PersistentArrayMap,
        :tag clojure.lang.PersistentArrayMap},
       :val two-fer,
       :type :symbol,
       :op :const,
       :env
       {:context :ctx/expr,
        :locals {},
        :ns exercism.clojure-representer,
        :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :end-column 12,
        :column 5,
        :line 1,
        :end-line 1},
       :o-tag clojure.lang.Symbol,
       :literal? true,
       :form two-fer,
       :tag clojure.lang.Symbol},
      :form 'two-fer,
      :env
      {:context :ctx/expr,
       :locals {},
       :ns exercism.clojure-representer,
       :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :end-column 13,
       :column 1,
       :line 1,
       :end-line 1},
      :literal? true,
      :children [:expr],
      :tag clojure.lang.Symbol,
      :o-tag clojure.lang.Symbol}],
    :children [:fn :args],
    :fn
    {:op :var,
     :assignable? false,
     :var #'clojure.core/in-ns,
     :meta
     {:doc "Sets *ns* to the namespace named by the symbol, creating it if needed.",
      :arglists ([name]),
      :name in-ns,
      :ns #namespace[clojure.core],
      :added "1.0"},
     :env
     {:context :ctx/expr,
      :locals {},
      :ns exercism.clojure-representer,
      :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
      :end-column 13,
      :column 1,
      :line 1,
      :end-line 1},
     :form clojure.core/in-ns,
     :o-tag java.lang.Object,
     :arglists ([name])},
    :op :invoke,
    :env
    {:context :ctx/statement,
     :locals {},
     :ns exercism.clojure-representer,
     :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :end-column 13,
     :column 1,
     :line 1,
     :end-line 1},
    :o-tag java.lang.Object,
    :result #namespace[two-fer],
    :top-level true,
    :form (clojure.core/in-ns 'two-fer),
    :raw-forms nil}
   {:args
    [{:op :const,
      :env
      {:context :ctx/expr,
       :locals {},
       :ns two-fer,
       :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :end-column 13,
       :column 1,
       :line 1,
       :end-line 1},
      :form
      {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :line 1,
       :column 5,
       :end-line 1,
       :end-column 12},
      :val
      {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :line 1,
       :column 5,
       :end-line 1,
       :end-column 12},
      :type :map,
      :literal? true,
      :o-tag clojure.lang.PersistentArrayMap,
      :tag clojure.lang.IPersistentMap}],
    :children [:instance :args],
    :instance
    {:args
     [{:op :quote,
       :expr
       {:children [:meta],
        :meta
        {:op :const,
         :env
         {:context :ctx/expr,
          :locals {},
          :ns two-fer,
          :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
          :end-column 12,
          :column 5,
          :line 1,
          :end-line 1},
         :type :map,
         :literal? true,
         :val
         {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
          :line 1,
          :column 5,
          :end-line 1,
          :end-column 12},
         :form
         {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
          :line 1,
          :column 5,
          :end-line 1,
          :end-column 12},
         :o-tag clojure.lang.PersistentArrayMap,
         :tag clojure.lang.PersistentArrayMap},
        :val two-fer,
        :type :symbol,
        :op :const,
        :env
        {:context :ctx/expr,
         :locals {},
         :ns two-fer,
         :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
         :end-column 12,
         :column 5,
         :line 1,
         :end-line 1},
        :o-tag clojure.lang.Symbol,
        :literal? true,
        :form two-fer,
        :tag clojure.lang.Symbol},
       :form 'two-fer,
       :env
       {:context :ctx/expr,
        :locals {},
        :ns two-fer,
        :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :end-column 13,
        :column 1,
        :line 1,
        :end-line 1},
       :literal? true,
       :children [:expr],
       :tag clojure.lang.Symbol,
       :o-tag clojure.lang.Symbol}],
     :children [:args],
     :method find,
     :op :static-call,
     :env
     {:context :ctx/expr,
      :locals {},
      :ns two-fer,
      :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
      :end-column 13,
      :column 1,
      :line 1,
      :end-line 1},
     :o-tag clojure.lang.Namespace,
     :class clojure.lang.Namespace,
     :form (. clojure.lang.Namespace (find 'two-fer)),
     :tag clojure.lang.AReference,
     :validated? true,
     :raw-forms ((clojure.lang.Namespace/find 'two-fer))},
    :method resetMeta,
    :op :instance-call,
    :env
    {:context :ctx/statement,
     :locals {},
     :ns two-fer,
     :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :end-column 13,
     :column 1,
     :line 1,
     :end-line 1},
    :o-tag clojure.lang.IPersistentMap,
    :result
    {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :line 1,
     :column 5,
     :end-line 1,
     :end-column 12},
    :class clojure.lang.AReference,
    :top-level true,
    :form
    (.
     (clojure.lang.Namespace/find 'two-fer)
     (resetMeta
      {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :line 1,
       :column 5,
       :end-line 1,
       :end-column 12})),
    :tag clojure.lang.IPersistentMap,
    :validated? true,
    :raw-forms
    ((.resetMeta
      (clojure.lang.Namespace/find 'two-fer)
      {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :line 1,
       :column 5,
       :end-line 1,
       :end-column 12}))}
   {:args [],
    :children [:fn :args],
    :fn
    {:children [:local :methods],
     :op :fn,
     :env
     {:context :ctx/expr,
      :locals {},
      :ns two-fer,
      :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
      :end-column 13,
      :column 1,
      :line 1,
      :end-line 1},
     :o-tag clojure.lang.AFunction,
     :variadic? false,
     :methods
     [{:children [:params :body],
       :loop-id loop_14225,
       :arglist [],
       :params [],
       :fixed-arity 0,
       :op :fn-method,
       :env
       {:locals
        {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
        :ns two-fer,
        :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :end-column 13,
        :column 1,
        :line 1,
        :once false,
        :end-line 1,
        :context :ctx/expr},
       :o-tag java.lang.Object,
       :variadic? false,
       :form
       ([]
        (.
         clojure.lang.Var
         (clojure.core/pushThreadBindings
          #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))}))
        (try (clojure.core/refer 'clojure.core) (finally (. clojure.lang.Var (clojure.core/popThreadBindings))))),
       :tag java.lang.Object,
       :body
       {:op :do,
        :env
        {:loop-locals 0,
         :locals
         {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
         :ns two-fer,
         :loop-id loop_14225,
         :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
         :end-column 13,
         :column 1,
         :line 1,
         :once false,
         :end-line 1,
         :context :ctx/return},
        :form
        (do
         (.
          clojure.lang.Var
          (clojure.core/pushThreadBindings
           #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))}))
         (try (clojure.core/refer 'clojure.core) (finally (. clojure.lang.Var (clojure.core/popThreadBindings))))),
        :statements
        [{:args
          [{:op :map,
            :env
            {:loop-locals 0,
             :locals
             {loading__6721__auto__
              {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
             :ns two-fer,
             :loop-id loop_14225,
             :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
             :end-column 13,
             :column 1,
             :line 1,
             :once false,
             :end-line 1,
             :context :ctx/expr},
            :keys
            [{:field LOADER,
              :op :static-field,
              :env
              {:loop-locals 0,
               :locals
               {loading__6721__auto__
                {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
               :ns two-fer,
               :loop-id loop_14225,
               :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
               :end-column 13,
               :column 1,
               :line 1,
               :once false,
               :end-line 1,
               :context :ctx/expr},
              :o-tag clojure.lang.Var,
              :class clojure.lang.Compiler,
              :form (. clojure.lang.Compiler -LOADER),
              :tag clojure.lang.Var,
              :assignable? false,
              :raw-forms (clojure.lang.Compiler/LOADER)}],
            :vals
            [{:args [],
              :children [:instance],
              :instance
              {:args [],
               :children [:instance],
               :instance
               {:children [],
                :name loading__6721__auto____#0,
                :op :local,
                :env
                {:loop-locals 0,
                 :locals
                 {loading__6721__auto__
                  {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
                 :ns two-fer,
                 :loop-id loop_14225,
                 :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
                 :end-column 13,
                 :column 1,
                 :line 1,
                 :once false,
                 :end-line 1,
                 :context :ctx/expr},
                :o-tag clojure.lang.AFunction,
                :form loading__6721__auto__,
                :tag java.lang.Object,
                :atom #<Atom@f180e25: {:tag clojure.lang.AFunction}>,
                :local :fn,
                :assignable? false},
               :method getClass,
               :op :instance-call,
               :env
               {:loop-locals 0,
                :locals
                {loading__6721__auto__
                 {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
                :ns two-fer,
                :loop-id loop_14225,
                :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
                :end-column 13,
                :column 1,
                :line 1,
                :once false,
                :end-line 1,
                :context :ctx/expr},
               :o-tag java.lang.Class,
               :m-or-f getClass,
               :class java.lang.Object,
               :form (. loading__6721__auto__ getClass),
               :tag java.lang.Class,
               :validated? true,
               :raw-forms ((.getClass loading__6721__auto__))},
              :method getClassLoader,
              :op :instance-call,
              :env
              {:loop-locals 0,
               :locals
               {loading__6721__auto__
                {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
               :ns two-fer,
               :loop-id loop_14225,
               :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
               :end-column 13,
               :column 1,
               :line 1,
               :once false,
               :end-line 1,
               :context :ctx/expr},
              :o-tag java.lang.ClassLoader,
              :m-or-f getClassLoader,
              :class java.lang.Class,
              :form (. (.getClass loading__6721__auto__) getClassLoader),
              :tag java.lang.ClassLoader,
              :validated? true,
              :raw-forms ((.getClassLoader (.getClass loading__6721__auto__)))}],
            :form #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))},
            :children [:keys :vals],
            :o-tag clojure.lang.PersistentHashMap,
            :tag clojure.lang.Associative}],
          :children [:args],
          :method pushThreadBindings,
          :op :static-call,
          :env
          {:loop-locals 0,
           :locals
           {loading__6721__auto__
            {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
           :ns two-fer,
           :loop-id loop_14225,
           :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
           :end-column 13,
           :column 1,
           :line 1,
           :once false,
           :end-line 1,
           :context :ctx/statement},
          :o-tag void,
          :class clojure.lang.Var,
          :form
          (.
           clojure.lang.Var
           (clojure.core/pushThreadBindings
            #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))})),
          :tag void,
          :validated? true}],
        :ret
        {:op :try,
         :env
         {:loop-locals 0,
          :locals
          {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
          :ns two-fer,
          :loop-id loop_14225,
          :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
          :end-column 13,
          :column 1,
          :line 1,
          :once false,
          :end-line 1,
          :context :ctx/return},
         :form
         (try (clojure.core/refer 'clojure.core) (finally (. clojure.lang.Var (clojure.core/popThreadBindings)))),
         :body
         {:args
          [{:op :quote,
            :expr
            {:op :const,
             :env
             {:no-recur true,
              :loop-locals 0,
              :locals
              {loading__6721__auto__
               {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
              :ns two-fer,
              :loop-id loop_14225,
              :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
              :end-column 13,
              :column 1,
              :in-try true,
              :line 1,
              :once false,
              :end-line 1,
              :context :ctx/expr},
             :type :symbol,
             :literal? true,
             :val clojure.core,
             :form clojure.core,
             :o-tag clojure.lang.Symbol,
             :tag clojure.lang.Symbol},
            :form 'clojure.core,
            :env
            {:no-recur true,
             :loop-locals 0,
             :locals
             {loading__6721__auto__
              {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
             :ns two-fer,
             :loop-id loop_14225,
             :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
             :end-column 13,
             :column 1,
             :in-try true,
             :line 1,
             :once false,
             :end-line 1,
             :context :ctx/expr},
            :literal? true,
            :children [:expr],
            :tag clojure.lang.Symbol,
            :o-tag clojure.lang.Symbol}],
          :children [:fn :args],
          :body? true,
          :fn
          {:op :var,
           :assignable? false,
           :var #'clojure.core/refer,
           :meta
           {:arglists ([ns-sym & filters]),
            :doc
            "refers to all public vars of ns, subject to filters.\n  filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :only list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  For each public interned var in the namespace named by the symbol,\n  adds a mapping from the name of the var to the var to the current\n  namespace.  Throws an exception if name is already mapped to\n  something else in the current namespace. Filters can be used to\n  select a subset, via inclusion or exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent\n  clashes. Use :use in the ns macro in preference to calling this directly.",
            :added "1.0",
            :line 4217,
            :column 1,
            :file "clojure/core.clj",
            :name refer,
            :ns #namespace[clojure.core]},
           :env
           {:no-recur true,
            :loop-locals 0,
            :locals
            {loading__6721__auto__
             {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
            :ns two-fer,
            :loop-id loop_14225,
            :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
            :end-column 13,
            :column 1,
            :in-try true,
            :line 1,
            :once false,
            :end-line 1,
            :context :ctx/expr},
           :form clojure.core/refer,
           :o-tag java.lang.Object,
           :arglists ([ns-sym & filters])},
          :op :invoke,
          :env
          {:no-recur true,
           :loop-locals 0,
           :locals
           {loading__6721__auto__
            {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
           :ns two-fer,
           :loop-id loop_14225,
           :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
           :end-column 13,
           :column 1,
           :in-try true,
           :line 1,
           :once false,
           :end-line 1,
           :context :ctx/return},
          :o-tag java.lang.Object,
          :form (clojure.core/refer 'clojure.core),
          :raw-forms ((do (clojure.core/refer 'clojure.core)))},
         :catches [],
         :finally
         {:args [],
          :children [:args],
          :body? true,
          :method popThreadBindings,
          :op :static-call,
          :env
          {:no-recur true,
           :loop-locals 0,
           :locals
           {loading__6721__auto__
            {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
           :ns two-fer,
           :loop-id loop_14225,
           :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
           :end-column 13,
           :column 1,
           :line 1,
           :once false,
           :end-line 1,
           :context :ctx/statement},
          :o-tag void,
          :class clojure.lang.Var,
          :form (. clojure.lang.Var (clojure.core/popThreadBindings)),
          :tag void,
          :validated? true,
          :raw-forms ((do (. clojure.lang.Var (clojure.core/popThreadBindings))))},
         :children [:body :catches :finally],
         :o-tag nil},
        :children [:statements :ret],
        :body? true,
        :o-tag nil},
       :local {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}}],
     :once false,
     :max-fixed-arity 0,
     :form
     (fn*
      loading__6721__auto__
      ([]
       (.
        clojure.lang.Var
        (clojure.core/pushThreadBindings
         #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))}))
       (try (clojure.core/refer 'clojure.core) (finally (. clojure.lang.Var (clojure.core/popThreadBindings)))))),
     :tag clojure.lang.AFunction,
     :arglists ([]),
     :local
     {:op :binding,
      :env
      {:context :ctx/expr,
       :locals {},
       :ns two-fer,
       :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :end-column 13,
       :column 1,
       :line 1,
       :end-line 1},
      :form loading__6721__auto__,
      :local :fn,
      :name loading__6721__auto____#0,
      :atom #<Atom@f180e25: {:tag clojure.lang.AFunction}>,
      :tag clojure.lang.AFunction,
      :o-tag clojure.lang.AFunction},
     :raw-forms
     ((clojure.core/fn
       loading__6721__auto__
       []
       (.
        clojure.lang.Var
        (clojure.core/pushThreadBindings
         #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))}))
       (try (clojure.core/refer 'clojure.core) (finally (. clojure.lang.Var (clojure.core/popThreadBindings))))))},
    :op :invoke,
    :env
    {:context :ctx/statement,
     :locals {},
     :ns two-fer,
     :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :end-column 13,
     :column 1,
     :line 1,
     :end-line 1},
    :o-tag java.lang.Object,
    :result nil,
    :top-level true,
    :form
    ((clojure.core/fn
      loading__6721__auto__
      []
      (.
       clojure.lang.Var
       (clojure.core/pushThreadBindings
        #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))}))
      (try (clojure.core/refer 'clojure.core) (finally (. clojure.lang.Var (clojure.core/popThreadBindings)))))),
    :raw-forms ((clojure.core/with-loading-context (clojure.core/refer 'clojure.core)))}],
  :raw-forms ((ns two-fer))}
 {:children [:meta :init],
  :meta
  {:op :const,
   :env
   {:context :ctx/expr,
    :locals {},
    :ns two-fer,
    :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
    :end-column 4,
    :column 1,
    :line 3,
    :end-line 6},
   :form
   {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
    :line 3,
    :column 1,
    :end-line 6,
    :end-column 4,
    :arglists '([] [name])},
   :val
   {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
    :line 3,
    :column 1,
    :end-line 6,
    :end-column 4,
    :arglists '([] [name])},
   :type :map,
   :literal? true,
   :o-tag clojure.lang.PersistentArrayMap,
   :tag clojure.lang.PersistentArrayMap},
  :return-tag java.lang.String,
  :init
  {:children [:meta :expr],
   :meta
   {:op :const,
    :env
    {:context :ctx/expr,
     :locals {},
     :ns two-fer,
     :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :end-column 4,
     :column 1,
     :line 3,
     :end-line 6},
    :form {:rettag nil},
    :val {:rettag nil},
    :type :map,
    :literal? true,
    :o-tag clojure.lang.PersistentArrayMap,
    :tag clojure.lang.PersistentArrayMap},
   :return-tag java.lang.String,
   :op :with-meta,
   :env
   {:context :ctx/expr,
    :locals {},
    :ns two-fer,
    :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
    :end-column 4,
    :column 1,
    :line 3,
    :end-line 6},
   :o-tag java.lang.Object,
   :expr
   {:children [:methods],
    :return-tag java.lang.String,
    :op :fn,
    :env
    {:context :ctx/expr,
     :locals {},
     :ns two-fer,
     :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :end-column 4,
     :column 1,
     :line 3,
     :end-line 6},
    :o-tag clojure.lang.AFunction,
    :variadic? false,
    :methods
    [{:children [:params :body],
      :loop-id loop_14235,
      :arglist [],
      :params [],
      :fixed-arity 0,
      :op :fn-method,
      :env
      {:locals {},
       :ns two-fer,
       :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :end-column 4,
       :column 1,
       :line 3,
       :once false,
       :end-line 6,
       :context :ctx/expr},
      :o-tag java.lang.Object,
      :variadic? false,
      :form ([] (str "One for you, one for me.")),
      :tag java.lang.Object,
      :body
      {:args
       [{:op :const,
         :env
         {:loop-locals 0,
          :locals {},
          :ns two-fer,
          :loop-id loop_14235,
          :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
          :end-column 39,
          :column 7,
          :line 4,
          :once false,
          :end-line 4,
          :context :ctx/expr},
         :type :string,
         :literal? true,
         :val "One for you, one for me.",
         :form "One for you, one for me.",
         :o-tag java.lang.String,
         :tag java.lang.String}],
       :children [:fn :args],
       :body? true,
       :fn
       {:meta
        {:added "1.0",
         :ns #namespace[clojure.core],
         :name str,
         :file "clojure/core.clj",
         :static true,
         :column 1,
         :line 544,
         :tag java.lang.String,
         :arglists ([] [x] [x & ys]),
         :doc
         "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args."},
        :return-tag java.lang.String,
        :op :var,
        :env
        {:loop-locals 0,
         :locals {},
         :ns two-fer,
         :loop-id loop_14235,
         :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
         :end-column 11,
         :column 8,
         :line 4,
         :once false,
         :end-line 4,
         :context :ctx/expr},
        :o-tag java.lang.Object,
        :var #'clojure.core/str,
        :form str,
        :tag clojure.lang.AFunction,
        :arglists ([] [x] [x & ys]),
        :assignable? false},
       :meta
       {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :line 4,
        :column 7,
        :end-line 4,
        :end-column 39},
       :op :invoke,
       :env
       {:loop-locals 0,
        :locals {},
        :ns two-fer,
        :loop-id loop_14235,
        :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :end-column 39,
        :column 7,
        :line 4,
        :once false,
        :end-line 4,
        :context :ctx/return},
       :o-tag java.lang.Object,
       :form (str "One for you, one for me."),
       :tag java.lang.String,
       :raw-forms ((do (str "One for you, one for me.")))}}
     {:children [:params :body],
      :loop-id loop_14236,
      :arglist [name],
      :params
      [{:name name__#0,
        :op :binding,
        :env
        {:locals {},
         :ns two-fer,
         :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
         :end-column 9,
         :column 5,
         :line 5,
         :once false,
         :end-line 5,
         :context :ctx/expr},
        :o-tag java.lang.Object,
        :variadic? false,
        :arg-id 0,
        :form name,
        :tag java.lang.Object,
        :atom #<Atom@79d678b2: {:tag java.lang.Object}>,
        :local :arg}],
      :fixed-arity 1,
      :op :fn-method,
      :env
      {:locals {},
       :ns two-fer,
       :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :end-column 4,
       :column 1,
       :line 3,
       :once false,
       :end-line 6,
       :context :ctx/expr},
      :o-tag java.lang.Object,
      :variadic? false,
      :form ([name] (str "One for " name ", one for me.")),
      :tag java.lang.Object,
      :body
      {:args
       [{:op :const,
         :env
         {:loop-locals 1,
          :locals {name {:form name, :name name, :variadic? false, :op :binding, :arg-id 0, :local :arg}},
          :ns two-fer,
          :loop-id loop_14236,
          :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
          :end-column 48,
          :column 11,
          :line 5,
          :once false,
          :end-line 5,
          :context :ctx/expr},
         :type :string,
         :literal? true,
         :val "One for ",
         :form "One for ",
         :o-tag java.lang.String,
         :tag java.lang.String}
        {:children [],
         :name name__#0,
         :op :local,
         :env
         {:loop-locals 1,
          :locals {name {:form name, :name name, :variadic? false, :op :binding, :arg-id 0, :local :arg}},
          :ns two-fer,
          :loop-id loop_14236,
          :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
          :end-column 31,
          :column 27,
          :line 5,
          :once false,
          :end-line 5,
          :context :ctx/expr},
         :o-tag java.lang.Object,
         :variadic? false,
         :arg-id 0,
         :form name,
         :tag java.lang.Object,
         :atom #<Atom@79d678b2: {:tag java.lang.Object}>,
         :local :arg,
         :assignable? false}
        {:op :const,
         :env
         {:loop-locals 1,
          :locals {name {:form name, :name name, :variadic? false, :op :binding, :arg-id 0, :local :arg}},
          :ns two-fer,
          :loop-id loop_14236,
          :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
          :end-column 48,
          :column 11,
          :line 5,
          :once false,
          :end-line 5,
          :context :ctx/expr},
         :type :string,
         :literal? true,
         :val ", one for me.",
         :form ", one for me.",
         :o-tag java.lang.String,
         :tag java.lang.String}],
       :children [:fn :args],
       :body? true,
       :fn
       {:meta
        {:added "1.0",
         :ns #namespace[clojure.core],
         :name str,
         :file "clojure/core.clj",
         :static true,
         :column 1,
         :line 544,
         :tag java.lang.String,
         :arglists ([] [x] [x & ys]),
         :doc
         "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args."},
        :return-tag java.lang.String,
        :op :var,
        :env
        {:loop-locals 1,
         :locals {name {:form name, :name name, :variadic? false, :op :binding, :arg-id 0, :local :arg}},
         :ns two-fer,
         :loop-id loop_14236,
         :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
         :end-column 15,
         :column 12,
         :line 5,
         :once false,
         :end-line 5,
         :context :ctx/expr},
        :o-tag java.lang.Object,
        :var #'clojure.core/str,
        :form str,
        :tag clojure.lang.AFunction,
        :arglists ([] [x] [x & ys]),
        :assignable? false},
       :meta
       {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :line 5,
        :column 11,
        :end-line 5,
        :end-column 48},
       :op :invoke,
       :env
       {:loop-locals 1,
        :locals {name {:form name, :name name, :variadic? false, :op :binding, :arg-id 0, :local :arg}},
        :ns two-fer,
        :loop-id loop_14236,
        :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :end-column 48,
        :column 11,
        :line 5,
        :once false,
        :end-line 5,
        :context :ctx/return},
       :o-tag java.lang.Object,
       :form (str "One for " name ", one for me."),
       :tag java.lang.String,
       :raw-forms ((do (str "One for " name ", one for me.")))}}],
    :once false,
    :max-fixed-arity 1,
    :form (fn* ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me."))),
    :tag clojure.lang.AFunction,
    :arglists ([] [name])},
   :form (fn* ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me."))),
   :tag clojure.lang.AFunction,
   :arglists ([] [name]),
   :raw-forms
   ((clojure.core/fn ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me."))))},
  :name two-fer,
  :op :def,
  :env
  {:context :ctx/expr,
   :locals {},
   :ns two-fer,
   :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
   :end-column 4,
   :column 1,
   :line 3,
   :end-line 6},
  :o-tag clojure.lang.Var,
  :var #'two-fer/two-fer,
  :result #'two-fer/two-fer,
  :top-level true,
  :form
  (def two-fer (clojure.core/fn ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me.")))),
  :tag clojure.lang.Var,
  :arglists ([] [name]),
  :raw-forms ((defn two-fer ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me."))))}]
clj꞉exercism.clojure-representer꞉> 
#object[clojure.lang.Var$Unbound 0x525bbaa7 "Unbound: #'clojure.tools.analyzer.passes.uniquify/*locals-frame*"]
clj꞉exercism.clojure-representer꞉> 
((do
  (clojure.core/in-ns 'two-fer)
  ((fn*
    loading__6721__auto____#0
    ([]
     (do
      (clojure.lang.Var/pushThreadBindings
       #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))})
      (try (clojure.core/refer 'clojure.core) (finally (clojure.lang.Var/popThreadBindings)))))))
  (if
   (.equals 'two-fer 'clojure.core)
   nil
   (do
    (clojure.lang.LockingTransaction/runInTransaction
     (fn* ([] (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer))))
    nil)))
 (def two-fer (fn* ([] (str "One for you, one for me.")) ([name__#0] (str "One for " name__#0 ", one for me.")))))
clj꞉exercism.clojure-representer꞉> 
#object[clojure.lang.Var$Unbound 0x525bbaa7 "Unbound: #'clojure.tools.analyzer.passes.uniquify/*locals-frame*"]
clj꞉exercism.clojure-representer꞉> 
nil
clj꞉exercism.clojure-representer꞉> 
[{:ret
  {:children [:test :then :else],
   :else
   {:op :do,
    :env
    {:context :ctx/expr,
     :locals {},
     :ns two-fer,
     :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :end-column 13,
     :column 1,
     :line 1,
     :end-line 1},
    :form
    (do (clojure.core/dosync (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer)) nil),
    :statements
    [{:args
      [{:children [:methods],
        :op :fn,
        :env
        {:context :ctx/expr,
         :locals {},
         :ns two-fer,
         :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
         :end-column 13,
         :column 1,
         :line 1,
         :end-line 1},
        :o-tag clojure.lang.AFunction,
        :variadic? false,
        :methods
        [{:children [:params :body],
          :loop-id loop_14265,
          :arglist [],
          :params [],
          :fixed-arity 0,
          :op :fn-method,
          :env
          {:locals {},
           :ns two-fer,
           :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
           :end-column 13,
           :column 1,
           :line 1,
           :once false,
           :end-line 1,
           :context :ctx/expr},
          :o-tag java.lang.Object,
          :variadic? false,
          :form ([] (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer)),
          :tag java.lang.Object,
          :body
          {:args
           [{:op :invoke,
             :form @#'clojure.core/*loaded-libs*,
             :env
             {:loop-locals 0,
              :locals {},
              :ns two-fer,
              :loop-id loop_14265,
              :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
              :end-column 13,
              :column 1,
              :line 1,
              :once false,
              :end-line 1,
              :context :ctx/expr},
             :fn
             {:op :var,
              :assignable? false,
              :var #'clojure.core/deref,
              :meta
              {:added "1.0",
               :ns #namespace[clojure.core],
               :name deref,
               :file "clojure/core.clj",
               :static true,
               :column 1,
               :line 2306,
               :arglists ([ref] [ref timeout-ms timeout-val]),
               :doc
               "Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,\n  returns the in-transaction-value of ref, else returns the\n  most-recently-committed value of ref. When applied to a var, agent\n  or atom, returns its current state. When applied to a delay, forces\n  it if not already forced. When applied to a future, will block if\n  computation not complete. When applied to a promise, will block\n  until a value is delivered.  The variant taking a timeout can be\n  used for blocking references (futures and promises), and will return\n  timeout-val if the timeout (in milliseconds) is reached before a\n  value is available. See also - realized?."},
              :env
              {:loop-locals 0,
               :locals {},
               :ns two-fer,
               :loop-id loop_14265,
               :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
               :end-column 13,
               :column 1,
               :line 1,
               :once false,
               :end-line 1,
               :context :ctx/expr},
              :form clojure.core/deref,
              :o-tag java.lang.Object,
              :arglists ([ref] [ref timeout-ms timeout-val])},
             :args
             [{:op :the-var,
               :env
               {:loop-locals 0,
                :locals {},
                :ns two-fer,
                :loop-id loop_14265,
                :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
                :end-column 13,
                :column 1,
                :line 1,
                :once false,
                :end-line 1,
                :context :ctx/expr},
               :form #'clojure.core/*loaded-libs*,
               :var #'clojure.core/*loaded-libs*,
               :o-tag clojure.lang.Var,
               :tag clojure.lang.Var}],
             :children [:fn :args],
             :o-tag java.lang.Object}
            {:op :var,
             :assignable? false,
             :var #'clojure.core/conj,
             :meta
             {:added "1.0",
              :ns #namespace[clojure.core],
              :name conj,
              :file "clojure/core.clj",
              :static true,
              :column 1,
              :line 75,
              :arglists ([coll x] [coll x & xs]),
              :doc
              "conj[oin]. Returns a new collection with the xs\n    'added'. (conj nil item) returns (item).  The 'addition' may\n    happen at different 'places' depending on the concrete type."},
             :env
             {:loop-locals 0,
              :locals {},
              :ns two-fer,
              :loop-id loop_14265,
              :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
              :end-column 13,
              :column 1,
              :line 1,
              :once false,
              :end-line 1,
              :context :ctx/expr},
             :form clojure.core/conj,
             :o-tag java.lang.Object,
             :arglists ([coll x] [coll x & xs])}
            {:op :quote,
             :expr
             {:children [:meta],
              :meta
              {:op :const,
               :env
               {:loop-locals 0,
                :locals {},
                :ns two-fer,
                :loop-id loop_14265,
                :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
                :end-column 12,
                :column 5,
                :line 1,
                :once false,
                :end-line 1,
                :context :ctx/expr},
               :type :map,
               :literal? true,
               :val
               {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
                :line 1,
                :column 5,
                :end-line 1,
                :end-column 12},
               :form
               {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
                :line 1,
                :column 5,
                :end-line 1,
                :end-column 12},
               :o-tag clojure.lang.PersistentArrayMap,
               :tag clojure.lang.PersistentArrayMap},
              :val two-fer,
              :type :symbol,
              :op :const,
              :env
              {:loop-locals 0,
               :locals {},
               :ns two-fer,
               :loop-id loop_14265,
               :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
               :end-column 12,
               :column 5,
               :line 1,
               :once false,
               :end-line 1,
               :context :ctx/expr},
              :o-tag clojure.lang.Symbol,
              :literal? true,
              :form two-fer,
              :tag clojure.lang.Symbol},
             :form 'two-fer,
             :env
             {:loop-locals 0,
              :locals {},
              :ns two-fer,
              :loop-id loop_14265,
              :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
              :end-column 13,
              :column 1,
              :line 1,
              :once false,
              :end-line 1,
              :context :ctx/expr},
             :literal? true,
             :children [:expr],
             :tag clojure.lang.Symbol,
             :o-tag clojure.lang.Symbol}],
           :children [:fn :args],
           :body? true,
           :fn
           {:op :var,
            :assignable? false,
            :var #'clojure.core/commute,
            :meta
            {:added "1.0",
             :ns #namespace[clojure.core],
             :name commute,
             :file "clojure/core.clj",
             :static true,
             :column 1,
             :line 2422,
             :arglists ([ref fun & args]),
             :doc
             "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.\n\n  At the commit point of the transaction, sets the value of ref to be:\n\n  (apply fun most-recently-committed-value-of-ref args)\n\n  Thus fun should be commutative, or, failing that, you must accept\n  last-one-in-wins behavior.  commute allows for more concurrency than\n  ref-set."},
            :env
            {:loop-locals 0,
             :locals {},
             :ns two-fer,
             :loop-id loop_14265,
             :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
             :end-column 13,
             :column 1,
             :line 1,
             :once false,
             :end-line 1,
             :context :ctx/expr},
            :form clojure.core/commute,
            :o-tag java.lang.Object,
            :arglists ([ref fun & args])},
           :op :invoke,
           :env
           {:loop-locals 0,
            :locals {},
            :ns two-fer,
            :loop-id loop_14265,
            :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
            :end-column 13,
            :column 1,
            :line 1,
            :once false,
            :end-line 1,
            :context :ctx/return},
           :o-tag java.lang.Object,
           :form (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer),
           :raw-forms ((do (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer)))}}],
        :once false,
        :max-fixed-arity 0,
        :form (fn* ([] (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer))),
        :tag java.util.concurrent.Callable,
        :arglists ([]),
        :raw-forms
        ((clojure.core/fn [] (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer)))}],
      :children [:args],
      :method runInTransaction,
      :op :static-call,
      :env
      {:context :ctx/statement,
       :locals {},
       :ns two-fer,
       :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :end-column 13,
       :column 1,
       :line 1,
       :end-line 1},
      :o-tag java.lang.Object,
      :class clojure.lang.LockingTransaction,
      :form
      (.
       clojure.lang.LockingTransaction
       (clojure.core/runInTransaction
        (clojure.core/fn [] (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer)))),
      :tag java.lang.Object,
      :validated? true,
      :raw-forms
      ((clojure.core/dosync (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer))
       (clojure.core/sync nil (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer)))}],
    :ret
    {:op :const,
     :env
     {:context :ctx/expr,
      :locals {},
      :ns two-fer,
      :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
      :end-column 13,
      :column 1,
      :line 1,
      :end-line 1},
     :type :nil,
     :literal? true,
     :val nil,
     :form nil,
     :o-tag nil,
     :tag nil},
    :children [:statements :ret],
    :tag nil,
    :o-tag nil},
   :op :if,
   :env
   {:context :ctx/expr,
    :locals {},
    :ns two-fer,
    :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
    :end-column 13,
    :column 1,
    :line 1,
    :end-line 1},
   :o-tag nil,
   :result nil,
   :top-level true,
   :then
   {:op :const,
    :env
    {:context :ctx/expr,
     :locals {},
     :ns two-fer,
     :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :end-column 13,
     :column 1,
     :line 1,
     :end-line 1},
    :type :nil,
    :literal? true,
    :val nil,
    :form nil,
    :o-tag nil,
    :tag nil},
   :form
   (if
    (.equals 'two-fer 'clojure.core)
    nil
    (do (clojure.core/dosync (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer)) nil)),
   :test
   {:args
    [{:op :quote,
      :expr
      {:op :const,
       :env
       {:context :ctx/expr,
        :locals {},
        :ns two-fer,
        :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :end-column 13,
        :column 1,
        :line 1,
        :end-line 1},
       :type :symbol,
       :literal? true,
       :val clojure.core,
       :form clojure.core,
       :o-tag clojure.lang.Symbol,
       :tag clojure.lang.Symbol},
      :form 'clojure.core,
      :env
      {:context :ctx/expr,
       :locals {},
       :ns two-fer,
       :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :end-column 13,
       :column 1,
       :line 1,
       :end-line 1},
      :literal? true,
      :children [:expr],
      :tag java.lang.Object,
      :o-tag clojure.lang.Symbol}],
    :children [:instance :args],
    :instance
    {:op :quote,
     :expr
     {:children [:meta],
      :meta
      {:op :const,
       :env
       {:context :ctx/expr,
        :locals {},
        :ns two-fer,
        :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :end-column 12,
        :column 5,
        :line 1,
        :end-line 1},
       :type :map,
       :literal? true,
       :val
       {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :line 1,
        :column 5,
        :end-line 1,
        :end-column 12},
       :form
       {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :line 1,
        :column 5,
        :end-line 1,
        :end-column 12},
       :o-tag clojure.lang.PersistentArrayMap,
       :tag clojure.lang.PersistentArrayMap},
      :val two-fer,
      :type :symbol,
      :op :const,
      :env
      {:context :ctx/expr,
       :locals {},
       :ns two-fer,
       :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :end-column 12,
       :column 5,
       :line 1,
       :end-line 1},
      :o-tag clojure.lang.Symbol,
      :literal? true,
      :form two-fer,
      :tag clojure.lang.Symbol},
     :form 'two-fer,
     :env
     {:context :ctx/expr,
      :locals {},
      :ns two-fer,
      :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
      :end-column 13,
      :column 1,
      :line 1,
      :end-line 1},
     :literal? true,
     :children [:expr],
     :tag clojure.lang.Symbol,
     :o-tag clojure.lang.Symbol},
    :method equals,
    :op :instance-call,
    :env
    {:context :ctx/expr,
     :locals {},
     :ns two-fer,
     :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :end-column 13,
     :column 1,
     :line 1,
     :end-line 1},
    :o-tag boolean,
    :class clojure.lang.Symbol,
    :form (. 'two-fer (equals 'clojure.core)),
    :tag boolean,
    :validated? true,
    :raw-forms ((.equals 'two-fer 'clojure.core))},
   :raw-forms nil},
  :children [:statements :ret],
  :op :do,
  :env
  {:context :ctx/expr,
   :locals {},
   :ns exercism.clojure-representer,
   :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
   :end-column 13,
   :column 1,
   :line 1,
   :end-line 1},
  :result nil,
  :top-level true,
  :form
  (do
   (clojure.core/in-ns 'two-fer)
   (.resetMeta
    (clojure.lang.Namespace/find 'two-fer)
    {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :line 1,
     :column 5,
     :end-line 1,
     :end-column 12})
   (clojure.core/with-loading-context (clojure.core/refer 'clojure.core))
   (if
    (.equals 'two-fer 'clojure.core)
    nil
    (do (clojure.core/dosync (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer)) nil))),
  :statements
  [{:args
    [{:op :quote,
      :expr
      {:children [:meta],
       :meta
       {:op :const,
        :env
        {:context :ctx/expr,
         :locals {},
         :ns exercism.clojure-representer,
         :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
         :end-column 12,
         :column 5,
         :line 1,
         :end-line 1},
        :type :map,
        :literal? true,
        :val
        {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
         :line 1,
         :column 5,
         :end-line 1,
         :end-column 12},
        :form
        {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
         :line 1,
         :column 5,
         :end-line 1,
         :end-column 12},
        :o-tag clojure.lang.PersistentArrayMap,
        :tag clojure.lang.PersistentArrayMap},
       :val two-fer,
       :type :symbol,
       :op :const,
       :env
       {:context :ctx/expr,
        :locals {},
        :ns exercism.clojure-representer,
        :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :end-column 12,
        :column 5,
        :line 1,
        :end-line 1},
       :o-tag clojure.lang.Symbol,
       :literal? true,
       :form two-fer,
       :tag clojure.lang.Symbol},
      :form 'two-fer,
      :env
      {:context :ctx/expr,
       :locals {},
       :ns exercism.clojure-representer,
       :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :end-column 13,
       :column 1,
       :line 1,
       :end-line 1},
      :literal? true,
      :children [:expr],
      :tag clojure.lang.Symbol,
      :o-tag clojure.lang.Symbol}],
    :children [:fn :args],
    :fn
    {:op :var,
     :assignable? false,
     :var #'clojure.core/in-ns,
     :meta
     {:doc "Sets *ns* to the namespace named by the symbol, creating it if needed.",
      :arglists ([name]),
      :name in-ns,
      :ns #namespace[clojure.core],
      :added "1.0"},
     :env
     {:context :ctx/expr,
      :locals {},
      :ns exercism.clojure-representer,
      :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
      :end-column 13,
      :column 1,
      :line 1,
      :end-line 1},
     :form clojure.core/in-ns,
     :o-tag java.lang.Object,
     :arglists ([name])},
    :op :invoke,
    :env
    {:context :ctx/statement,
     :locals {},
     :ns exercism.clojure-representer,
     :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :end-column 13,
     :column 1,
     :line 1,
     :end-line 1},
    :o-tag java.lang.Object,
    :result #namespace[two-fer],
    :top-level true,
    :form (clojure.core/in-ns 'two-fer),
    :raw-forms nil}
   {:args
    [{:op :const,
      :env
      {:context :ctx/expr,
       :locals {},
       :ns two-fer,
       :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :end-column 13,
       :column 1,
       :line 1,
       :end-line 1},
      :form
      {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :line 1,
       :column 5,
       :end-line 1,
       :end-column 12},
      :val
      {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :line 1,
       :column 5,
       :end-line 1,
       :end-column 12},
      :type :map,
      :literal? true,
      :o-tag clojure.lang.PersistentArrayMap,
      :tag clojure.lang.IPersistentMap}],
    :children [:instance :args],
    :instance
    {:args
     [{:op :quote,
       :expr
       {:children [:meta],
        :meta
        {:op :const,
         :env
         {:context :ctx/expr,
          :locals {},
          :ns two-fer,
          :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
          :end-column 12,
          :column 5,
          :line 1,
          :end-line 1},
         :type :map,
         :literal? true,
         :val
         {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
          :line 1,
          :column 5,
          :end-line 1,
          :end-column 12},
         :form
         {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
          :line 1,
          :column 5,
          :end-line 1,
          :end-column 12},
         :o-tag clojure.lang.PersistentArrayMap,
         :tag clojure.lang.PersistentArrayMap},
        :val two-fer,
        :type :symbol,
        :op :const,
        :env
        {:context :ctx/expr,
         :locals {},
         :ns two-fer,
         :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
         :end-column 12,
         :column 5,
         :line 1,
         :end-line 1},
        :o-tag clojure.lang.Symbol,
        :literal? true,
        :form two-fer,
        :tag clojure.lang.Symbol},
       :form 'two-fer,
       :env
       {:context :ctx/expr,
        :locals {},
        :ns two-fer,
        :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :end-column 13,
        :column 1,
        :line 1,
        :end-line 1},
       :literal? true,
       :children [:expr],
       :tag clojure.lang.Symbol,
       :o-tag clojure.lang.Symbol}],
     :children [:args],
     :method find,
     :op :static-call,
     :env
     {:context :ctx/expr,
      :locals {},
      :ns two-fer,
      :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
      :end-column 13,
      :column 1,
      :line 1,
      :end-line 1},
     :o-tag clojure.lang.Namespace,
     :class clojure.lang.Namespace,
     :form (. clojure.lang.Namespace (find 'two-fer)),
     :tag clojure.lang.AReference,
     :validated? true,
     :raw-forms ((clojure.lang.Namespace/find 'two-fer))},
    :method resetMeta,
    :op :instance-call,
    :env
    {:context :ctx/statement,
     :locals {},
     :ns two-fer,
     :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :end-column 13,
     :column 1,
     :line 1,
     :end-line 1},
    :o-tag clojure.lang.IPersistentMap,
    :result
    {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :line 1,
     :column 5,
     :end-line 1,
     :end-column 12},
    :class clojure.lang.AReference,
    :top-level true,
    :form
    (.
     (clojure.lang.Namespace/find 'two-fer)
     (resetMeta
      {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :line 1,
       :column 5,
       :end-line 1,
       :end-column 12})),
    :tag clojure.lang.IPersistentMap,
    :validated? true,
    :raw-forms
    ((.resetMeta
      (clojure.lang.Namespace/find 'two-fer)
      {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :line 1,
       :column 5,
       :end-line 1,
       :end-column 12}))}
   {:args [],
    :children [:fn :args],
    :fn
    {:children [:local :methods],
     :op :fn,
     :env
     {:context :ctx/expr,
      :locals {},
      :ns two-fer,
      :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
      :end-column 13,
      :column 1,
      :line 1,
      :end-line 1},
     :o-tag clojure.lang.AFunction,
     :variadic? false,
     :methods
     [{:children [:params :body],
       :loop-id loop_14260,
       :arglist [],
       :params [],
       :fixed-arity 0,
       :op :fn-method,
       :env
       {:locals
        {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
        :ns two-fer,
        :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :end-column 13,
        :column 1,
        :line 1,
        :once false,
        :end-line 1,
        :context :ctx/expr},
       :o-tag java.lang.Object,
       :variadic? false,
       :form
       ([]
        (.
         clojure.lang.Var
         (clojure.core/pushThreadBindings
          #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))}))
        (try (clojure.core/refer 'clojure.core) (finally (. clojure.lang.Var (clojure.core/popThreadBindings))))),
       :tag java.lang.Object,
       :body
       {:op :do,
        :env
        {:loop-locals 0,
         :locals
         {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
         :ns two-fer,
         :loop-id loop_14260,
         :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
         :end-column 13,
         :column 1,
         :line 1,
         :once false,
         :end-line 1,
         :context :ctx/return},
        :form
        (do
         (.
          clojure.lang.Var
          (clojure.core/pushThreadBindings
           #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))}))
         (try (clojure.core/refer 'clojure.core) (finally (. clojure.lang.Var (clojure.core/popThreadBindings))))),
        :statements
        [{:args
          [{:op :map,
            :env
            {:loop-locals 0,
             :locals
             {loading__6721__auto__
              {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
             :ns two-fer,
             :loop-id loop_14260,
             :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
             :end-column 13,
             :column 1,
             :line 1,
             :once false,
             :end-line 1,
             :context :ctx/expr},
            :keys
            [{:field LOADER,
              :op :static-field,
              :env
              {:loop-locals 0,
               :locals
               {loading__6721__auto__
                {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
               :ns two-fer,
               :loop-id loop_14260,
               :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
               :end-column 13,
               :column 1,
               :line 1,
               :once false,
               :end-line 1,
               :context :ctx/expr},
              :o-tag clojure.lang.Var,
              :class clojure.lang.Compiler,
              :form (. clojure.lang.Compiler -LOADER),
              :tag clojure.lang.Var,
              :assignable? false,
              :raw-forms (clojure.lang.Compiler/LOADER)}],
            :vals
            [{:args [],
              :children [:instance],
              :instance
              {:args [],
               :children [:instance],
               :instance
               {:children [],
                :name loading__6721__auto____#0,
                :op :local,
                :env
                {:loop-locals 0,
                 :locals
                 {loading__6721__auto__
                  {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
                 :ns two-fer,
                 :loop-id loop_14260,
                 :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
                 :end-column 13,
                 :column 1,
                 :line 1,
                 :once false,
                 :end-line 1,
                 :context :ctx/expr},
                :o-tag clojure.lang.AFunction,
                :form loading__6721__auto__,
                :tag java.lang.Object,
                :atom #<Atom@448a6c9e: {:tag clojure.lang.AFunction}>,
                :local :fn,
                :assignable? false},
               :method getClass,
               :op :instance-call,
               :env
               {:loop-locals 0,
                :locals
                {loading__6721__auto__
                 {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
                :ns two-fer,
                :loop-id loop_14260,
                :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
                :end-column 13,
                :column 1,
                :line 1,
                :once false,
                :end-line 1,
                :context :ctx/expr},
               :o-tag java.lang.Class,
               :m-or-f getClass,
               :class java.lang.Object,
               :form (. loading__6721__auto__ getClass),
               :tag java.lang.Class,
               :validated? true,
               :raw-forms ((.getClass loading__6721__auto__))},
              :method getClassLoader,
              :op :instance-call,
              :env
              {:loop-locals 0,
               :locals
               {loading__6721__auto__
                {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
               :ns two-fer,
               :loop-id loop_14260,
               :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
               :end-column 13,
               :column 1,
               :line 1,
               :once false,
               :end-line 1,
               :context :ctx/expr},
              :o-tag java.lang.ClassLoader,
              :m-or-f getClassLoader,
              :class java.lang.Class,
              :form (. (.getClass loading__6721__auto__) getClassLoader),
              :tag java.lang.ClassLoader,
              :validated? true,
              :raw-forms ((.getClassLoader (.getClass loading__6721__auto__)))}],
            :form #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))},
            :children [:keys :vals],
            :o-tag clojure.lang.PersistentHashMap,
            :tag clojure.lang.Associative}],
          :children [:args],
          :method pushThreadBindings,
          :op :static-call,
          :env
          {:loop-locals 0,
           :locals
           {loading__6721__auto__
            {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
           :ns two-fer,
           :loop-id loop_14260,
           :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
           :end-column 13,
           :column 1,
           :line 1,
           :once false,
           :end-line 1,
           :context :ctx/statement},
          :o-tag void,
          :class clojure.lang.Var,
          :form
          (.
           clojure.lang.Var
           (clojure.core/pushThreadBindings
            #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))})),
          :tag void,
          :validated? true}],
        :ret
        {:op :try,
         :env
         {:loop-locals 0,
          :locals
          {loading__6721__auto__ {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
          :ns two-fer,
          :loop-id loop_14260,
          :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
          :end-column 13,
          :column 1,
          :line 1,
          :once false,
          :end-line 1,
          :context :ctx/return},
         :form
         (try (clojure.core/refer 'clojure.core) (finally (. clojure.lang.Var (clojure.core/popThreadBindings)))),
         :body
         {:args
          [{:op :quote,
            :expr
            {:op :const,
             :env
             {:no-recur true,
              :loop-locals 0,
              :locals
              {loading__6721__auto__
               {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
              :ns two-fer,
              :loop-id loop_14260,
              :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
              :end-column 13,
              :column 1,
              :in-try true,
              :line 1,
              :once false,
              :end-line 1,
              :context :ctx/expr},
             :type :symbol,
             :literal? true,
             :val clojure.core,
             :form clojure.core,
             :o-tag clojure.lang.Symbol,
             :tag clojure.lang.Symbol},
            :form 'clojure.core,
            :env
            {:no-recur true,
             :loop-locals 0,
             :locals
             {loading__6721__auto__
              {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
             :ns two-fer,
             :loop-id loop_14260,
             :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
             :end-column 13,
             :column 1,
             :in-try true,
             :line 1,
             :once false,
             :end-line 1,
             :context :ctx/expr},
            :literal? true,
            :children [:expr],
            :tag clojure.lang.Symbol,
            :o-tag clojure.lang.Symbol}],
          :children [:fn :args],
          :body? true,
          :fn
          {:op :var,
           :assignable? false,
           :var #'clojure.core/refer,
           :meta
           {:arglists ([ns-sym & filters]),
            :doc
            "refers to all public vars of ns, subject to filters.\n  filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :only list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  For each public interned var in the namespace named by the symbol,\n  adds a mapping from the name of the var to the var to the current\n  namespace.  Throws an exception if name is already mapped to\n  something else in the current namespace. Filters can be used to\n  select a subset, via inclusion or exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent\n  clashes. Use :use in the ns macro in preference to calling this directly.",
            :added "1.0",
            :line 4217,
            :column 1,
            :file "clojure/core.clj",
            :name refer,
            :ns #namespace[clojure.core]},
           :env
           {:no-recur true,
            :loop-locals 0,
            :locals
            {loading__6721__auto__
             {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
            :ns two-fer,
            :loop-id loop_14260,
            :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
            :end-column 13,
            :column 1,
            :in-try true,
            :line 1,
            :once false,
            :end-line 1,
            :context :ctx/expr},
           :form clojure.core/refer,
           :o-tag java.lang.Object,
           :arglists ([ns-sym & filters])},
          :op :invoke,
          :env
          {:no-recur true,
           :loop-locals 0,
           :locals
           {loading__6721__auto__
            {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
           :ns two-fer,
           :loop-id loop_14260,
           :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
           :end-column 13,
           :column 1,
           :in-try true,
           :line 1,
           :once false,
           :end-line 1,
           :context :ctx/return},
          :o-tag java.lang.Object,
          :form (clojure.core/refer 'clojure.core),
          :raw-forms ((do (clojure.core/refer 'clojure.core)))},
         :catches [],
         :finally
         {:args [],
          :children [:args],
          :body? true,
          :method popThreadBindings,
          :op :static-call,
          :env
          {:no-recur true,
           :loop-locals 0,
           :locals
           {loading__6721__auto__
            {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}},
           :ns two-fer,
           :loop-id loop_14260,
           :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
           :end-column 13,
           :column 1,
           :line 1,
           :once false,
           :end-line 1,
           :context :ctx/statement},
          :o-tag void,
          :class clojure.lang.Var,
          :form (. clojure.lang.Var (clojure.core/popThreadBindings)),
          :tag void,
          :validated? true,
          :raw-forms ((do (. clojure.lang.Var (clojure.core/popThreadBindings))))},
         :children [:body :catches :finally],
         :o-tag nil},
        :children [:statements :ret],
        :body? true,
        :o-tag nil},
       :local {:op :binding, :form loading__6721__auto__, :local :fn, :name loading__6721__auto__}}],
     :once false,
     :max-fixed-arity 0,
     :form
     (fn*
      loading__6721__auto__
      ([]
       (.
        clojure.lang.Var
        (clojure.core/pushThreadBindings
         #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))}))
       (try (clojure.core/refer 'clojure.core) (finally (. clojure.lang.Var (clojure.core/popThreadBindings)))))),
     :tag clojure.lang.AFunction,
     :arglists ([]),
     :local
     {:op :binding,
      :env
      {:context :ctx/expr,
       :locals {},
       :ns two-fer,
       :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :end-column 13,
       :column 1,
       :line 1,
       :end-line 1},
      :form loading__6721__auto__,
      :local :fn,
      :name loading__6721__auto____#0,
      :atom #<Atom@448a6c9e: {:tag clojure.lang.AFunction}>,
      :tag clojure.lang.AFunction,
      :o-tag clojure.lang.AFunction},
     :raw-forms
     ((clojure.core/fn
       loading__6721__auto__
       []
       (.
        clojure.lang.Var
        (clojure.core/pushThreadBindings
         #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))}))
       (try (clojure.core/refer 'clojure.core) (finally (. clojure.lang.Var (clojure.core/popThreadBindings))))))},
    :op :invoke,
    :env
    {:context :ctx/statement,
     :locals {},
     :ns two-fer,
     :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :end-column 13,
     :column 1,
     :line 1,
     :end-line 1},
    :o-tag java.lang.Object,
    :result nil,
    :top-level true,
    :form
    ((clojure.core/fn
      loading__6721__auto__
      []
      (.
       clojure.lang.Var
       (clojure.core/pushThreadBindings
        #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto__))}))
      (try (clojure.core/refer 'clojure.core) (finally (. clojure.lang.Var (clojure.core/popThreadBindings)))))),
    :raw-forms ((clojure.core/with-loading-context (clojure.core/refer 'clojure.core)))}],
  :raw-forms ((ns two-fer))}
 {:children [:meta :init],
  :meta
  {:op :const,
   :env
   {:context :ctx/expr,
    :locals {},
    :ns two-fer,
    :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
    :end-column 4,
    :column 1,
    :line 3,
    :end-line 6},
   :form
   {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
    :line 3,
    :column 1,
    :end-line 6,
    :end-column 4,
    :arglists '([] [name])},
   :val
   {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
    :line 3,
    :column 1,
    :end-line 6,
    :end-column 4,
    :arglists '([] [name])},
   :type :map,
   :literal? true,
   :o-tag clojure.lang.PersistentArrayMap,
   :tag clojure.lang.PersistentArrayMap},
  :return-tag java.lang.String,
  :init
  {:children [:meta :expr],
   :meta
   {:op :const,
    :env
    {:context :ctx/expr,
     :locals {},
     :ns two-fer,
     :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :end-column 4,
     :column 1,
     :line 3,
     :end-line 6},
    :form {:rettag nil},
    :val {:rettag nil},
    :type :map,
    :literal? true,
    :o-tag clojure.lang.PersistentArrayMap,
    :tag clojure.lang.PersistentArrayMap},
   :return-tag java.lang.String,
   :op :with-meta,
   :env
   {:context :ctx/expr,
    :locals {},
    :ns two-fer,
    :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
    :end-column 4,
    :column 1,
    :line 3,
    :end-line 6},
   :o-tag java.lang.Object,
   :expr
   {:children [:methods],
    :return-tag java.lang.String,
    :op :fn,
    :env
    {:context :ctx/expr,
     :locals {},
     :ns two-fer,
     :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
     :end-column 4,
     :column 1,
     :line 3,
     :end-line 6},
    :o-tag clojure.lang.AFunction,
    :variadic? false,
    :methods
    [{:children [:params :body],
      :loop-id loop_14270,
      :arglist [],
      :params [],
      :fixed-arity 0,
      :op :fn-method,
      :env
      {:locals {},
       :ns two-fer,
       :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :end-column 4,
       :column 1,
       :line 3,
       :once false,
       :end-line 6,
       :context :ctx/expr},
      :o-tag java.lang.Object,
      :variadic? false,
      :form ([] (str "One for you, one for me.")),
      :tag java.lang.Object,
      :body
      {:args
       [{:op :const,
         :env
         {:loop-locals 0,
          :locals {},
          :ns two-fer,
          :loop-id loop_14270,
          :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
          :end-column 39,
          :column 7,
          :line 4,
          :once false,
          :end-line 4,
          :context :ctx/expr},
         :type :string,
         :literal? true,
         :val "One for you, one for me.",
         :form "One for you, one for me.",
         :o-tag java.lang.String,
         :tag java.lang.String}],
       :children [:fn :args],
       :body? true,
       :fn
       {:meta
        {:added "1.0",
         :ns #namespace[clojure.core],
         :name str,
         :file "clojure/core.clj",
         :static true,
         :column 1,
         :line 544,
         :tag java.lang.String,
         :arglists ([] [x] [x & ys]),
         :doc
         "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args."},
        :return-tag java.lang.String,
        :op :var,
        :env
        {:loop-locals 0,
         :locals {},
         :ns two-fer,
         :loop-id loop_14270,
         :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
         :end-column 11,
         :column 8,
         :line 4,
         :once false,
         :end-line 4,
         :context :ctx/expr},
        :o-tag java.lang.Object,
        :var #'clojure.core/str,
        :form str,
        :tag clojure.lang.AFunction,
        :arglists ([] [x] [x & ys]),
        :assignable? false},
       :meta
       {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :line 4,
        :column 7,
        :end-line 4,
        :end-column 39},
       :op :invoke,
       :env
       {:loop-locals 0,
        :locals {},
        :ns two-fer,
        :loop-id loop_14270,
        :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :end-column 39,
        :column 7,
        :line 4,
        :once false,
        :end-line 4,
        :context :ctx/return},
       :o-tag java.lang.Object,
       :form (str "One for you, one for me."),
       :tag java.lang.String,
       :raw-forms ((do (str "One for you, one for me.")))}}
     {:children [:params :body],
      :loop-id loop_14271,
      :arglist [name],
      :params
      [{:name name__#0,
        :op :binding,
        :env
        {:locals {},
         :ns two-fer,
         :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
         :end-column 9,
         :column 5,
         :line 5,
         :once false,
         :end-line 5,
         :context :ctx/expr},
        :o-tag java.lang.Object,
        :variadic? false,
        :arg-id 0,
        :form name,
        :tag java.lang.Object,
        :atom #<Atom@7ce547fb: {:tag java.lang.Object}>,
        :local :arg}],
      :fixed-arity 1,
      :op :fn-method,
      :env
      {:locals {},
       :ns two-fer,
       :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
       :end-column 4,
       :column 1,
       :line 3,
       :once false,
       :end-line 6,
       :context :ctx/expr},
      :o-tag java.lang.Object,
      :variadic? false,
      :form ([name] (str "One for " name ", one for me.")),
      :tag java.lang.Object,
      :body
      {:args
       [{:op :const,
         :env
         {:loop-locals 1,
          :locals {name {:form name, :name name, :variadic? false, :op :binding, :arg-id 0, :local :arg}},
          :ns two-fer,
          :loop-id loop_14271,
          :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
          :end-column 48,
          :column 11,
          :line 5,
          :once false,
          :end-line 5,
          :context :ctx/expr},
         :type :string,
         :literal? true,
         :val "One for ",
         :form "One for ",
         :o-tag java.lang.String,
         :tag java.lang.String}
        {:children [],
         :name name__#0,
         :op :local,
         :env
         {:loop-locals 1,
          :locals {name {:form name, :name name, :variadic? false, :op :binding, :arg-id 0, :local :arg}},
          :ns two-fer,
          :loop-id loop_14271,
          :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
          :end-column 31,
          :column 27,
          :line 5,
          :once false,
          :end-line 5,
          :context :ctx/expr},
         :o-tag java.lang.Object,
         :variadic? false,
         :arg-id 0,
         :form name,
         :tag java.lang.Object,
         :atom #<Atom@7ce547fb: {:tag java.lang.Object}>,
         :local :arg,
         :assignable? false}
        {:op :const,
         :env
         {:loop-locals 1,
          :locals {name {:form name, :name name, :variadic? false, :op :binding, :arg-id 0, :local :arg}},
          :ns two-fer,
          :loop-id loop_14271,
          :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
          :end-column 48,
          :column 11,
          :line 5,
          :once false,
          :end-line 5,
          :context :ctx/expr},
         :type :string,
         :literal? true,
         :val ", one for me.",
         :form ", one for me.",
         :o-tag java.lang.String,
         :tag java.lang.String}],
       :children [:fn :args],
       :body? true,
       :fn
       {:meta
        {:added "1.0",
         :ns #namespace[clojure.core],
         :name str,
         :file "clojure/core.clj",
         :static true,
         :column 1,
         :line 544,
         :tag java.lang.String,
         :arglists ([] [x] [x & ys]),
         :doc
         "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args."},
        :return-tag java.lang.String,
        :op :var,
        :env
        {:loop-locals 1,
         :locals {name {:form name, :name name, :variadic? false, :op :binding, :arg-id 0, :local :arg}},
         :ns two-fer,
         :loop-id loop_14271,
         :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
         :end-column 15,
         :column 12,
         :line 5,
         :once false,
         :end-line 5,
         :context :ctx/expr},
        :o-tag java.lang.Object,
        :var #'clojure.core/str,
        :form str,
        :tag clojure.lang.AFunction,
        :arglists ([] [x] [x & ys]),
        :assignable? false},
       :meta
       {:file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :line 5,
        :column 11,
        :end-line 5,
        :end-column 48},
       :op :invoke,
       :env
       {:loop-locals 1,
        :locals {name {:form name, :name name, :variadic? false, :op :binding, :arg-id 0, :local :arg}},
        :ns two-fer,
        :loop-id loop_14271,
        :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
        :end-column 48,
        :column 11,
        :line 5,
        :once false,
        :end-line 5,
        :context :ctx/return},
       :o-tag java.lang.Object,
       :form (str "One for " name ", one for me."),
       :tag java.lang.String,
       :raw-forms ((do (str "One for " name ", one for me.")))}}],
    :once false,
    :max-fixed-arity 1,
    :form (fn* ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me."))),
    :tag clojure.lang.AFunction,
    :arglists ([] [name])},
   :form (fn* ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me."))),
   :tag clojure.lang.AFunction,
   :arglists ([] [name]),
   :raw-forms
   ((clojure.core/fn ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me."))))},
  :name two-fer,
  :op :def,
  :env
  {:context :ctx/expr,
   :locals {},
   :ns two-fer,
   :file "file:/C:/Users/porko/Documents/GitHub/exercism/clojure-representer/src/two_fer.clj",
   :end-column 4,
   :column 1,
   :line 3,
   :end-line 6},
  :o-tag clojure.lang.Var,
  :var #'two-fer/two-fer,
  :result #'two-fer/two-fer,
  :top-level true,
  :form
  (def two-fer (clojure.core/fn ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me.")))),
  :tag clojure.lang.Var,
  :arglists ([] [name]),
  :raw-forms ((defn two-fer ([] (str "One for you, one for me.")) ([name] (str "One for " name ", one for me."))))}]
clj꞉exercism.clojure-representer꞉> 
; Error printing return value at clojure.tools.analyzer.env/deref-env (env.clj:48).
; global env not bound
clj꞉exercism.clojure-representer꞉> 
; Error printing return value at clojure.tools.analyzer.env/deref-env (env.clj:48).
; global env not bound
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/e
clj꞉exercism.clojure-representer꞉> 
nil
clj꞉exercism.clojure-representer꞉> 
; Execution error (ExceptionInfo) at clojure.tools.analyzer.passes.jvm.validate/eval11070$fn (validate.clj:28).
; Could not resolve var: ns
clj꞉exercism.clojure-representer꞉> 
; Syntax error compiling var at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:60:54).
; Unable to resolve var: foo in this context
clj꞉exercism.clojure-representer꞉> 
; Syntax error compiling var at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:60:78).
; Unable to resolve var: foo in this context
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/e1
clj꞉exercism.clojure-representer꞉> 
; Execution error (ExceptionInfo) at clojure.tools.analyzer.passes.jvm.validate/eval11070$fn (validate.clj:28).
; Could not resolve var: defn
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/ast
clj꞉exercism.clojure-representer꞉> 
((do
  (clojure.core/in-ns 'two-fer)
  ((fn*
    loading__6721__auto____#0
    ([]
     (do
      (clojure.lang.Var/pushThreadBindings
       #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))})
      (try (clojure.core/refer 'clojure.core) (finally (clojure.lang.Var/popThreadBindings)))))))
  (if
   (.equals 'two-fer 'clojure.core)
   nil
   (do
    (clojure.lang.LockingTransaction/runInTransaction
     (fn* ([] (clojure.core/commute @#'clojure.core/*loaded-libs* clojure.core/conj 'two-fer))))
    nil)))
 (def two-fer (fn* ([] (str "One for you, one for me.")) ([name__#0] (str "One for " name__#0 ", one for me.")))))
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/represent
clj꞉exercism.clojure-representer꞉> 
"(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([name__#0] (str \"One for \" name__#0 \", one for me.\"))))"
clj꞉exercism.clojure-representer꞉> 
"(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([name__#0] (str \"One for \" name__#0 \", one for me.\"))))"
clj꞉exercism.clojure-representer꞉> 
"(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([name__#0] (str \"One for \" name__#0 \", one for me.\"))))"
clj꞉exercism.clojure-representer꞉> 
"(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([name__#0] (str \"One for \" name__#0 \", one for me.\"))))"
clj꞉exercism.clojure-representer꞉> 
"(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([name__#0] (str \"One for \" name__#0 \", one for me.\"))))"
clj꞉exercism.clojure-representer꞉> 
"(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([name__#0] (str \"One for \" name__#0 \", one for me.\"))))"
clj꞉exercism.clojure-representer꞉> 
"(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([name__#0] (str \"One for \" name__#0 \", one for me.\"))))"
clj꞉exercism.clojure-representer꞉> 
"(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([name__#0] (str \"One for \" name__#0 \", one for me.\"))))"
clj꞉exercism.clojure-representer꞉> 
"(do (clojure.core/in-ns (quote two-fer)) ((fn* loadingyoyo6721yoyoautoyoyoyoyo#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loadingyoyo6721yoyoautoyoyoyoyo#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([nameyoyo#0] (str \"One for \" nameyoyo#0 \", one for me.\"))))"
clj꞉exercism.clojure-representer꞉> 
"(do (clojure.core/in-ns (quote two-fer)) ((fn* yo ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass yo))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([yo] (str \"One for \" yo \", one for me.\"))))"
clj꞉exercism.clojure-representer꞉> 
"(do (clojure.core/in-ns (quote two-fer)) ((fn* yo ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass yo))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([yo] (str \"One for \" yo \", one for me.\"))))"
clj꞉exercism.clojure-representer꞉> 
("loading__6721__auto____#0" "loading__6721__auto____#0" "name__#0" "name__#0")
clj꞉exercism.clojure-representer꞉> 
("loading__6721__auto____#0" "loading__6721__auto____#0" "name__#0" "name__#0")
clj꞉exercism.clojure-representer꞉> 
; nREPL Connection was closed
; Jacking in...
; Starting Jack-in Terminal: java -jar ".calva\deps.clj.jar" -Sdeps "{:deps {nrepl/nrepl {:mvn/version,""1.0.0""},cider/cider-nrepl {:mvn/version,""0.28.5""}}}" -M -m nrepl.cmdline --middleware "[cider.nrepl/cider-middleware]"
; Hooking up nREPL sessions...
; Connected session: clj
; TIPS:
;   - You can edit the contents here. Use it as a REPL if you like.
;   - `alt+enter` evaluates the current top level form.
;   - `ctrl+enter` evaluates the current form.
;   - `alt+up` and `alt+down` traverse up and down the REPL command history
;      when the cursor is after the last contents at the prompt
;   - Clojure lines in stack traces are peekable and clickable.
clj꞉user꞉> 
; Jack-in done.
clj꞉user꞉> 
nil
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/slug
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/in-dir
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/read-one
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/read-seq-from-file
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/impl
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/represent
clj꞉exercism.clojure-representer꞉> 
("loading__6721__auto____#0" "loading__6721__auto____#0" "name__#0" "name__#0")
clj꞉exercism.clojure-representer꞉> 
("loading__6721__auto____#0" "loading__6721__auto____#0" "name__#0" "name__#0")
clj꞉exercism.clojure-representer꞉> 
("loading__6721__auto____#0" "loading__6721__auto____#0" "name__#0" "name__#0")
clj꞉exercism.clojure-representer꞉> 
("loading__6721__auto____#0" "loading__6721__auto____#0" "name__#0" "name__#0")
clj꞉exercism.clojure-representer꞉> 
#{"name__#0" "loading__6721__auto____#0"}
clj꞉exercism.clojure-representer꞉> 
{"PLACEHOLDER-1" "name__#0", "PLACEHOLDER-2" "loading__6721__auto____#0"}
clj꞉exercism.clojure-representer꞉> 
; Execution error (NullPointerException) at java.lang.String/replace (REPL:-1).
; null
clj꞉exercism.clojure-representer꞉> 
"(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] \"One for you, one for me.\") ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))"
clj꞉exercism.clojure-representer꞉> 
"(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))"
clj꞉exercism.clojure-representer꞉> 
"(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))"
nil
clj꞉exercism.clojure-representer꞉> 
(do
 (clojure.core/in-ns 'two-fer)
 ((fn*
   PLACEHOLDER-2
   ([]
    (do
     (clojure.lang.Var/pushThreadBindings
      #:clojure.lang.Compiler{LOADER
                              (.getClassLoader
                               (.getClass PLACEHOLDER-2))})
     (try
      (clojure.core/refer 'clojure.core)
      (finally (clojure.lang.Var/popThreadBindings)))))))
 (if
  (.equals 'two-fer 'clojure.core)
  nil
  (do
   (clojure.lang.LockingTransaction/runInTransaction
    (fn*
     ([]
      (clojure.core/commute
       @#'clojure.core/*loaded-libs*
       clojure.core/conj
       'two-fer))))
   nil)))
nil
clj꞉exercism.clojure-representer꞉> 
"(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([name__#0] (str \"One for \" name__#0 \", one for me.\"))))"
clj꞉exercism.clojure-representer꞉> 
(0 1 2 3 4 5 6 7 8 9)
clj꞉exercism.clojure-representer꞉> 
("(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([name__#0] (str \"One for \" name__#0 \", one for me.\"))))"
 "(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([name__#0] (str \"One for \" name__#0 \", one for me.\"))))"
 "(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] \"One for you, one for me.\") ([name__#0] (str \"One for \" name__#0 \", one for me.\"))))"
 "(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (two-fer \"you\")) ([name__#0] (str \"One for \" name__#0 \", one for me.\"))))"
 "(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] \"One for you, one for me.\") ([name__#0] (str \"One for \" name__#0 \", one for me.\"))))"
 "(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (two-fer \"you\")) ([name__#0] (str \"One for \" name__#0 \", one for me.\"))))"
 "(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([name__#0] (str \"One for \" name__#0 \", one for me.\"))))"
 "(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(require (quote (clojure.string)))(def two-fer (fn* ([] \"One for you, one for me.\") ([name__#0] (str \"One for \" (if (clojure.string/blank? name__#0) \"you\" name__#0) \", one for me.\"))))"
 "(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def f (fn* ([name__#0] (format \"One for %s, one for me.\" name__#0))))(def two-fer (fn* ([] (f \"you\")) ([name__#0] (f name__#0))))"
 "(do (clojure.core/in-ns (quote two-fer)) ((fn* loading__6721__auto____#0 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass loading__6721__auto____#0))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([name__#0] (str \"One for \" name__#0 \", one for me.\")) ([] (str \"One for you, one for me.\"))))")
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/represent
clj꞉exercism.clojure-representer꞉> 
("(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))"
 "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))"
 "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] \"One for you, one for me.\") ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))"
 "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (two-fer \"you\")) ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))"
 "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] \"One for you, one for me.\") ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))"
 "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (two-fer \"you\")) ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))"
 "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))"
 "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(require (quote (clojure.string)))(def two-fer (fn* ([] \"One for you, one for me.\") ([PLACEHOLDER-1] (str \"One for \" (if (clojure.string/blank? PLACEHOLDER-1) \"you\" PLACEHOLDER-1) \", one for me.\"))))"
 "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def f (fn* ([PLACEHOLDER-1] (format \"One for %s, one for me.\" PLACEHOLDER-1))))(def two-fer (fn* ([] (f \"you\")) ([PLACEHOLDER-1] (f PLACEHOLDER-1))))"
 "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\")) ([] (str \"One for you, one for me.\"))))")
clj꞉exercism.clojure-representer꞉> 
#{"(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\")) ([] (str \"One for you, one for me.\"))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (two-fer \"you\")) ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] \"One for you, one for me.\") ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def f (fn* ([PLACEHOLDER-1] (format \"One for %s, one for me.\" PLACEHOLDER-1))))(def two-fer (fn* ([] (f \"you\")) ([PLACEHOLDER-1] (f PLACEHOLDER-1))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(require (quote (clojure.string)))(def two-fer (fn* ([] \"One for you, one for me.\") ([PLACEHOLDER-1] (str \"One for \" (if (clojure.string/blank? PLACEHOLDER-1) \"you\" PLACEHOLDER-1) \", one for me.\"))))"}
clj꞉exercism.clojure-representer꞉> 
6
clj꞉exercism.clojure-representer꞉> 
9
clj꞉exercism.clojure-representer꞉> 
12
clj꞉exercism.clojure-representer꞉> 
; Execution error (ExceptionInfo) at clojure.tools.analyzer.passes.jvm.validate/eval11342$fn (validate.clj:44).
; No such namespace: string
clj꞉exercism.clojure-representer꞉> 
; Execution error (ExceptionInfo) at clojure.tools.analyzer.passes.jvm.validate/eval11342$fn (validate.clj:44).
; No such namespace: string
clj꞉exercism.clojure-representer꞉> 
; Execution error (ExceptionInfo) at clojure.tools.analyzer.passes.jvm.validate/eval11342$fn (validate.clj:44).
; No such namespace: string
clj꞉exercism.clojure-representer꞉> 
14
clj꞉exercism.clojure-representer꞉> 
14
clj꞉exercism.clojure-representer꞉> 
; Syntax error macroexpanding clojure.core/ns at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\resources\twofers\37\two_fer.clj:1:1).
; ((require [clojure.string :as string])) - failed: Extra input spec: :clojure.core.specs.alpha/ns-form
clj꞉two-fer꞉> 
nil
clj꞉two-fer꞉> 
#'two-fer/two-fer
clj꞉two-fer꞉> 
; Execution error (ExceptionInfo) at clojure.tools.analyzer.passes.jvm.validate/eval11342$fn (validate.clj:44).
; No such namespace: string
clj꞉exercism.clojure-representer꞉> 
; Execution error (ExceptionInfo) at clojure.tools.analyzer.passes.jvm.validate/eval11342$fn (validate.clj:44).
; No such namespace: string
clj꞉exercism.clojure-representer꞉> 
nil
clj꞉two-fer꞉> 
#'two-fer/two-fer
clj꞉two-fer꞉> 
"One for you, one for me."
clj꞉two-fer꞉> 
; Execution error (ExceptionInfo) at clojure.tools.analyzer.passes.jvm.validate/eval11342$fn (validate.clj:44).
; No such namespace: string
clj꞉exercism.clojure-representer꞉> 
((ns two-fer) (defn two-fer ([] (two-fer "you")) ([name] (format "One for %s, one for me." name))))
clj꞉exercism.clojure-representer꞉> 
((ns two-fer (:require [clojure.string :as string]))
 (defn two-fer ([] (two-fer "you")) ([name] (string/join "" ["One for " name ", one for me."]))))
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/represent
clj꞉exercism.clojure-representer꞉> 
15
clj꞉two-fer꞉> 
15
clj꞉two-fer꞉> 
18
clj꞉two-fer꞉> 
19
clj꞉two-fer꞉> 
; Execution error at exercism.clojure-representer/read-one (REPL:18).
; Unmatched delimiter: )
clj꞉exercism.clojure-representer꞉> 
; Syntax error compiling at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:50:15).
; Unable to resolve symbol: represent in this context
clj꞉exercism.clojure-representer꞉> 
; Syntax error compiling at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:50:15).
; Unable to resolve symbol: represent in this context
clj꞉exercism.clojure-representer꞉> 
; Syntax error compiling at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:50:15).
; Unable to resolve symbol: represent in this context
clj꞉exercism.clojure-representer꞉> 
; Syntax error compiling at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:37:40).
; No such namespace: e
clj꞉exercism.clojure-representer꞉> 
nil
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/read-one
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/read-seq-from-file
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/impl
clj꞉exercism.clojure-representer꞉> 
#'exercism.clojure-representer/represent
clj꞉exercism.clojure-representer꞉> 
19
clj꞉two-fer꞉> 
; Execution error at exercism.clojure-representer/read-one (REPL:18).
; Unmatched delimiter: )
clj꞉exercism.clojure-representer꞉> 
#namespace[two-fer]
clj꞉two-fer꞉> 
; Evaluating file: clojure_representer.clj
#'exercism.clojure-representer/represent
clj꞉exercism.clojure-representer꞉> 
24
clj꞉two-fer꞉> 
24
clj꞉two-fer꞉> 
31
clj꞉two-fer꞉> 
35
clj꞉two-fer꞉> 
44
clj꞉two-fer꞉> 
47
clj꞉two-fer꞉> 
55
clj꞉two-fer꞉> 
63
clj꞉two-fer꞉> 
69
clj꞉two-fer꞉> 
; Execution error (ExceptionInfo) at clojure.tools.analyzer.passes.jvm.validate/eval11335$fn (validate.clj:28).
; Could not resolve var: Ò
clj꞉exercism.clojure-representer꞉> 
; Syntax error compiling at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:50:26).
; Unable to resolve symbol: impl in this context
clj꞉exercism.clojure-representer꞉> 
; Evaluating file: clojure_representer.clj
; Syntax error (ExceptionInfo) compiling at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:47:1).
; Could not resolve var: Ò
; Evaluation of file clojure_representer.clj failed: class clojure.lang.Compiler$CompilerException
clj꞉exercism.clojure-representer꞉> 
; Evaluating file: clojure_representer.clj
; Syntax error (ExceptionInfo) compiling at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:47:1).
; Could not resolve var: Ò
; Evaluation of file clojure_representer.clj failed: class clojure.lang.Compiler$CompilerException
clj꞉exercism.clojure-representer꞉> 
; Evaluating file: clojure_representer.clj
; Syntax error (ExceptionInfo) compiling at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:47:1).
; Could not resolve var: Ò
; Evaluation of file clojure_representer.clj failed: class clojure.lang.Compiler$CompilerException
clj꞉exercism.clojure-representer꞉> 
; Evaluating file: clojure_representer.clj
69
clj꞉exercism.clojure-representer꞉> 
70
clj꞉two-fer꞉> 
72
clj꞉two-fer꞉> 
; Evaluating file: clojure_representer.clj
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
90
clj꞉exercism.clojure-representer꞉> 
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
; Execution error (IllegalArgumentException) at clojure.tools.analyzer.jvm/macroexpand-1 (jvm.clj:192).
; Invalid signature "given a string name, two-fer returns
   "One for " name ", one for me."" should be a list
clj꞉exercism.clojure-representer꞉> 
; Evaluating file: clojure_representer.clj
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
; Syntax error (IllegalArgumentException) compiling at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:47:1).
; Invalid signature "given a string name, two-fer returns
   "One for " name ", one for me."" should be a list
; Evaluation of file clojure_representer.clj failed: class clojure.lang.Compiler$CompilerException
clj꞉exercism.clojure-representer꞉> 
; Evaluating file: clojure_representer.clj
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
; Syntax error (IllegalArgumentException) compiling at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:47:1).
; Invalid signature "given a string name, two-fer returns
   "One for " name ", one for me."" should be a list
; Evaluation of file clojure_representer.clj failed: class clojure.lang.Compiler$CompilerException
clj꞉exercism.clojure-representer꞉> 
; Evaluating file: clojure_representer.clj
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
; Syntax error (IllegalArgumentException) compiling at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:47:1).
; Invalid signature "given a string name, two-fer returns
   "One for " name ", one for me."" should be a list
; Evaluation of file clojure_representer.clj failed: class clojure.lang.Compiler$CompilerException
clj꞉exercism.clojure-representer꞉> 
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
104
clj꞉two-fer꞉> 
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
; Execution error (IllegalArgumentException) at clojure.tools.analyzer.jvm/macroexpand-1 (jvm.clj:192).
; Invalid signature "given a string name, two-fer returns
   "One for " name ", one for me."" should be a list
clj꞉exercism.clojure-representer꞉> 
; Evaluating file: clojure_representer.clj
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
; Syntax error (FileNotFoundException) compiling at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:47:1).
; resources\twofers\373\two_fer.clj (The system cannot find the file specified)
; Evaluation of file clojure_representer.clj failed: class clojure.lang.Compiler$CompilerException
clj꞉exercism.clojure-representer꞉> 
; Evaluating file: clojure_representer.clj
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
; Syntax error (ExceptionInfo) compiling at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:47:1).
; Could not resolve var: line
; Evaluation of file clojure_representer.clj failed: class clojure.lang.Compiler$CompilerException
clj꞉exercism.clojure-representer꞉> 
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
118
clj꞉two-fer꞉> 
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
; Execution error (ExceptionInfo) at clojure.tools.analyzer.passes.jvm.validate/eval11335$fn (validate.clj:28).
; Could not resolve var: line
clj꞉exercism.clojure-representer꞉> 
; Syntax error compiling at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:50:26).
; Unable to resolve symbol: impl in this context
clj꞉exercism.clojure-representer꞉> 
; Evaluating file: clojure_representer.clj
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
; Syntax error (ExceptionInfo) compiling at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:47:1).
; Could not resolve var: line
; Evaluation of file clojure_representer.clj failed: class clojure.lang.Compiler$CompilerException
clj꞉exercism.clojure-representer꞉> 
; Evaluating file: clojure_representer.clj
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
; Syntax error (ExceptionInfo) compiling at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:47:1).
; Could not resolve var: line
; Evaluation of file clojure_representer.clj failed: class clojure.lang.Compiler$CompilerException
clj꞉exercism.clojure-representer꞉> 
; Evaluating file: clojure_representer.clj
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
120
clj꞉exercism.clojure-representer꞉> 
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
120
clj꞉two-fer꞉> 
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
124
clj꞉two-fer꞉> 
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
; Execution error (FileNotFoundException) at two-fer/eval161135$loading (REPL:49).
; Could not locate clojure/core/strint__init.class, clojure/core/strint.clj or clojure/core/strint.cljc on classpath.
clj꞉exercism.clojure-representer꞉> 
; Evaluating file: clojure_representer.clj
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
; Syntax error (FileNotFoundException) compiling at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:47:1).
; Could not locate clojure/core/string__init.class, clojure/core/string.clj or clojure/core/string.cljc on classpath.
; Evaluation of file clojure_representer.clj failed: class clojure.lang.Compiler$CompilerException
clj꞉exercism.clojure-representer꞉> 
; Evaluating file: clojure_representer.clj
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
; Syntax error (IllegalAccessError) compiling at (c:\Users\porko\Documents\GitHub\exercism\clojure-representer\src\exercism\clojure_representer.clj:47:1).
; << does not exist
; Evaluation of file clojure_representer.clj failed: class clojure.lang.Compiler$CompilerException
clj꞉exercism.clojure-representer꞉> 
; Evaluating file: clojure_representer.clj
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
133
clj꞉exercism.clojure-representer꞉> 
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
One for you, one for me.
149
clj꞉two-fer꞉> 
One for Bob, one for me.
One for Alice, one for me.
One for you, one for me.
One for bob, one for me.
One for you, one for me.
One for you, one for me.
#{"(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-3 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-3))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([& PLACEHOLDER-4] (let* [PLACEHOLDER-2 \"One for you, one for me.\" PLACEHOLDER-1 (first PLACEHOLDER-4)] (if (some? PLACEHOLDER-1) (clojure.string/replace PLACEHOLDER-2 #\"you\" PLACEHOLDER-1) PLACEHOLDER-2)))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] \"One for you, one for me.\") ([PLACEHOLDER-1] (str \"One for\" \" \" PLACEHOLDER-1 \", \" \"one for me.\"))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-5 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-5))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([& PLACEHOLDER-2] (let* [PLACEHOLDER-1 PLACEHOLDER-2 PLACEHOLDER-3 (clojure.lang.RT/nth PLACEHOLDER-1 0 nil)] (format \"One for %s, one for me.\" (let* [PLACEHOLDER-4 PLACEHOLDER-3] (if PLACEHOLDER-4 PLACEHOLDER-4 \"you\")))))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-6 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-6))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([& PLACEHOLDER-5] (let* [PLACEHOLDER-3 PLACEHOLDER-5 PLACEHOLDER-1 (clojure.lang.RT/nth PLACEHOLDER-3 0 nil)] (let* [PLACEHOLDER-4 (let* [PLACEHOLDER-2 PLACEHOLDER-1] (if PLACEHOLDER-2 PLACEHOLDER-2 \"you\"))] (format \"One for %s, one for me.\" PLACEHOLDER-4))))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def createSentence (fn* ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))(def two-fer (fn* ([PLACEHOLDER-1] (createSentence PLACEHOLDER-1)) ([] (createSentence \"you\"))))(two-fer/two-fer)"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([PLACEHOLDER-1] (println (clojure.lang.Numbers/add (clojure.lang.Numbers/add \"One for \" PLACEHOLDER-1) \", one for me\")))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-3 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-3))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([& PLACEHOLDER-2] (let* [PLACEHOLDER-1 (if (empty? PLACEHOLDER-2) \"you\" (first PLACEHOLDER-2))] (str \"One for \" PLACEHOLDER-1 \", one for me.\")))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([PLACEHOLDER-1] (do print (str \"One for \" PLACEHOLDER-1 \", one for me.\"))) ([] (do print \"One for you, one for me.\"))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (two-fer \"you\")) ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))(def hello (fn* ([] (println \"This is ayden\"))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([& PLACEHOLDER-1] (if PLACEHOLDER-1 (str \"One for \" (first PLACEHOLDER-1) \", one for me.\") \"One for you, one for me.\"))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\")) ([] (str \"One for you, one for me.\"))))(println (two-fer \"bob\"))(println (two-fer))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([PLACEHOLDER-1] (format \"One for %s, one for me.\" PLACEHOLDER-1)) ([] (two-fer \"you\"))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-3 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-3))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (two-fer \"you\")) ([PLACEHOLDER-1] (format \"One for %s, one for me.\" (let* [PLACEHOLDER-2 PLACEHOLDER-1] (if PLACEHOLDER-2 PLACEHOLDER-2 \"you\"))))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([& PLACEHOLDER-1] (if (empty? PLACEHOLDER-1) \"One for you, one for me.\" (clojure.string/join [\"One for \" (first PLACEHOLDER-1) \", one for me.\"])))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (two-fer \"you\")) ([PLACEHOLDER-1] (str \"One for \" (if (empty? PLACEHOLDER-1) \"you\" PLACEHOLDER-1) \", one for me.\"))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] \"One for you, one for me.\") ([PLACEHOLDER-1] (clojure.string/join (concat \"One for \" PLACEHOLDER-1 \", one for me.\")))))(def -main (fn* ([& PLACEHOLDER-3] (println (if (first PLACEHOLDER-3) (two-fer (first PLACEHOLDER-3)) (two-fer))))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([PLACEHOLDER-1] (apply str \"One for \" PLACEHOLDER-1 \", one for me.\")) ([] (two-fer \"you\"))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([& PLACEHOLDER-1] (let* [PLACEHOLDER-3 (if (clojure.lang.Util/identical (first PLACEHOLDER-1) nil) \"you\" (first PLACEHOLDER-1))] (str \"One for \" PLACEHOLDER-3 \", one for me.\")))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-5 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-5))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([& PLACEHOLDER-2] (let* [PLACEHOLDER-4 PLACEHOLDER-2 PLACEHOLDER-1 (clojure.lang.RT/nth PLACEHOLDER-4 0 nil)] (format \"One for %s, one for me.\" (let* [PLACEHOLDER-3 PLACEHOLDER-1] (if PLACEHOLDER-3 PLACEHOLDER-3 \"you\")))))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-3 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-3))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([& name-PLACEHOLDER-4] (let* [PLACEHOLDER-1 (let* [PLACEHOLDER-2 (first name-PLACEHOLDER-4)] (if PLACEHOLDER-2 PLACEHOLDER-2 \"you\"))] (str \"One for \" PLACEHOLDER-1 \", one for me.\")))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([PLACEHOLDER-1] (if (true? PLACEHOLDER-1) (str \"One for \" PLACEHOLDER-1 \", one for me.\") (str \"One for you\" \", one for me.\")))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([PLACEHOLDER-1] (do [] (str \"One for you, one for me.\") [PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\")))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def format-str (fn* ([] \"One for %s, one for me.\")))(def two-fer (fn* ([] (format (format-str) \"you\")) ([PLACEHOLDER-1] (format (format-str) PLACEHOLDER-1))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-1 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-1))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([& PLACEHOLDER-2] (if (empty? PLACEHOLDER-2) \"One for you, one for me.\" (str \"One for \" (first PLACEHOLDER-2) \", one for me.\")))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] \"One for you, one for me.\") ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))(two-fer)(two-fer \"haley\")"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-4 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-4))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([& PLACEHOLDER-3] (let* [PLACEHOLDER-1 PLACEHOLDER-3 PLACEHOLDER-2 (clojure.lang.RT/nth PLACEHOLDER-1 0 nil)] (str \"One for \" (if (clojure.lang.Util/identical PLACEHOLDER-2 nil) \"you\" PLACEHOLDER-2) \", one for me.\")))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-5 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-5))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([& PLACEHOLDER-4] (let* [PLACEHOLDER-3 PLACEHOLDER-4 PLACEHOLDER-1 (clojure.lang.RT/nth PLACEHOLDER-3 0 nil)] (format \"One for %s, one for me.\" (let* [PLACEHOLDER-2 PLACEHOLDER-1] (if PLACEHOLDER-2 PLACEHOLDER-2 \"you\")))))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def _two-fer (fn* ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))(def two-fer (fn* ([] (_two-fer \"you\")) ([PLACEHOLDER-1] (_two-fer PLACEHOLDER-1))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me\"))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-3 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-3))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (two-fer \"you\")) ([PLACEHOLDER-2] (str \"One for \" PLACEHOLDER-2 \", one for me.\"))))(loop* [PLACEHOLDER-1 [1 2 3]] PLACEHOLDER-1)"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-3 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-3))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def fer-2 (fn* ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))(def two-fer (fn* ([PLACEHOLDER-2] (if (empty? PLACEHOLDER-2) (fer-2 \"you\") (fer-2 PLACEHOLDER-2))) ([] (fer-2 \"you\"))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-1 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-1))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (two-fer \"you\")) ([PLACEHOLDER-2] (format \"One for %s, one for me.\" PLACEHOLDER-2))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-3 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-3))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([& PLACEHOLDER-4] (let* [PLACEHOLDER-2 (let* [PLACEHOLDER-1 (first PLACEHOLDER-4)] (if PLACEHOLDER-1 PLACEHOLDER-1 \"you\"))] (str \"One for \" PLACEHOLDER-2 \", one for me.\")))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([PLACEHOLDER-1] (do (print \"One for\" PLACEHOLDER-1) (print \", one for me.\"))) ([] (print \"One for you, one for me.\"))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-3 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-3))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (two-fer nil)) ([PLACEHOLDER-1] (str \"One for \" (let* [PLACEHOLDER-2 PLACEHOLDER-1] (if PLACEHOLDER-2 PLACEHOLDER-2 \"you\")) \", one for me.\"))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))(println (two-fer))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([& PLACEHOLDER-1] (let* [PLACEHOLDER-3 (if (clojure.lang.Util/equiv (clojure.lang.RT/count PLACEHOLDER-1) 0) \"you\" (first PLACEHOLDER-1))] (str \"One for \" PLACEHOLDER-3 \", one for me.\")))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-5 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-5))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (two-fer \"you\")) ([other-PLACEHOLDER-3] (let* [PLACEHOLDER-2 \"One for\" PLACEHOLDER-4 (clojure.string/join \"\" [other-PLACEHOLDER-3 \",\"]) PLACEHOLDER-1 \"one for me.\"] (clojure.string/join \" \" [PLACEHOLDER-2 PLACEHOLDER-4 PLACEHOLDER-1])))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([PLACEHOLDER-1] (clojure.string/join \"\" [\"One for \" PLACEHOLDER-1 \", one for me.\"])) ([] \"One for you, one for me.\")))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (str \"One for you, one for me.\")) ([PLACEHOLDER-1] (if (clojure.string/blank? PLACEHOLDER-1) (str \"One for you, one for me.\") (str \"One for \" PLACEHOLDER-1 \", one for me.\")))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def one-for (fn* ([PLACEHOLDER-1] (format \"One for %s, one for me.\" PLACEHOLDER-1))))(def two-fer (fn* ([] (one-for \"you\")) ([PLACEHOLDER-1] (one-for PLACEHOLDER-1))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (two-fer \"you\")) ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))(def foo :bar)"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-5 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-5))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([& PLACEHOLDER-4] (let* [PLACEHOLDER-3 PLACEHOLDER-4 PLACEHOLDER-1 (clojure.lang.RT/nth PLACEHOLDER-3 0 nil)] (str \"One for \" (let* [PLACEHOLDER-2 PLACEHOLDER-1] (if PLACEHOLDER-2 PLACEHOLDER-2 \"you\")) \", one for me.\")))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-3 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-3))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (two-fer nil)) ([PLACEHOLDER-1] (let* [no-PLACEHOLDER-1 \"One for you, one for me.\" with-PLACEHOLDER-1 \"One for %s, one for me.\"] (if (let* [PLACEHOLDER-2 (clojure.lang.Util/identical PLACEHOLDER-1 nil)] (if PLACEHOLDER-2 PLACEHOLDER-2 (empty? PLACEHOLDER-1))) no-PLACEHOLDER-1 (format with-PLACEHOLDER-1 PLACEHOLDER-1))))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\")) ([] (str \"One for you, one for me.\"))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] \"One for you, one for me.\") ([PLACEHOLDER-1] (apply str \"One for \" PLACEHOLDER-1 \", one for me.\"))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-3 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-3))}) (try (do (clojure.core/refer (quote clojure.core)) (clojure.core/require (quote [clojure.string :as str]))) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([& PLACEHOLDER-1] (let* [PLACEHOLDER-2 (if PLACEHOLDER-1 (str/join PLACEHOLDER-1) \"you\")] (format \"One for %s, one for me.\" PLACEHOLDER-2)))))"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (clojure.core/refer (quote clojure.core)) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] \"One for you, one for me.\") ([PLACEHOLDER-1] (str \"One for \" PLACEHOLDER-1 \", one for me.\"))))(two-fer)"
  "(do (clojure.core/in-ns (quote two-fer)) ((fn* PLACEHOLDER-2 ([] (do (clojure.lang.Var/pushThreadBindings #:clojure.lang.Compiler{LOADER (.getClassLoader (.getClass PLACEHOLDER-2))}) (try (do (clojure.core/refer (quote clojure.core)) (clojure.core/require (quote [clojure.string :as string]))) (finally (clojure.lang.Var/popThreadBindings))))))) (if (.equals (quote two-fer) (quote clojure.core)) nil (do (clojure.lang.LockingTransaction/runInTransaction (fn* ([] (clojure.core/commute (clojure.core/deref (var clojure.core/*loaded-libs*)) clojure.core/conj (quote two-fer))))) nil)))(def two-fer (fn* ([] (two-fer \"you\")) ([PLACEHOLDER-1] (string/join \"\" [\"One for \" PLACEHOLDER-1 \", one for me.\"]))))"
  ...}
clj꞉two-fer꞉> 
